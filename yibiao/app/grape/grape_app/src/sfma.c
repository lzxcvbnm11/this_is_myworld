/************************************************************************************************ PROJECT : simple_draw_d1l2 app FILE : $Id: sfma.c 1164 2013-07-31 08:29:57Z florian.zimmermann $ ============================================================================ DESCRIPTION, serial flash of the simple_draw_d1l2 ============================================================================ C O P Y R I G H T ============================================================================ Copyright (c) 2015 by Renesas Electronics (Europe) GmbH. Arcadiastrasse 10 D-40472 Duesseldorf Germany All rights reserved. ============================================================================ Purpose: only for testing, not for mass production  DISCLAIMER  LICENSEE has read, understood and accepted the terms and conditions defined in the license agreement, especially the usage rights. In any case, it is LICENSEE's responsibility to make sure that any user of the software complies with the terms and conditions of the signed license agreement.  SAMPLE CODE is not part of the licensed software, as such it must not be used in mass-production applications. It can only be used for evaluation and demonstration purposes at customer's premises listed in the signed license agreement. **************************************************************************** */  /******************************************************************************* Section: Includes */  #include "r_typedefs.h" /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Renesas basic types, e.g. uint32_t */ #include "r_bsp_stdio_api.h" /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Board support package */ #include "r_bsp_api.h" /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Board support package */ #include "yd_sfma_api.h" #include "r_sfma_api.h"  #include "r_sfcdb_macronix.h" #include "r_sfcdb_spansion.h"  #include "config.h" #include "main.h"   #define SPI_FLASH_TYPE_SPANSION 1 #define SPI_FLASH_TYPE_MACRONIX 0   /*********************************************************** Section: Local Variables */ //#define DEBUG_SFMA_R #if defined(DEBUG_SFMA_R) static uint32_t loc_verifyData[4096]; #endif  //#define DEBUG_SFMA_RW #if defined(DEBUG_SFMA_RW)  static uint32_t loc_srcData [4096]; static uint32_t loc_eraseData [4096]; static uint32_t loc_verifyData[4096]; #endif  #define ADDR_SFMA_F1A1 0X010 #define SIZE_SFMA_F1A1 5  static uint32_t F1A1[SIZE_SFMA_F1A1];   /*********************************************************** Section: Local Defines */ #define LOC_SFMA_SECTOR_SIZE (4096u)  /*************************************************************************** Constant: SF_DEFAULT_CAL  Default calibration for Serial flash memory (Macronix device only).  SPBCLK clock phase shift 3 (range 0 - 7, written to the upper 16bits) Sampling point phase shift 1 (range 0 - 7, written to the Lower 16 bits) */ #define SF_SPBCLK_CLOCK_PHASE_SHIFT (3u) #define SF_SAMPLING_POINT_PHASE_SHIFT (1u) #define LOC_SFMA_DEFAULT_CAL ((SF_SPBCLK_CLOCK_PHASE_SHIFT << 16) | SF_SAMPLING_POINT_PHASE_SHIFT)  /*********************************************************** Section: Local Functions */ static void loc_SFMAConfig(yd_sfma_Config_t *Config, yd_sfma_Mode_t Mode, yd_sfma_DataTransferMode_t Transfer); /******************************************************************************* Function: SetSFMAConfig  Fills the flash device config and command structure according to the target device. */ static void loc_SFMAConfig(yd_sfma_Config_t *Config, yd_sfma_Mode_t Mode, yd_sfma_DataTransferMode_t Transfer) { if(Config != R_NULL) { Config->Mode = Mode; Config->MemoryNum = YD_SFMA_MEMORY_SINGLE; Config->DataTransferMode = Transfer; Config->AddressMode = YD_SFMA_ADDRESS_32BIT; Config->SerialFlashMemoryPageSize = 0x100uL; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr 256Byte */ Config->SerialFlashMemoryMaxClock = (80*1000*1000); Config->CacheMode = YD_SFMA_CACHE_BL8; Config->PerformanceEnMode = YD_SFMA_PER_EN_MODE_DISABLE; Config->Calibration = LOC_SFMA_DEFAULT_CAL;   if(YD_SFMA_MEMORY_DUAL == Config->MemoryNum) { Config->SerialFlashMemorySectorSize = LOC_SFMA_SECTOR_SIZE app_drw2dcpu app_menu app_tripcomp app_tutorial application.c application.h error.c error.h font.h font_data.h fonts fs_data.h hmi_manager.c hmi_manager.h img.c img.h img_data.h img_drw2d.c img_drw2d.h img_format.h main.c main.h mem_init.c mem_init.h sfma.c wm.c wm.h write.c write.h 2;  #if SPI_FLASH_TYPE_MACRONIX Config->SerialFlashMemorySize = 128*1024*1024; #endif  #if SPI_FLASH_TYPE_SPANSION Config->SerialFlashMemorySize = 128*1024*1024; #endif } else { Config->SerialFlashMemorySectorSize = LOC_SFMA_SECTOR_SIZE; #if SPI_FLASH_TYPE_MACRONIX Config->SerialFlashMemorySize = 128*1024*1024; #endif  #if SPI_FLASH_TYPE_SPANSION Config->SerialFlashMemorySize = 128*1024*1024; #endif }  #if SPI_FLASH_TYPE_MACRONIX if (YD_SFMA_ADDRESS_32BIT == Config->AddressMode) { if ((40*1000*1000) < Config->SerialFlashMemoryMaxClock) { if ((Config->DataTransferMode == YD_SFMA_SDR_QUAD_IO) || (Config->DataTransferMode == YD_SFMA_DDR_QUAD_IO)) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr at 80MHZ with external address space use performance enhance mode */ if(YD_SFMA_MODE_EX_SPACE == Mode) { Config->Command = &r_sfc_Macronix_32bitAddrCmdPerformanceEnhance_80MHz; Config->PerformanceEnMode = YD_SFMA_PER_EN_MODE_ENABLE; } else { Config->Command = &r_sfc_Macronix_32bitAddrQuadCmd_80MHz; } } else { Config->Command = &r_sfc_Macronix_32bitAddrCmd_80MHz; } } else { if ((Config->DataTransferMode == YD_SFMA_SDR_QUAD_IO) || (Config->DataTransferMode == YD_SFMA_DDR_QUAD_IO)) { Config->Command = &r_sfc_Macronix_32bitAddrQuadCmd_40MHz; } else { Config->Command = &r_sfc_Macronix_32bitAddrCmd_40MHz; } } } else { if ((40*1000*1000) < Config->SerialFlashMemoryMaxClock) { if ((Config->DataTransferMode == YD_SFMA_SDR_QUAD_IO) || (Config->DataTransferMode == YD_SFMA_DDR_QUAD_IO)) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr at 40MHZ with external address space use performance enhance mode */ if(YD_SFMA_MODE_EX_SPACE == Mode) { Config->Command = &r_sfc_Macronix_32bitAddrCmdPerformanceEnhance_40MHz; Config->PerformanceEnMode = YD_SFMA_PER_EN_MODE_ENABLE; } else Config->Command = &r_sfc_Macronix_24bitAddrQuadCmd_80MHz; } else { Config->Command = &r_sfc_Macronix_24bitAddrCmd_80MHz; } } else { if ((Config->DataTransferMode == YD_SFMA_SDR_QUAD_IO) || (Config->DataTransferMode == YD_SFMA_DDR_QUAD_IO)) { Config->Command = &r_sfc_Macronix_24bitAddrQuadCmd_40MHz; } else { Config->Command = &r_sfc_Macronix_24bitAddrCmd_40MHz; } } } #endif  #if SPI_FLASH_TYPE_SPANSION if (YD_SFMA_ADDRESS_32BIT == Config->AddressMode) { if ((40*1000*1000) < Config->SerialFlashMemoryMaxClock) { if ((Config->DataTransferMode == YD_SFMA_SDR_QUAD_IO) || (Config->DataTransferMode == YD_SFMA_DDR_QUAD_IO)) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr at 80MHZ with external address space use performance enhance mode */ #if 1 if(YD_SFMA_MODE_EX_SPACE == Mode) { Config->Command = &r_sfc_Spansion_32bitAddrCmdPerformanceEnhance_80MHz; Config->PerformanceEnMode = YD_SFMA_PER_EN_MODE_ENABLE; } else #endif { Config->Command = &r_sfc_Spansion_32bitAddrQuadCmd_80MHz; } } else { Config->Command = &r_sfc_Spansion_32bitAddrCmd_80MHz; } } else { if ((Config->DataTransferMode == YD_SFMA_SDR_QUAD_IO) || (Config->DataTransferMode == YD_SFMA_DDR_QUAD_IO)) { #if 1 if(YD_SFMA_MODE_EX_SPACE == Mode) { Config->Command = &r_sfc_Spansion_32bitAddrCmdPerformanceEnhance_40MHz; Config->PerformanceEnMode = YD_SFMA_PER_EN_MODE_ENABLE; } else #endif { Config->Command = &r_sfc_Spansion_32bitAddrQuadCmd_40MHz; } } else { Config->Command = &r_sfc_Spansion_32bitAddrCmd_40MHz; } } } else { if ((40*1000*1000) < Config->SerialFlashMemoryMaxClock) { #if 1 if ((Config->DataTransferMode == YD_SFMA_SDR_QUAD_IO) || (Config->DataTransferMode == YD_SFMA_DDR_QUAD_IO)) { Config->Command = &r_sfc_Spansion_24bitAddrQuadCmd_80MHz; }  else #endif { Config->Command = &r_sfc_Spansion_24bitAddrCmd_80MHz; } } else { if ((Config->DataTransferMode == YD_SFMA_SDR_QUAD_IO) || (Config->DataTransferMode == YD_SFMA_DDR_QUAD_IO)) { Config->Command = &r_sfc_Spansion_24bitAddrQuadCmd_40MHz; } else { Config->Command = &r_sfc_Spansion_24bitAddrCmd_40MHz; } } } #endif } }   /******************************************************************************* Function: loc_StartSFMA  Opens SFMA for writing and writes a pattern to it. Afterwards SFMA is closed but opened for reading again, so that the application can use it. */ void loc_StartSFMA(void) { yd_sfma_Error_t err = YD_SFMA_ERR_OK; yd_sfma_Config_t cfg;  uint32_t sf_adr = 0x00034000; uint32_t i;  err |= YD_SFMA_Init(LOC_SFMA_UNIT);  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr open for writing */ loc_SFMAConfig(&cfg, YD_SFMA_MODE_EX_SPACE, YD_SFMA_DDR_DUAL_IO); err |= YD_SFMA_Open(LOC_SFMA_UNIT, &cfg); err |= YD_SFMA_AccessAddressSet(LOC_SFMA_UNIT, 0, R_SFMA_ACCESS_RANGE_128MB);  #ifdef DEBUG_SFMA_RW /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr fill color: reddish */ for(i = 0; i < 4096; i++) { loc_srcData[i] =i+0x10; loc_eraseData[i] = 0xa5a5a5a5; loc_verifyData[i] = 0x5a5a5a5a; }  err |= YD_SFMA_ProtectionModeSet(LOC_SFMA_UNIT, YD_SFMA_MODE_UNPROTECT); err |= YD_SFMA_DataErase(LOC_SFMA_UNIT, sf_adr, sizeof(loc_srcData)); err |= YD_SFMA_DataRead(LOC_SFMA_UNIT, sf_adr, (uint8_t*)loc_eraseData, sizeof(loc_eraseData));  err |= YD_SFMA_DataWrite(LOC_SFMA_UNIT, sf_adr, (uint8_t*)loc_srcData, sizeof(loc_srcData)); err |= YD_SFMA_DataRead(LOC_SFMA_UNIT, sf_adr, (uint8_t*)loc_verifyData, sizeof(loc_verifyData)); //err |= YD_SFMA_Close(LOC_SFMA_UNIT); #endif  #ifdef DEBUG_SFMA_R /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr fill color: reddish */ for(i = 0; i < 4096; i++) { loc_verifyData[i] = 0x5a5a5a5a; }  err |= YD_SFMA_DataRead(LOC_SFMA_UNIT, sf_adr, (uint8_t*)loc_verifyData, sizeof(loc_verifyData)); //err |= YD_SFMA_Close(LOC_SFMA_UNIT); #endif if(err != YD_SFMA_ERR_OK) { if(err) { R_BSP_STDIO_Printf("Note: There.....\n"); //loc_Error((int32_t)err); } } }  /******************************************************************************* Function: loc_StopSFMA  Closes and stops SFMA */ void loc_StopSFMA(void) { yd_sfma_Error_t err = YD_SFMA_ERR_OK;  err |= YD_SFMA_Close(LOC_SFMA_UNIT); err |= YD_SFMA_DeInit(LOC_SFMA_UNIT);  if(err != YD_SFMA_ERR_OK) { loc_Error((int32_t)err); } }  //uint8_t* SFMA_GetF1A1_Value(void) //{ // memcpy(F1A1,(BYTE *)0x10000010, 5); // return F1A1; //}
