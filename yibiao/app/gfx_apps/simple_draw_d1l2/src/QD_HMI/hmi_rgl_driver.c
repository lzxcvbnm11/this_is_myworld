 #include "hmi_all_struct_include.h" #include "hmi_res_font.rom" #include <math.h> /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr sin and cos */   #define USE_V2_HMI_SDK 1 void hmi_driver_send_cmdlist(void); void free_all_buffer_res_manager(void); void free_all_jpg_buffer_res_manager(void); BOOLEAN free_jpg_buffer_res_manager(void); void loc_IncMsgCount(uint32_t Unit);   /*********************************************************** Function: locVBlank  VBlank callback function, called when a VBlank interrupt occurs. */ //void locVBlank_hmi(void); //void loc_VI_VBlank_hmi(void); /*********************************************************** Define: LOC_VRAM_IMAGE_COUNT  Number of images moved to VRAM. */  #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) uint32_t loc_CallbackReached = 0; uint32_t loc_InterruptFactor = 0;  #endif /* layer type info.  only one video layer at one page sprite only at layer 1,layer 2,layer 4. only sprite at one page  */ BYTE CONST hmi_layer_info[HMI_LAYER_MAX_CNT] = { HMI_LAYER_RLE/*HMI_LAYER_BUFFER*//*HMI_LAYER_VIDEOIN*/,  HMI_LAYER_SPRITE, HMI_LAYER_BUFFER/*HMI_LAYER_SPRITE*/, HMI_LAYER_BUFFER  };    static BYTE hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml layer_video_element[HMI_LAYER_MAX_CNT] = {NULL,NULL ,NULL ,NULL}; #if 0 static HMI_OBJECT_ID_STR layer_video_element_id[HMI_LAYER_MAX_CNT] = { HMI_NB_ELEMENTS, HMI_NB_ELEMENTS, HMI_NB_ELEMENTS, HMI_NB_ELEMENTS  }; #endif  /*font buffer*/ #define HMI_LOAD_FONT_DATA HMI_NO #if (HMI_LOAD_FONT_DATA==HMI_YES) /*font buffer*/ #if HMI_ALL_FONT_NUMBER > 0 static MUL_FONT_BUF_ADDR_STR hmi_all_font_not_hit[HMI_ALL_FONT_NOT_HIT_LEN]; #endif  #if HMI_ALL_FONT_NUMBER == 0 static FONT_BUF_ADDR_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_all_font_buffer=NULL; #elif HMI_ALL_FONT_NUMBER == 1 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer  };   #elif HMI_ALL_FONT_NUMBER == 2 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer };  #elif HMI_ALL_FONT_NUMBER == 3 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer };  #elif HMI_ALL_FONT_NUMBER == 4 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer };  #elif HMI_ALL_FONT_NUMBER == 5 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer };  #elif HMI_ALL_FONT_NUMBER == 6 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer };  #elif HMI_ALL_FONT_NUMBER == 7 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN];   static FONT_BUF_ADDR_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer };  #elif HMI_ALL_FONT_NUMBER == 8 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN];   static FONT_BUF_ADDR_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer };  #elif HMI_ALL_FONT_NUMBER == 9 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer };  #elif HMI_ALL_FONT_NUMBER == 10 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer };  #elif HMI_ALL_FONT_NUMBER == 11 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer };  #elif HMI_ALL_FONT_NUMBER == 12 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer };  #elif HMI_ALL_FONT_NUMBER == 13 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer };  #elif HMI_ALL_FONT_NUMBER == 14 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer };  #elif HMI_ALL_FONT_NUMBER == 15 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer };  #elif HMI_ALL_FONT_NUMBER == 16 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer };  #elif HMI_ALL_FONT_NUMBER == 17 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer };  #elif HMI_ALL_FONT_NUMBER == 18 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer };  #elif HMI_ALL_FONT_NUMBER == 19 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN];  static CONST FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer };  #elif HMI_ALL_FONT_NUMBER == 20 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer };  #elif HMI_ALL_FONT_NUMBER == 21 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer };  #elif HMI_ALL_FONT_NUMBER == 22 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer };  #elif HMI_ALL_FONT_NUMBER == 23 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer };  #elif HMI_ALL_FONT_NUMBER == 24 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer };  #elif HMI_ALL_FONT_NUMBER == 25 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer  };  #elif HMI_ALL_FONT_NUMBER == 26 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer };  #elif HMI_ALL_FONT_NUMBER == 27 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer };  #elif HMI_ALL_FONT_NUMBER == 28 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer };  #elif HMI_ALL_FONT_NUMBER == 29 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer };  #elif HMI_ALL_FONT_NUMBER == 30 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer };  #elif HMI_ALL_FONT_NUMBER == 31 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer };  #elif HMI_ALL_FONT_NUMBER == 32 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer };  #elif HMI_ALL_FONT_NUMBER == 33 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer };  #elif HMI_ALL_FONT_NUMBER == 34 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer };  #elif HMI_ALL_FONT_NUMBER == 35 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer  };  #elif HMI_ALL_FONT_NUMBER == 36 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer };  #elif HMI_ALL_FONT_NUMBER == 37 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer };  #elif HMI_ALL_FONT_NUMBER == 38 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer };  #elif HMI_ALL_FONT_NUMBER == 39 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer };  #elif HMI_ALL_FONT_NUMBER == 40 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer  };  #elif HMI_ALL_FONT_NUMBER == 41 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font41_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer, hmi_font41_buffer };  #elif HMI_ALL_FONT_NUMBER == 42 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font41_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font42_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer, hmi_font41_buffer,hmi_font42_buffer };  #elif HMI_ALL_FONT_NUMBER == 43 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font41_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font42_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font43_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer, hmi_font41_buffer,hmi_font42_buffer,hmi_font43_buffer };  #elif HMI_ALL_FONT_NUMBER == 44 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font41_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font42_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font43_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font44_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer, hmi_font41_buffer,hmi_font42_buffer,hmi_font43_buffer,hmi_font44_buffer };  #elif HMI_ALL_FONT_NUMBER == 45 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font41_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font42_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font43_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font44_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font45_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer, hmi_font41_buffer,hmi_font42_buffer,hmi_font43_buffer,hmi_font44_buffer,hmi_font45_buffer };   #elif HMI_ALL_FONT_NUMBER == 46 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font41_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font42_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font43_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font44_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font45_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font46_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer, hmi_font41_buffer,hmi_font42_buffer,hmi_font43_buffer,hmi_font44_buffer,hmi_font45_buffer, hmi_font46_buffer };  #elif HMI_ALL_FONT_NUMBER == 47 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font41_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font42_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font43_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font44_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font45_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font46_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font47_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer, hmi_font41_buffer,hmi_font42_buffer,hmi_font43_buffer,hmi_font44_buffer,hmi_font45_buffer, hmi_font46_buffer,hmi_font47_buffer };  #elif HMI_ALL_FONT_NUMBER == 48 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font41_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font42_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font43_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font44_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font45_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font46_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font47_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font48_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer, hmi_font41_buffer,hmi_font42_buffer,hmi_font43_buffer,hmi_font44_buffer,hmi_font45_buffer, hmi_font46_buffer,hmi_font47_buffer,hmi_font48_buffer };  #elif HMI_ALL_FONT_NUMBER == 49 static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font41_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font42_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font43_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font44_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font45_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font46_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font47_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font48_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font49_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer, hmi_font41_buffer,hmi_font42_buffer,hmi_font43_buffer,hmi_font44_buffer,hmi_font45_buffer, hmi_font46_buffer,hmi_font47_buffer,hmi_font48_buffer,hmi_font49_buffer };  #else static FONT_BUF_ADDR_STR hmi_font1_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font2_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font3_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font4_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font5_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font6_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font7_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font8_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font9_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font10_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font11_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font12_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font13_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font14_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font15_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font16_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font17_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font18_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font19_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font20_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font21_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font22_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font23_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font24_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font25_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font26_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font27_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font28_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font29_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font30_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font31_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font32_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font33_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font34_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font35_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font36_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font37_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font38_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font39_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font40_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font41_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font42_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font43_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font44_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font45_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font46_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font47_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font48_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font49_buffer[HMI_FONT_BUFFER_LEN]; static FONT_BUF_ADDR_STR hmi_font50_buffer[HMI_FONT_BUFFER_LEN];  static FONT_BUF_ADDR_STR CONST *hmi_all_font_buffer[HMI_ALL_FONT_NUMBER]= { hmi_font1_buffer,hmi_font2_buffer,hmi_font3_buffer,hmi_font4_buffer,hmi_font5_buffer, hmi_font6_buffer,hmi_font7_buffer,hmi_font8_buffer,hmi_font9_buffer,hmi_font10_buffer, hmi_font11_buffer,hmi_font12_buffer,hmi_font13_buffer,hmi_font14_buffer,hmi_font15_buffer, hmi_font16_buffer,hmi_font17_buffer,hmi_font18_buffer,hmi_font19_buffer,hmi_font20_buffer, hmi_font21_buffer,hmi_font22_buffer,hmi_font23_buffer,hmi_font24_buffer,hmi_font25_buffer, hmi_font26_buffer,hmi_font27_buffer,hmi_font28_buffer,hmi_font29_buffer,hmi_font30_buffer, hmi_font31_buffer,hmi_font32_buffer,hmi_font33_buffer,hmi_font34_buffer,hmi_font35_buffer, hmi_font36_buffer,hmi_font37_buffer,hmi_font38_buffer,hmi_font39_buffer,hmi_font40_buffer, hmi_font41_buffer,hmi_font42_buffer,hmi_font43_buffer,hmi_font44_buffer,hmi_font45_buffer, hmi_font46_buffer,hmi_font47_buffer,hmi_font48_buffer,hmi_font49_buffer,hmi_font50_buffer };  #endif #endif typedef enum  { HMI_QD_RGB565, HMI_QD_RGB888, HMI_QD_ARGB8888, HMI_QD_RGBA8888, HMI_QD_ARGB4444, HMI_QD_RGB444, HMI_QD_RGBA4444, HMI_QD_ARGB1555, HMI_QD_RGBA5551, HMI_QD_ALPHA8, HMI_QD_RLE24ARGB8888, HMI_QD_RLE18ARGB8888, HMI_QD_RLE24RGB0888, HMI_QD_RLE18RGB0888, HMI_QD_RLE8CLUT8, HMI_QD_RLE8CLUT4, HMI_QD_RLE8CLUT1, } hmi_qd_fbformat_t;  /*********************************************************** Section: Local Defines */ /**********************************************************************/ #ifdef HMI_GRAPHIC_RGL #define HMI_INIT_HEAP_CUSTOM YES #define HMI_INIT_RGL_CUSTOM YES #define HMI_INIT_SCREEN_CUSTOM YES #define HMI_INIT_WM_QUEEN_CUSTOM YES #define HMI_INIT_VOVIAL_CUSTOM NO   #define HMI_CPU_HP_BLOCK_NB 0x400  #define HMI_CPU_HP_BLOCK_SIZE 0x40   #define HMI_VID_HP_BLOCK_SIZE (1280u) #define HMI_VID_HP_BLOCK_NB (hmi_loc_VRAM0_SIZE / HMI_VID_HP_BLOCK_SIZE) #define HMI_ALIGN(ADDR,BLOCK) ( (ADDR+(BLOCK-1)) & ~(BLOCK-1) ) #define HMI_DHD_MEMORY_SIZE 0x2000000 #define HMI_VRAM_HEAP_BASE HMI_ALIGN((hmi_loc_VRAM0+HMI_DHD_MEMORY_SIZE), HMI_VID_HP_BLOCK_SIZE) /***VOVIAL***/ #define HMI_LOC_VOVIAL_UNIT 0 #define HMI_LOC_CAPTURE_UNIT 1 #define HMI_LOC_DISPLAY_UNIT 0 #define HMI_LOC_VOVIAL_FORMAT HMI_QD_ARGB1555//HMI_QD_ARGB1555 #define HMI_LOC_SPRITE_VOVIAL_FORMAT HMI_QD_ARGB8888 #define HMI_LOC_DISPLAY_NAME "800x480_60Hz" #define HMI_GPU_FINISH_FLAG R_DRW2D_FINISH_NOWAIT//R_DRW2D_FINISH_NOWAIT static r_drw2d_PixelFormat_t hmi_loc_drw2d_framebuffer_format = R_DRW2D_PIXELFORMAT_NONE; static UINT8 hmi_bpp =0; /**/ static void *locSurface[4]; #if (HMI_INIT_HEAP_CUSTOM == YES) static r_cdi_Heap_t *phmi_loc_lRAM_heap = NULL;  static r_cdi_Heap_t *phmi_loc_VRAM_heap = NULL; #define HMI_LOC_LRAM_HEAP (phmi_loc_lRAM_heap)  #define HMI_LOC_VRAM_HEAP (phmi_loc_VRAM_heap) r_cdi_Heap_t hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_get_CPU_heap(void); r_cdi_Heap_t hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_get_video_heap(void); #else static r_cdi_Heap_t hmi_loc_lRAM_heap; static r_cdi_Heap_t hmi_loc_VRAM_heap; #define HMI_LOC_LRAM_HEAP (&hmi_loc_lRAM_heap) #define HMI_LOC_VRAM_HEAP (&hmi_loc_VRAM_heap) static uint32_t hmi_loc_DHD_BASE = 0; static uint32_t hmi_loc_VRAM0 = 0; static uint32_t hmi_loc_VRAM0_SIZE = 0; static uint32_t hmi_loc_VRAM0_WRAP_ARGB6666 = 0;  static uint32_t hmi_loc_SFMA_BASE = 0; static uint32_t hmi_loc_SFMA_SIZE = 0; #endif   #if (HMI_INIT_RGL_CUSTOM == YES) static r_drw2d_Device_t *phmi_locDrw2dDev= NULL; static struct r_drw2d_DeviceDHD_s *phmi_locImplDev= NULL; #define HMI_LOC_DRW2D_DEV (*phmi_locDrw2dDev) #define HMI_LOC_IMPL_DEV (*phmi_locImplDev) #define HMI_P_LOC_DRW2D_DEV (phmi_locDrw2dDev) #define HMI_P_LOC_IMPL_DEV (phmi_locImplDev) r_drw2d_Device_t* hmi_get_rgl_drw2dDevice(void); void hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_get_rgl_deviceInternal(void); #else static r_drw2d_Device_t hmi_loc_drw2dDev; static struct r_drw2d_DeviceDHD_s hmi_loc_implDev; #define HMI_LOC_DRW2D_DEV hmi_loc_drw2dDev #define HMI_LOC_IMPL_DEV hmi_loc_implDev #endif /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr these depend on the device and are initialised at runtime */   #ifdef HMI_USE_LRAM_FB r_cdi_Heap_t loc_VOVIALRAM_heap; static uint8_t locFrameBufferLRAM[(LOC_DISPLAY_STRIDE hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_DISPLAY_HEIGHT hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_DISPLAY_BPP hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml 2 + 0x1000)] __attribute__((aligned(128))); #endif #if (HMI_INIT_HEAP_CUSTOM==NO) static r_cdi_HpBlkIndex_t loc_lRAM_heapIdxList[HMI_CPU_HP_BLOCK_NB hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml HMI_CPU_HP_BLOCK_SIZE]; #endif #endif  #define HMI_QD_CRFLAG_NONE 0 #define HMI_QD_CRFLAG_NO_ALLOC 1 #define HMI_QD_CRFLAG_3D_SURFACE 2 #define HMI_QD_CRFLAG_OGLES_SURFACE 4 #define HMI_QD_CRFLAG_OVG_SURFACE 8 #define HMI_QD_CRFLAG_AA_ENABLE 16 #define HMI_QD_CRFLAG_SPRITE 32 #define HMI_QD_CRFLAG_RLE 64  /******************************************************************************* Enum: hmi_qd_performance_t  Type of performance value.  Values: HMI_QD_PERF_CPU - CPU time for drawing in ms HMI_QD_PERF_GPU - GPU time for drawing in ms */  typedef enum  { HMI_QD_PERF_CPU, HMI_QD_PERF_GPU } hmi_qd_performance_t;   /******************************************************************************* Enum: hmi_qd_SpriteStatus_t  Type of sprite status.  Values:  */ typedef enum { HMI_QD_SPRITESTATUS_NOT_INITIALIZED = 0, HMI_QD_SPRITESTATUS_DISABLED, HMI_QD_SPRITESTATUS_ENABLED } hmi_qd_SpriteStatus_t;   /******************************************************************************* Struct: hmi_qd_Sprite_t  Description:  Each sprite has a data structure of this type.  Members:  Surface - pointer to the parent surface Intern - for internal usage, do NOT modify Next - zs12_project_page_0816_bginternal.xml zs12_project_page_lyy 0808-test-rle-internal.xml pointer to the next sprite in the queue Status - status of the sprite (should be set to HMI_QD_SPRITESTATUS_NOT_INITIALIZED before the call to hmi_qd_createsprite) Data - pointer to the image data of a sprite PosX / PosY / PosZ - position of the sprite on the window Width / Height - size of the sprite */ typedef struct hmi_qd_sprite_s { void *Surface; void *Intern; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Do NOT modify */ hmi_qd_SpriteStatus_t Status; void *Data; uint32_t PosX; uint32_t PosY; uint32_t PosZ; uint32_t Width; uint32_t Height; } hmi_qd_Sprite_t;  typedef struct { hmi_qd_Sprite_t hmi_sprite; hmi_qd_SpriteStatus_t next_status; HMI_OBJECT_ID_STR sprite_id; }HMI_SPRITE_STR;  /*********************************************************** Variable: locAllocedVRAM  Pointer array to store allocated VRAM blocks. */ //static void *locAllocedVRAM[LOC_VRAM_IMAGE_COUNT]; #if USE_V2_HMI_SDK  #define HMI_ENABLE_SPRITE_NB 16 #define HMI_MAX_SPRITE_LAYER 3 #define HMI_MAX_SPRITE_NB 32 #else #define HMI_ENABLE_SPRITE_NB 16 #define HMI_MAX_SPRITE_LAYER 3 #define HMI_MAX_SPRITE_NB 16 #endif HMI_SPRITE_STR hmi_sprite_list[HMI_MAX_SPRITE_LAYER][HMI_MAX_SPRITE_NB]={0};  /*Texture manager*/ #if HMI_DXY_BITMAPS_NUMBER > 0 rgl_buffer_img_str res_tex_dxy_bmp[HMI_DXY_BITMAPS_NUMBER]; #endif   #if HMI_SXY_BITMAPS_NUMBER > 0 rgl_buffer_img_str res_tex_sxy_bmp[1/*HMI_SXY_BITMAPS_NUMBER*/]; #endif  #if HMI_DXY_IMAGELIST_NUMBER > 0 rgl_buffer_img_str res_tex_dxy_imagelist[HMI_DXY_IMAGELIST_NUMBER]; #endif #if HMI_SXY_IMAGELIST_NUMBER > 0 rgl_buffer_img_str res_tex_sxy_imagelist[HMI_SXY_IMAGELIST_NUMBER]; #endif #if HMI_DXY_SCROLLBAR_NUMBER > 0 rgl_buffer_img_str res_tex_dxy_scrollbar[HMI_DXY_SCROLLBAR_NUMBER];  #endif #if HMI_SXY_SCROLLBAR_NUMBER > 0 rgl_buffer_img_str res_tex_sxy_scrollbar[HMI_SXY_SCROLLBAR_NUMBER]; #endif #if HMI_DXY_BUTTON_NUMBER > 0  rgl_buffer_img_str res_tex_dxy_button[HMI_DXY_BUTTON_NUMBER]; #endif #if HMI_SXY_BUTTON_NUMBER > 0  rgl_buffer_img_str res_tex_sxy_button[HMI_SXY_BUTTON_NUMBER];  #endif  #if HMI_JPG_BITMAPS_NUMBER > 0 rgl_jpg_decode_buffer_str jpg_buffer_tex_manager[HMI_JPG_BITMAPS_NUMBER]; #endif  /******************************************************************************* Section: Global Functions */ void hmi_qd_init(int32_t Vout, const char *DisplayId, void *CpuHead, void *VidHeap); void hmi_qd_deinit(int32_t Vout); void *hmi_qd_createsurface(int32_t Vout, hmi_qd_fbformat_t Format,  int32_t PosX, int32_t PosY, int32_t PosZ, int32_t Pitch, int32_t Width, int32_t Height, int32_t Alpha, int32_t Bufnum, uint32_t Flags);  int32_t hmi_qd_selectsurface(void *Id); void hmi_qd_enablesurface(void *Id); void hmi_qd_disablesurface(void *Id); void hmi_qd_deletesurface(void *Id); void *hmi_qd_getnativewindow(void *Id); void *hmi_qd_getnativedisplay(void *Id); void hmi_qd_movesurface(void *Id, int32_t PosX, int32_t PosY, int32_t PosZ); void hmi_qd_resizesurface(void *Id, uint32_t Pitch, uint32_t Width, uint32_t Height ); void *hmi_qd_getframebuffer(void *Id); int32_t hmi_qd_getframebufferidx(void *Id); //void *FW_VOVIAL_GetPrevFrameBuffer(void *Id); void *hmi_qd_getcurframebuffer(void *Id); int32_t hmi_qd_setbufferaddr(void *Id, int32_t BufNum, void **Addresses); void* hmi_qd_getvisiblebuffer(void *Id); void hmi_qd_swapframebuffer(void *Id, uint32_t FrameCount); void hmi_qd_registervblankisr(void *Id, void (*Isr)(void)); void hmi_qd_register_vi_vblankisr(void *Id, void (*Isr)(void)); void hmi_qd_setsurface_alpha(void *Id, uint32_t Alpha); void hmi_qd_getbufferinfo(void *Id, hmi_qd_fbformat_t *Format,  int32_t *Pitch, int32_t *Width, int32_t *Height); int32_t hmi_qd_createsprite(hmi_qd_Sprite_t *Sprite);  void hmi_qd_enablesprite(hmi_qd_Sprite_t *Sprite);  void hmi_qd_disablesprite(hmi_qd_Sprite_t *Sprite);  void hmi_qd_movesprite( hmi_qd_Sprite_t *Sprite, uint32_t PosX, uint32_t PosY, uint32_t PosZ );  void hmi_qd_setspritebuffer(hmi_qd_Sprite_t *Sprite, void *Buffer);  void hmi_qd_deletesprite(hmi_qd_Sprite_t *Sprite);    void *hmi_qd_createcapturesurface(int32_t Vin, hmi_qd_fbformat_t Format, int32_t Bufnum, int32_t SrcPitch, int32_t SrcWidth, int32_t SrcHeight, int32_t SrcMode, int32_t CropWidth, int32_t CropHeight, int32_t CropXOff, int32_t CropYOff);  void hmi_qd_InitWm(int32_t Unit, const char *DisplayName, void *CpuHeap, void *VidHeap);  /*************************************************************** Section: Local Defines */  /*************************************************************** Define: LOC_DECODE_VOUT  Decodes a slot from a surface. */  #define LOC_DECODE_VOUT(S) (((S) & 0x0000ffffu) - 1)  /*************************************************************** Define: LOC_CHECK_WM_ERR  Decodes a slot from a surface. */  #define LOC_CHECK_WM_ERR(E) if (R_WM_ERR_OK != E) loc_ErrorEndlessLoop()  /*************************************************************** Define: LOC_DECODE_WIN  Decodes a window slot from a surface. */  #define LOC_DECODE_WIN(S) ((((S) & 0xffff0000u) >> 16) - 1)  /*************************************************************** Define: LOC_ENCODE_SURF  Encode a window slot from a surface. */  #define LOC_ENCODE_SURF(V, W) ( (((W) + 1) << 16) + (V) + 1)   /*************************************************************** Define: LOC_WM_MSG_QUEUE_LEN */  #define LOC_WM_MSG_QUEUE_LEN 512  /*************************************************************** Define: LOC_INVALID_SURF_ID  Corresponds to interface expectation of the NULL pointer */  #define LOC_INVALID_SURF_ID 0x00000000u  /*************************************************************** Define: LOC_MAX_SURFACE_NUM  Maximum number of surfaces. */  #define LOC_MAX_SURFACE_NUM_PER_VOUT 4  /*************************************************************** Define: LOC_MAX_BUFFER_NUM_SURFACE  Maximum number of buffers per surface. */  #define LOC_MAX_BUFFER_NUM_SURFACE 3   /*************************************************************** Define: LOC_MAX_DISPLAY_NUM  Maximum number of displays. */  #define LOC_MAX_DISPLAY_NUM 2  /*************************************************************** Define: LOC_WM_EV_EXEC_THREAD_STACK_SIZE */  #define LOC_WM_EV_EXEC_THREAD_STACK_SIZE 1024  /*************************************************************** Define: CHECK_SURF_ID  Check if valid surface id. */  #define CHECK_SURF_ID(V, W) if ( ((V) > (LOC_MAX_DISPLAY_NUM - 1)) || ((W) > (LOC_MAX_SURFACE_NUM_PER_VOUT - 1)) ) loc_ErrorEndlessLoop()  /*************************************************************** Section: Local Types */  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Surface type is an integer with encoded VOUT and local array slot */ typedef uint32_t Surface_t;  typedef struct { r_wm_Window_t Win; r_wm_WinBuffer_t Buffers[LOC_MAX_BUFFER_NUM_SURFACE]; uint32_t Empty; } WindowSlot_t;  /*************************************************************** Section: Local Variables */  /*************************************************************** Variable: loc_Windows  The local storage for windows. */  static WindowSlot_t loc_Windows[LOC_MAX_DISPLAY_NUM hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT];  /*************************************************************** Variable: loc_VBLANKCallbacks  The local storage for window VBLANK callback functions. */  /*************************************************************** Variable: loc_WmEventQueue  WM event queue storage. */ #if (HMI_INIT_WM_QUEEN_CUSTOM == NO) static r_wm_Msg_t loc_WmEventQueue[2][LOC_WM_MSG_QUEUE_LEN]; #endif /*************************************************************** Variable: loc_WmEvExecThreadStack  WM event execute thread stack storage. */ //static uint8_t loc_WmEvExecThreadStack[LOC_WM_EV_EXEC_THREAD_STACK_SIZE];//removed by pxguo  /*************************************************************** Variable: loc_VoutMsgCount  Count of the messages sent to the vout. */ static volatile uint32_t loc_VoutMsgCount[R_WM_DEV_NUM];  /*************************************************************** Variable: loc_VblankIsr  VBLANK ISRs. */ static void(*loc_VblankIsr[R_WM_DEV_NUM])(void);  /*************************************************************** Variable: loc_VI_VblankIsr  VI_VBLANK ISRs. */ static void(*loc_VI_VblankIsr[R_WM_DEV_NUM])(void);  #ifdef USE_ROS static fw_osal_Mutex_t loc_WmMutex={0}; #endif  static r_cdi_Heap_t *loc_CpuHeap_VOVIAL = 0;  /*************************************************************** Section: Local Functions */  /******************************************************************************* Function: hmi_loc_DevCallback  A device callback function, for receiving notifications like EOF */  void hmi_loc_DevCallback(uint32_t Unit, const r_wm_Event_t* Event) { if (Event->Id == R_WM_EVENT_VBLANK) { if (loc_VblankIsr[Unit] != 0) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr execute the user defined ISR */ loc_VblankIsr[Unit](); } } }  /******************************************************************************* Function: loc_VI_DevCallback  A device callback function, for receiving notifications like EOF */  void loc_VI_DevCallback(uint32_t Unit, const r_wm_Event_t* Event) { if (Event->Id == R_WM_EVENT_VI_VBLANK) { if (loc_VI_VblankIsr[Unit] != 0) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr execute the user defined ISR */ loc_VI_VblankIsr[Unit](); } } }  void loc_IncMsgCount(uint32_t Unit) {  #ifdef USE_ROS FW_OSAL_MutexLock(&loc_WmMutex); #endif ++loc_VoutMsgCount[Unit]; #ifdef USE_ROS FW_OSAL_MutexUnlock(&loc_WmMutex); #endif }  /******************************************************************************* Function: loc_ErrorEndlessLoop  Endless loop in case of an error. */ static void loc_ErrorEndlessLoop(void) { #if(HMI_ENDLESS_LOOP==YES) for (;;) { } #endif }  /******************************************************************************* Function: loc_FmtConvVovialToWm  Converts the VOVIAL->WM color format conversion */  static uint32_t loc_FmtConvVovialToWm(hmi_qd_fbformat_t VovialFmt, r_wm_WinColorFmt_t *WmFmt) { switch (VovialFmt) { case HMI_QD_RGBA8888: *WmFmt = R_WM_COLORFMT_RGBA8888; break; case HMI_QD_ARGB8888: *WmFmt = R_WM_COLORFMT_ARGB8888; break; case HMI_QD_ARGB1555: *WmFmt = R_WM_COLORFMT_ARGB1555; break; case HMI_QD_RGB565: *WmFmt = R_WM_COLORFMT_RGB565; break; case HMI_QD_RLE24ARGB8888: *WmFmt = R_WM_COLORFMT_RLE24ARGB8888; break; case HMI_QD_RLE24RGB0888: *WmFmt = R_WM_COLORFMT_RLE24RGB0888; break; case HMI_QD_RLE18ARGB8888: *WmFmt = R_WM_COLORFMT_RLE18ARGB8888; break; case HMI_QD_RLE18RGB0888: *WmFmt = R_WM_COLORFMT_RLE18RGB0888; break; case HMI_QD_RLE8CLUT8: *WmFmt = R_WM_COLORFMT_RLE8CLUT8; break; case HMI_QD_RLE8CLUT4: *WmFmt = R_WM_COLORFMT_RLE8CLUT4; break; case HMI_QD_RLE8CLUT1: *WmFmt = R_WM_COLORFMT_RLE8CLUT1; break; default: return R_FALSE; } return R_TRUE; }  static uint32_t loc_FmtConvWmToVovial(r_wm_WinColorFmt_t WmFmt, hmi_qd_fbformat_t *VovialFmt) { switch (WmFmt) { case R_WM_COLORFMT_RGBA8888: *VovialFmt = HMI_QD_RGBA8888; break; case R_WM_COLORFMT_ARGB8888: *VovialFmt = HMI_QD_ARGB8888; break; case R_WM_COLORFMT_ARGB1555: *VovialFmt = HMI_QD_ARGB1555; break; case R_WM_COLORFMT_RGB565: *VovialFmt = HMI_QD_RGB565; break; case R_WM_COLORFMT_RLE24ARGB8888: *VovialFmt = HMI_QD_RLE24ARGB8888; break; case R_WM_COLORFMT_RLE24RGB0888: *VovialFmt = HMI_QD_RLE24RGB0888; break; case R_WM_COLORFMT_RLE18ARGB8888: *VovialFmt = HMI_QD_RLE18ARGB8888; break; case R_WM_COLORFMT_RLE18RGB0888: *VovialFmt = HMI_QD_RLE18RGB0888; break; case R_WM_COLORFMT_RLE8CLUT8: *VovialFmt = HMI_QD_RLE8CLUT8; break; case R_WM_COLORFMT_RLE8CLUT4: *VovialFmt = HMI_QD_RLE8CLUT4; break; case R_WM_COLORFMT_RLE8CLUT1: *VovialFmt = HMI_QD_RLE8CLUT1; break; default: return R_FALSE; } return R_TRUE; }  /******************************************************************************* Function: loc_EventExecuteThreadStart  The WM event execute thread. */  void* loc_WmEvExecLoop(void* Arg) { #if 0 uint32_t i = 0; for(;;) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr we are greedy: as soon as there are some messages, process them */ for (i = 0; i < R_WM_DEV_NUM; ++i) { if (loc_VoutMsgCount[i] > 0) {  #ifdef USE_ROS FW_OSAL_MutexLock(&loc_WmMutex); #endif loc_VoutMsgCount[i] = 0; #ifdef USE_ROS FW_OSAL_MutexUnlock(&loc_WmMutex); #endif R_WM_FrameEndMark(i, 0); R_WM_FrameWait(i, 0); /* be nice to other threads because otherwise, on some operating systems, they could not get scheduled */ } } #ifdef USE_ROS FW_OSAL_ThreadSleep(0); #endif } #endif return 0; }  /******************************************************************************* Section: Global Functions */  /******************************************************************************* Function: hmi_qd_init  For details see vovial.h */  void hmi_qd_init(int32_t Vout, const char *DisplayId, void *CpuHeap, void *VidHeap) { int32_t iv = 0; int32_t iw = 0; #if (HMI_INIT_WM_QUEEN_CUSTOM == NO) r_wm_Error_t wm_err = R_WM_ERR_OK; #endif /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr initialize the window structure slots */ for (iv = 0; iv < LOC_MAX_DISPLAY_NUM; ++iv) { for (iw = 0; iw < LOC_MAX_SURFACE_NUM_PER_VOUT; ++iw) { loc_Windows[iv hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + iw].Win.Status = R_WM_WINSTATUS_NOT_INITIALIZED; loc_Windows[iv hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + iw].Empty = R_TRUE; } }  loc_CpuHeap_VOVIAL = CpuHeap; #ifdef USE_ROS FW_OSAL_MutexCreate(&loc_WmMutex); #endif /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr init the screen */ #if (HMI_INIT_WM_QUEEN_CUSTOM == NO) wm_err = R_WM_DevInit(Vout, loc_WmEventQueue[Vout], LOC_WM_MSG_QUEUE_LEN, hmi_loc_DevCallback, CpuHeap, VidHeap); LOC_CHECK_WM_ERR(wm_err); #endif  #if (HMI_INIT_SCREEN_CUSTOM == NO) wm_err = R_WM_ScreenTimingSetByName(Vout, (const int8_t*)DisplayId); LOC_CHECK_WM_ERR(wm_err);  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr NOTE for D1L2 usage: Actually D1Lx devices implement RGB666 VDCE video output i/f only. For simplified wiring of the display on the D1Lx Mango Board, we set-up RGB888 i/f here anyway. Please adapt on custom boards. */ wm_err = R_WM_ScreenColorFormatSet(Vout, (R_WM_OUTCOLORFMT_RGB888)); LOC_CHECK_WM_ERR(wm_err);  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr enable the screen */ wm_err = R_WM_ScreenEnable(Vout); LOC_CHECK_WM_ERR(wm_err);  wm_err = R_WM_ScreenBgColorSet(Vout, 0x00, 0x00, 0); LOC_CHECK_WM_ERR(wm_err); #endif }  /******************************************************************************* Function: hmi_qd_deinit  For details see vovial.h */  void hmi_qd_deinit(int32_t Vout) { r_wm_Error_t wm_err = R_WM_ERR_OK;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr deinitialize the screen */ wm_err = R_WM_DevDeinit(Vout); LOC_CHECK_WM_ERR(wm_err); }   int32_t loc_GetSpriteLayerPitch(r_wm_WinColorFmt_t Format) { int32_t Pitch = 0;  switch(Format) { case R_WM_COLORFMT_RGB565: case R_WM_COLORFMT_ARGB1555: case R_WM_COLORFMT_ARGB4444: case R_WM_COLORFMT_RGB0444: case R_WM_COLORFMT_RGB0888: case R_WM_COLORFMT_ARGB8888: case R_WM_COLORFMT_RGBA5551: case R_WM_COLORFMT_RGBA4444: case R_WM_COLORFMT_RGBA8888: Pitch = 2048; break; case R_WM_COLORFMT_CLUT8: case R_WM_COLORFMT_CLUT4: case R_WM_COLORFMT_CLUT1: Pitch = 8192; break; default: Pitch = 0; break; }  return Pitch; }   /******************************************************************************* Function: hmi_qd_createsurface  For details see: <vovial.h> */  void *hmi_qd_createsurface(int32_t Vout, hmi_qd_fbformat_t Format,  int32_t PosX, int32_t PosY, int32_t PosZ, int32_t Pitch, int32_t Width, int32_t Height, int32_t Alpha, int32_t BufNum, uint32_t Flags) { int32_t i = 0; int32_t j = 0; r_wm_Window_t* win = NULL;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr find the next available window slot */ for (i = 0; i < LOC_MAX_SURFACE_NUM_PER_VOUT; ++i) { if (loc_Windows[Vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + i].Empty == R_TRUE) { break; } } if (i == LOC_MAX_SURFACE_NUM_PER_VOUT) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr no available slot found */ return (void*)LOC_INVALID_SURF_ID; }  loc_Windows[Vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + i].Empty = R_FALSE; win = &loc_Windows[Vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + i].Win;  if (!loc_FmtConvVovialToWm(Format, &win->ColorFmt)) { return (void*)LOC_INVALID_SURF_ID; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr color format not supported */ }  if (Flags & HMI_QD_CRFLAG_SPRITE) { win->Mode = R_WM_WINMODE_SPRITES; win->Pitch = loc_GetSpriteLayerPitch(win->ColorFmt);  if(0 == win->Pitch) { return (void*)LOC_INVALID_SURF_ID; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr color format not supported for sprite layer */ } } else { win->Mode = R_WM_WINMODE_FB; win->Pitch = Pitch; }  win->PosX = PosX; win->PosY = PosY; win->PosZ = PosZ; win->Width = Width; win->Height = Height;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Setup the buffer structure */ if ( (Flags & HMI_QD_CRFLAG_NO_ALLOC) || (Flags & HMI_QD_CRFLAG_RLE) || (Flags & HMI_QD_CRFLAG_SPRITE)) { win->Surface.Fb.Buffer = loc_Windows[Vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + i].Buffers; for(j = 0; j < LOC_MAX_BUFFER_NUM_SURFACE; ++j) { win->Surface.Fb.Buffer[j].Data = (void*) 0x0; win->Surface.Fb.Buffer[j].Status = R_WM_WINBUF_FREE; } win->Surface.Fb.BufMode = R_WM_WINBUF_ALLOC_EXTERNAL; } else { win->Surface.Fb.Buffer = (r_wm_WinBuffer_t*) R_NULL; win->Surface.Fb.BufMode = R_WM_WINBUF_ALLOC_INTERNAL; }  win->Surface.Fb.BufNum = BufNum; win->Alpha = Alpha; if (R_WM_WindowCreate(Vout, win) == R_WM_ERR_OK) { return (void*)LOC_ENCODE_SURF(Vout, i); } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr an error has occured */ return (void*)LOC_INVALID_SURF_ID; }   /******************************************************************************* Function: hmi_qd_createcapturesurface  For details see <vovial.h> */  void *hmi_qd_createcapturesurface(int32_t Vin, hmi_qd_fbformat_t Format, int32_t Bufnum, int32_t SrcPitch, int32_t SrcWidth, int32_t SrcHeight, int32_t SrcMode, int32_t CropWidth, int32_t CropHeight, int32_t CropXOff, int32_t CropYOff) { return (void*)0; }  /******************************************************************************* Function: hmi_qd_selectsurface  For details see <vovial.h> */ int32_t hmi_qd_selectsurface(void *Id) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr not applicable */ return 0; }  /******************************************************************************* Function: hmi_qd_enablesurface  For details see <vovial.h> */  void hmi_qd_enablesurface(void *Id) { uint32_t vout = 0; uint32_t win = 0; r_wm_Error_t wm_err = R_WM_ERR_OK;  vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  wm_err = R_WM_WindowEnable(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win); LOC_CHECK_WM_ERR(wm_err);  loc_IncMsgCount(vout); }   /******************************************************************************* Function: hmi_qd_disablesurface  For details see <vovial.h> */  void hmi_qd_disablesurface(void *Id) { uint32_t vout = 0; uint32_t win = 0; r_wm_Error_t wm_err = R_WM_ERR_OK;  vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  wm_err = R_WM_WindowDisable(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win); LOC_CHECK_WM_ERR(wm_err);  loc_IncMsgCount(vout); }  /******************************************************************************* Function: hmi_qd_deletesurface  For details see <vovial.h> */  void hmi_qd_deletesurface(void *Id) { uint32_t vout = 0; uint32_t win = 0; r_wm_Error_t wm_err = R_WM_ERR_OK;  vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  wm_err = R_WM_WindowDisable(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win); LOC_CHECK_WM_ERR(wm_err); wm_err = R_WM_WindowDelete(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win); LOC_CHECK_WM_ERR(wm_err);  loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win.Status = R_WM_WINSTATUS_NOT_INITIALIZED; loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Empty = R_TRUE;  R_WM_FrameEndMark(vout, 0); R_WM_FrameWait(vout, 0); }   /******************************************************************************* Function: hmi_qd_getnativewindow  For details see <vovial.h> */  void* hmi_qd_getnativewindow(void *Id) { uint32_t vout = 0; uint32_t win = 0;  vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  return (void*)&loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win; }   void* hmi_qd_getnativedisplay(void *Id) { return R_NULL; } /******************************************************************************* Function: hmi_qd_movesurface  For details see <vovial.h> */  void hmi_qd_movesurface(void *Id, int32_t PosX, int32_t PosY, int32_t PosZ) { uint32_t vout = 0; uint32_t win = 0; r_wm_Error_t wm_err = R_WM_ERR_OK;  vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  wm_err = R_WM_WindowMove(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win, PosX, PosY, PosZ); loc_IncMsgCount(vout); LOC_CHECK_WM_ERR(wm_err); }   /******************************************************************************* Function: FW_VOVIAL_GetFrameCount  For details see <vovial.h> */  uint32_t FW_VOVIAL_GetFrameCount( void *Id ) { return 0; }   /******************************************************************************* Function: hmi_qd_getbufferinfo  For details see vovial.h */  void hmi_qd_getbufferinfo(void *Id,  hmi_qd_fbformat_t *Format,  int32_t *Pitch, int32_t *Width,  int32_t *Height) { uint32_t i_vout = 0; uint32_t i_win = 0; r_wm_Window_t* win = NULL;  i_vout = LOC_DECODE_VOUT((uint32_t)Id); i_win = LOC_DECODE_WIN((uint32_t)Id);  CHECK_SURF_ID(i_vout, i_win);  win = &loc_Windows[i_vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + i_win].Win;  loc_FmtConvWmToVovial(win->ColorFmt, Format); *Pitch = win->Pitch; *Width = win->Width; *Height = win->Height; }   /******************************************************************************* Function: hmi_qd_getframebufferidx   */  int32_t hmi_qd_getframebufferidx(void *Id) { return 0; }    /******************************************************************************* Function: hmi_qd_getframebuffer   */  void* hmi_qd_getframebuffer(void* Id) { uint32_t vout = 0; uint32_t win = 0; void* fb = R_NULL;  vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  while (!fb) { fb = R_WM_WindowNewDrawBufGet(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win); } return fb; }   /******************************************************************************* Function: hmi_qd_swapframebuffer   */  void hmi_qd_swapframebuffer(void *Id, uint32_t FrameCount) { uint32_t vout = 0; uint32_t win = 0; r_wm_Error_t wm_err = R_WM_ERR_OK;  vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  wm_err = R_WM_WindowSwap(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win); LOC_CHECK_WM_ERR(wm_err); loc_IncMsgCount(vout); }   /******************************************************************************* Function: hmi_qd_registervblankisr   */  void hmi_qd_registervblankisr(void *Id, void (*Isr)(void))  { uint32_t vout = 0;  vout = LOC_DECODE_VOUT((uint32_t)Id);  loc_VblankIsr[vout] = Isr;  R_WM_DevEventRegister(vout, R_WM_EVENT_VBLANK, 0); }   /******************************************************************************* Function: hmi_qd_register_vi_vblankisr   */  void hmi_qd_register_vi_vblankisr(void *Id, void (*Isr)(void))  { uint32_t vout = 0;  vout = LOC_DECODE_VOUT((uint32_t)Id);  loc_VI_VblankIsr[vout] = Isr;  R_WM_DevEventRegister(vout, R_WM_EVENT_VI_VBLANK, 0); }    /******************************************************************************* Function: hmi_qd_setsurface_alpha  */  void hmi_qd_setsurface_alpha(void *Id, uint32_t Alpha) { uint32_t vout = 0; uint32_t win = 0; r_wm_Error_t wm_err = R_WM_ERR_OK;  vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  wm_err = R_WM_WindowAlphaSet(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win, Alpha); loc_IncMsgCount(vout); LOC_CHECK_WM_ERR(wm_err); }  /******************************************************************************* Function: hmi_qd_getcurframebuffer  */  void* hmi_qd_getcurframebuffer(void *Id) { uint32_t vout = 0; uint32_t win = 0; void* fb = R_NULL;  vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  while (!fb) { fb = R_WM_WindowCurrentDrawBufGet(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win); }  return fb; }  /******************************************************************************* Function: hmi_qd_getvisiblebuffer   */   void* hmi_qd_getvisiblebuffer(void *Id) { uint32_t vout = 0; uint32_t win = 0; void* fb = R_NULL; #if(HMI_ENDLESS_LOOP == NO) UINT16 get_buffer_nb = 0; #endif vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  #if(HMI_ENDLESS_LOOP==YES) while (!fb) { fb = R_WM_WindowVisibleBufGet(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win); } #else while ((!fb)&&(get_buffer_nb < HMI_GET_BUFFER_CNT)) { fb = R_WM_WindowVisibleBufGet(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win); get_buffer_nb++; } #endif return fb; }  /******************************************************************************* Function: hmi_qd_resizesurface */  void hmi_qd_resizesurface(void *Id, uint32_t Pitch, uint32_t Width, uint32_t Height ) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr todo */ /*lq added*/ uint32_t vout = 0; uint32_t win = 0; r_wm_Error_t wm_err = R_WM_ERR_OK;  vout = LOC_DECODE_VOUT((uint32_t)Id); win = LOC_DECODE_WIN((uint32_t)Id);  wm_err = R_WM_WindowResize(vout, &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win,  Pitch, Width, Height); loc_IncMsgCount(vout); LOC_CHECK_WM_ERR(wm_err); }  /*********************************************************** Function: loc_ConvSpriteStatusToWM  Converts a hmi_qd_SpriteStatus_t sprite status to a r_wm_SpriteStatus_t sprite status.  Parameters: SpriteStatus - The sprite status to convert.  Returns: The corresponding WM sprite status. */ r_wm_SpriteStatus_t loc_ConvSpriteStatusToWM(hmi_qd_SpriteStatus_t SpriteStatus) { r_wm_SpriteStatus_t ret = R_WM_SPRITESTATUS_NOT_INITIALIZED;  switch(SpriteStatus) { case HMI_QD_SPRITESTATUS_NOT_INITIALIZED: ret = R_WM_SPRITESTATUS_NOT_INITIALIZED; break; case HMI_QD_SPRITESTATUS_DISABLED: ret = R_WM_SPRITESTATUS_DISABLED; break; case HMI_QD_SPRITESTATUS_ENABLED: ret = R_WM_SPRITESTATUS_ENABLED; break; default: ret = R_WM_SPRITESTATUS_NOT_INITIALIZED; break; }  return ret; }  /*********************************************************** Function: hmi_qd_createsprite */ int32_t hmi_qd_createsprite(hmi_qd_Sprite_t *Sprite) { r_wm_Error_t error=R_WM_ERR_OK;//lq uint32_t vout = 0; uint32_t win = 0; r_wm_Sprite_t *wm_sprite = NULL;  vout = LOC_DECODE_VOUT((uint32_t) Sprite->Surface); win = LOC_DECODE_WIN ((uint32_t) Sprite->Surface);  wm_sprite = R_CDI_Alloc(loc_CpuHeap_VOVIAL, sizeof(*wm_sprite));  if(wm_sprite == 0) { return -1; } else { Sprite->Intern = (void*) wm_sprite; }  wm_sprite->Window = &loc_Windows[vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + win].Win; wm_sprite->Status = loc_ConvSpriteStatusToWM(Sprite->Status);  wm_sprite->Data = Sprite->Data; wm_sprite->PosX = Sprite->PosX; wm_sprite->PosY = Sprite->PosY; wm_sprite->PosZ = Sprite->PosZ; wm_sprite->Width = Sprite->Width; wm_sprite->Height = Sprite->Height;  error = R_WM_SpriteCreate(vout, wm_sprite); LOC_CHECK_WM_ERR(error);  Sprite->Status = HMI_QD_SPRITESTATUS_DISABLED;  return 0; }  /*********************************************************** Function: hmi_qd_enablesprite */ void hmi_qd_enablesprite(hmi_qd_Sprite_t *Sprite) { r_wm_Error_t error=R_WM_ERR_OK; uint32_t vout = 0; r_wm_Sprite_t *wm_sprite = (r_wm_Sprite_t*) Sprite->Intern;  vout = LOC_DECODE_VOUT((uint32_t) Sprite->Surface);  error = R_WM_SpriteEnable(vout, wm_sprite); /*******test***/ // if(error !=R_WM_ERR_OK) // { // error =R_WM_ERR_OK; // } /**************/ LOC_CHECK_WM_ERR(error);  Sprite->Status = HMI_QD_SPRITESTATUS_ENABLED; }   /*********************************************************** Function: hmi_qd_disablesprite */ void hmi_qd_disablesprite(hmi_qd_Sprite_t *Sprite) { uint32_t vout = 0; r_wm_Sprite_t *wm_sprite = (r_wm_Sprite_t*) Sprite->Intern;  vout = LOC_DECODE_VOUT((uint32_t) Sprite->Surface);  R_WM_SpriteDisable(vout, wm_sprite);  Sprite->Status = HMI_QD_SPRITESTATUS_DISABLED; }   /*********************************************************** Function: hmi_qd_movesprite */ void hmi_qd_movesprite ( hmi_qd_Sprite_t *Sprite, uint32_t PosX, uint32_t PosY, uint32_t PosZ ) { uint32_t vout = 0; r_wm_Sprite_t *wm_sprite = (r_wm_Sprite_t*) Sprite->Intern;  vout = LOC_DECODE_VOUT((uint32_t) Sprite->Surface);  R_WM_SpriteMove(vout, wm_sprite, PosX, PosY, PosZ);  Sprite->PosX = PosX; Sprite->PosY = PosY; Sprite->PosZ = PosZ; }   /*********************************************************** Function: hmi_qd_setbufferaddr */ int32_t hmi_qd_setbufferaddr(void *Id, int32_t BufNum, void **Addresses) { r_wm_Error_t ret = R_WM_ERR_OK;  int32_t i = 0; uint32_t i_vout = 0 ; uint32_t i_win = 0; r_wm_Window_t* win =NULL; r_wm_WinBuffer_t *bufs=NULL;  i_vout = LOC_DECODE_VOUT((uint32_t)Id); i_win = LOC_DECODE_WIN((uint32_t)Id);  win = &loc_Windows[i_vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + i_win].Win; bufs = loc_Windows[i_vout hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml LOC_MAX_SURFACE_NUM_PER_VOUT + i_win].Buffers;  if(R_WM_WINBUF_ALLOC_INTERNAL == win->Surface.Fb.BufMode) { return -1; }  for(i = 0; i < BufNum; ++i) {  bufs[i].Data = Addresses[i]; bufs[i].Status = R_WM_WINBUF_FREE; }  ret |= R_WM_WindowExternalBufSet(i_vout, win, bufs, BufNum, win->ColorFmt);  return ret; }   /*********************************************************** Function: hmi_qd_setspritebuffer */ void hmi_qd_setspritebuffer(hmi_qd_Sprite_t *Sprite, void *Buffer) { uint32_t vout = 0; r_wm_Sprite_t *wm_sprite = (r_wm_Sprite_t*) Sprite->Intern;  vout = LOC_DECODE_VOUT((uint32_t) Sprite->Surface);  R_WM_SpriteBufSet(vout, wm_sprite, Buffer);  Sprite->Data = Buffer; }   /*********************************************************** Function: hmi_qd_deletesprite */ void hmi_qd_deletesprite(hmi_qd_Sprite_t *Sprite) { uint32_t vout = 0; r_wm_Sprite_t *wm_sprite = (r_wm_Sprite_t*) Sprite->Intern;  vout = LOC_DECODE_VOUT((uint32_t) Sprite->Surface);  R_WM_SpriteDelete(vout, wm_sprite);  R_CDI_Free((uint32_t) wm_sprite, loc_CpuHeap_VOVIAL);  Sprite->Intern = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Make sure that subsequent dereferencing attracts attention. */ }  /******************************************************************************* Function: hmi_qd_InitWm */  void hmi_qd_InitWm(int32_t Unit, const char *DisplayName, void *CpuHeap, void *VidHeap) { #if (HMI_INIT_WM_QUEEN_CUSTOM == NO) r_wm_Error_t wm_err = R_WM_ERR_OK; wm_err = R_WM_DevInit(Unit, loc_WmEventQueue[Unit], LOC_WM_MSG_QUEUE_LEN, &loc_VI_DevCallback, CpuHeap, VidHeap); LOC_CHECK_WM_ERR(wm_err); #endif #if (HMI_INIT_SCREEN_CUSTOM == NO) wm_err = R_WM_ScreenTimingSetByName(Unit, (const int8_t*)DisplayName);  LOC_CHECK_WM_ERR(wm_err); wm_err = R_WM_ScreenEnable(Unit); LOC_CHECK_WM_ERR(wm_err); wm_err = R_WM_ScreenBgColorSet(Unit, 0, 0, 0); LOC_CHECK_WM_ERR(wm_err); wm_err = R_WM_FrameEndMark(Unit, 0); LOC_CHECK_WM_ERR(wm_err); wm_err = R_WM_FrameWait(Unit, 0); LOC_CHECK_WM_ERR(wm_err); #endif  }  /******************************************/  /*********************************************************** Variable: locSurface  The application's VOVIAL render surface */ //static U08 vertical_blank=0;   HMI_RECT_STR locSurface_rect[HMI_LAYER_MAX_CNT] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}}; /*effect.global variable*/ r_drw2d_FixedP_t c_alpha = 0; r_drw2d_EffectColorParamOperand_t op0 = R_DRW2D_EFFECT_COLOR_OPERAND_RGBA; r_drw2d_EffectStage_t effect_stages[2]; /**cube**/ r_drw2d_Vec4_t cubeCoords1_4[4]={ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Face 1*/ R_DRW2D_2X(0.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(1.0f), R_DRW2D_2X(1.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(1.0f), R_DRW2D_2X(1.0f),R_DRW2D_2X(1.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f),R_DRW2D_2X(1.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(1.0f), }; r_drw2d_Vec4_t cubeCoords5_6[4]={ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Face 1*/ R_DRW2D_2X(0.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(1.0f), R_DRW2D_2X(1.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(1.0f), R_DRW2D_2X(1.0f),R_DRW2D_2X(1.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f),R_DRW2D_2X(1.0f),R_DRW2D_2X(0.0f),R_DRW2D_2X(1.0f), };  r_drw2d_Rect_t cube_rect1_4 ={{ R_DRW2D_2X(-0.25f), R_DRW2D_2X(-0.25f),}, { R_DRW2D_2X(0.5f), R_DRW2D_2X(0.5f)}}; r_drw2d_Rect_t cube_rect5_6 ={{ R_DRW2D_2X(-0.25f), R_DRW2D_2X(-0.25f),}, { R_DRW2D_2X(0.5f), R_DRW2D_2X(0.5f)}};   CONST r_drw2d_IntRect_t viewport_rect = { {HMI_MAX_WIDTH, HMI_MAX_HEIGHT}, {0, 0} };  static CONST r_drw2d_UVCoord_t uvcoords1[] = { { R_DRW2D_2U(1.0f), R_DRW2D_2V(1.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr left/top */ { R_DRW2D_2U(0.0f), R_DRW2D_2V(1.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr right/top */ { R_DRW2D_2U(0.0f), R_DRW2D_2V(0.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr right/bottom */ { R_DRW2D_2U(1.0f), R_DRW2D_2V(0.0f) } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr left/bottom */ };  static CONST r_drw2d_UVCoord_t uvcoords2[] = { { R_DRW2D_2U(1.0f), R_DRW2D_2V(1.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr left/top */ { R_DRW2D_2U(0.0f), R_DRW2D_2V(1.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr right/top */ { R_DRW2D_2U(0.0f), R_DRW2D_2V(0.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr right/bottom */ { R_DRW2D_2U(1.0f), R_DRW2D_2V(0.0f) } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr left/bottom */ };  static CONST r_drw2d_UVCoord_t uvcoords3[] = { { R_DRW2D_2U(0.0f), R_DRW2D_2V(1.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr left/top */ { R_DRW2D_2U(0.0f), R_DRW2D_2V(0.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr right/top */ { R_DRW2D_2U(1.0f), R_DRW2D_2V(0.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr right/bottom */ { R_DRW2D_2U(1.0f), R_DRW2D_2V(1.0f) } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr left/bottom */ }; static r_drw2d_Buffer_t hmi_conv_buf = {0}; static r_drw2d_Framebuffer_t hmi_blur_buffer = {0}; static r_drw2d_Framebuffer_t hmi_jpg_blur_buffer = {0}; static r_drw2d_Framebuffer_t hmi_rle_blur_buffer = {0};    /***********************************************************  Variable: loc_CaptureDevice  The capture device object. */ static r_wm_Capture_t loc_CaptureDevice = {0}; static r_drw2d_Error_t rgl_err_list = R_DRW2D_ERR_OK; void loc_Error_hmi(r_drw2d_Error_t err) {  if(err) { rgl_err_list |= err; err = R_DRW2D_ERR_OK;  }  } #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) void hmi_loc_JpegCallbackFunction(uint32_t Unit, r_jcua_CallbackReason_t Factor, uint32_t Param) { loc_CallbackReached = 1; loc_InterruptFactor |= Factor; } #endif /* free all jpg decode buffer */ void free_all_jpg_buffer_res_manager(void) { #if HMI_JPG_BITMAPS_NUMBER>0 UINT32 i=0; R_JCUA_DecoderClose(LOC_JCUA_UNIT);//added by pxguo 160906 for(i=0;i < HMI_JPG_BITMAPS_NUMBER;i++) { if((jpg_buffer_tex_manager[i].pBuffer != NULL))  { R_CDI_Free((uint32_t)(jpg_buffer_tex_manager[i].pBuffer), HMI_LOC_VRAM_HEAP); } jpg_buffer_tex_manager[i].hmi_object_id = HMI_NB_ELEMENTS; jpg_buffer_tex_manager[i].pBuffer = NULL; jpg_buffer_tex_manager[i].ticks = 0; } #endif }  void free_image_res_manager(HMI_OBJECT_ID_STR hmi_object_id) { #if HMI_DXY_IMAGELIST_NUMBER>0 if(HMI_IS_DYN_IMAGELIST_DXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_IMAGELIST_DXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_DXY_IMAGELIST_NUMBER) { if(res_tex_dxy_imagelist[hmi_object_id].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_dxy_imagelist[hmi_object_id].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_dxy_imagelist[hmi_object_id].pBuffer = NULL; res_tex_dxy_imagelist[hmi_object_id].pData = NULL; res_tex_dxy_imagelist[hmi_object_id].ticks = 0; }  }  else #endif #if HMI_SXY_IMAGELIST_NUMBER>0 if(HMI_IS_DYN_IMAGELIST_SXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_IMAGELIST_SXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_SXY_IMAGELIST_NUMBER) { if(res_tex_sxy_imagelist[hmi_object_id].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_sxy_imagelist[hmi_object_id].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_sxy_imagelist[hmi_object_id].pBuffer = NULL; res_tex_sxy_imagelist[hmi_object_id].pData = NULL; res_tex_sxy_imagelist[hmi_object_id].ticks = 0; }  } else #endif #if HMI_DXY_SCROLLBAR_NUMBER>0 if(HMI_IS_DYN_SCROLLBAR_DXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_SCROLLBAR_DXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_DXY_SCROLLBAR_NUMBER) { if(res_tex_dxy_scrollbar[hmi_object_id].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_dxy_scrollbar[hmi_object_id].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_dxy_scrollbar[hmi_object_id].pBuffer = NULL; res_tex_dxy_scrollbar[hmi_object_id].pData = NULL; res_tex_dxy_scrollbar[hmi_object_id].ticks = 0; } } else  #endif #if HMI_SXY_SCROLLBAR_NUMBER>0 if(HMI_IS_DYN_SCROLLBAR_SXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_SCROLLBAR_SXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_SXY_SCROLLBAR_NUMBER) { if(res_tex_sxy_scrollbar[hmi_object_id].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_sxy_scrollbar[hmi_object_id].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_sxy_scrollbar[hmi_object_id].pBuffer = NULL; res_tex_sxy_scrollbar[hmi_object_id].pData = NULL; res_tex_sxy_scrollbar[hmi_object_id].ticks = 0; } } else #endif #if HMI_DXY_BUTTON_NUMBER > 0  if(HMI_IS_DYN_BUTTON_DXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_BUTTON_DXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_DXY_BUTTON_NUMBER) { if(res_tex_dxy_button[hmi_object_id].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_dxy_button[hmi_object_id].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_dxy_button[hmi_object_id].pBuffer = NULL; res_tex_dxy_button[hmi_object_id].pData = NULL; res_tex_dxy_button[hmi_object_id].ticks = 0; }  }  else #endif #if HMI_SXY_BUTTON_NUMBER>0  if(HMI_IS_DYN_BUTTON_SXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_BUTTON_SXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_SXY_BUTTON_NUMBER) { if(res_tex_sxy_button[hmi_object_id].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_sxy_button[hmi_object_id].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_sxy_button[hmi_object_id].pBuffer = NULL; res_tex_sxy_button[hmi_object_id].pData = NULL; res_tex_sxy_button[hmi_object_id].ticks = 0; }  }  else  #endif  #if HMI_DXY_BITMAPS_NUMBER> 0  if(HMI_IS_DYN_XY_BITMAP(hmi_object_id)) {  hmi_object_id = HMI_GET_DYN_XY_BITMAP_INDEX(hmi_object_id ); if(hmi_object_id < HMI_DXY_BITMAPS_NUMBER) { if(res_tex_dxy_bmp[hmi_object_id].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_dxy_bmp[hmi_object_id].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_dxy_bmp[hmi_object_id].pBuffer = NULL; res_tex_dxy_bmp[hmi_object_id].pData = NULL; res_tex_dxy_bmp[hmi_object_id].ticks = 0; } } else #endif #if HMI_SXY_BITMAPS_NUMBER> 0 if(HMI_IS_S_XY_BITMAP(hmi_object_id)) {  hmi_object_id = HMI_GET_SXY_BITMAPS_ID_INDEX(hmi_object_id);  if(hmi_object_id < 1/*HMI_SXY_BITMAPS_NUMBER*/) { if(res_tex_sxy_bmp[hmi_object_id].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_sxy_bmp[hmi_object_id].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_sxy_bmp[hmi_object_id].pBuffer = NULL; res_tex_sxy_bmp[hmi_object_id].pData = NULL; res_tex_sxy_bmp[hmi_object_id].ticks = 0; }  } else #endif  { }  } void free_all_buffer_res_manager(void) {  #if (HMI_SXY_BITMAPS_NUMBER + HMI_DXY_BITMAPS_NUMBER+\ HMI_DXY_IMAGELIST_NUMBER + HMI_SXY_IMAGELIST_NUMBER +\ HMI_DXY_SCROLLBAR_NUMBER + HMI_SXY_SCROLLBAR_NUMBER +\ HMI_DXY_BUTTON_NUMBER + HMI_SXY_BUTTON_NUMBER > 0) uint32_t i = 0; #endif  #if HMI_DXY_BITMAPS_NUMBER > 0 for(i=0;i < HMI_DXY_BITMAPS_NUMBER;i++) { if(res_tex_dxy_bmp[i].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_dxy_bmp[i].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_dxy_bmp[i].pBuffer = NULL; res_tex_dxy_bmp[i].pData = NULL; res_tex_dxy_bmp[i].ticks = 0; } #endif  #if HMI_SXY_BITMAPS_NUMBER > 0 for(i=0;i < 1/*HMI_SXY_BITMAPS_NUMBER*/;i++) { if(res_tex_sxy_bmp[i].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_sxy_bmp[i].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_sxy_bmp[i].pBuffer = NULL; res_tex_sxy_bmp[i].pData = NULL;  res_tex_sxy_bmp[i].ticks = 0; } #endif  #if HMI_DXY_IMAGELIST_NUMBER > 0 for(i=0;i < HMI_DXY_IMAGELIST_NUMBER;i++) { if(res_tex_dxy_imagelist[i].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_dxy_imagelist[i].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_dxy_imagelist[i].pBuffer= NULL; res_tex_dxy_imagelist[i].pData = NULL; res_tex_dxy_imagelist[i].ticks = 0; } #endif  #if HMI_SXY_IMAGELIST_NUMBER > 0 for(i=0;i < HMI_SXY_IMAGELIST_NUMBER;i++) { if(res_tex_sxy_imagelist[i].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_sxy_imagelist[i].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_sxy_imagelist[i].pBuffer= NULL; res_tex_sxy_imagelist[i].pData = NULL; res_tex_sxy_imagelist[i].ticks = 0; }  #endif  #if HMI_DXY_SCROLLBAR_NUMBER > 0  for(i=0;i < HMI_DXY_SCROLLBAR_NUMBER;i++) { if(res_tex_dxy_scrollbar[i].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_dxy_scrollbar[i].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_dxy_scrollbar[i].pBuffer= NULL; res_tex_dxy_scrollbar[i].pData = NULL; res_tex_dxy_scrollbar[i].ticks = 0; }  #endif  #if HMI_SXY_SCROLLBAR_NUMBER > 0 for(i=0;i < HMI_SXY_SCROLLBAR_NUMBER;i++) { if(res_tex_sxy_scrollbar[i].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_sxy_scrollbar[i].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_sxy_scrollbar[i].pBuffer= NULL; res_tex_sxy_scrollbar[i].pData = NULL; res_tex_sxy_scrollbar[i].ticks = 0; }  #endif  #if HMI_DXY_BUTTON_NUMBER > 0  for(i=0;i < HMI_DXY_BUTTON_NUMBER;i++) { if(res_tex_dxy_button[i].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_dxy_button[i].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_dxy_button[i].pBuffer = NULL; res_tex_dxy_button[i].pData = NULL; res_tex_dxy_button[i].ticks = 0; } #endif  #if HMI_SXY_BUTTON_NUMBER > 0  for(i=0;i < HMI_SXY_BUTTON_NUMBER;i++) { if(res_tex_sxy_button[i].pBuffer != NULL) { R_CDI_Free((uint32_t)(res_tex_sxy_button[i].pBuffer), HMI_LOC_VRAM_HEAP); } res_tex_sxy_button[i].pBuffer = NULL; res_tex_sxy_button[i].pData = NULL; res_tex_sxy_button[i].ticks = 0; }  #endif if((hmi_blur_buffer.Buffer.Data)!=NULL) { R_CDI_Free((uint32_t)(hmi_blur_buffer.Buffer.Data),HMI_LOC_VRAM_HEAP); hmi_blur_buffer.Buffer.Data = NULL; hmi_blur_buffer.Flags = __R_DRW2D_FRAMEBUFFERFLAGS_PLACEHOLDER__; hmi_blur_buffer.Handle = NULL; } if((hmi_conv_buf.Data)!=NULL) { R_CDI_Free((uint32_t)(hmi_conv_buf.Data),HMI_LOC_VRAM_HEAP); hmi_conv_buf.Data = NULL; } if((hmi_jpg_blur_buffer.Buffer.Data)!=NULL) { R_CDI_Free((uint32_t)(hmi_jpg_blur_buffer.Buffer.Data),HMI_LOC_VRAM_HEAP); hmi_jpg_blur_buffer.Buffer.Data = NULL; hmi_jpg_blur_buffer.Flags = __R_DRW2D_FRAMEBUFFERFLAGS_PLACEHOLDER__; hmi_jpg_blur_buffer.Handle = NULL; } if((hmi_rle_blur_buffer.Buffer.Data)!=NULL) { R_CDI_Free((uint32_t)(hmi_rle_blur_buffer.Buffer.Data),HMI_LOC_VRAM_HEAP); hmi_rle_blur_buffer.Buffer.Data = NULL; hmi_rle_blur_buffer.Flags = __R_DRW2D_FRAMEBUFFERFLAGS_PLACEHOLDER__; hmi_rle_blur_buffer.Handle = NULL; } }  /* every loop,add texture resource ticks . for memory manager.the longest time no used texture, which will free memory if insufficent memeory */ #if 0 void add_tick_res_manager(void) { uint32_t i=0; #if HMI_DXY_BITMAPS_NUMBER>0 for(i=0;i < HMI_DXY_BITMAPS_NUMBER;i++) { if(res_tex_dxy_bmp[i].pBuffer != NULL) { res_tex_dxy_bmp[i].ticks++;  if(res_tex_dxy_bmp[i].ticks == 0)/*overflow,0 mean the texture used at this loop*/ { res_tex_dxy_bmp[i].ticks = HMI_MAX_RGL_OVERFLOW; } } } #endif #if (HMI_LOAD_SOURCE_MODE == HMI_LOAD_RES_ALL_INIT)||(HMI_LOAD_SOURCE_MODE == HMI_LOAD_RES_ALL_AT_USED) #if HMI_SXY_BITMAPS_NUMBER>0 for(i=0;i < HMI_SXY_BITMAPS_NUMBER;i++) { if(res_tex_sxy_bmp[i].pBuffer != NULL) { res_tex_sxy_bmp[i].ticks++;  if(res_tex_sxy_bmp[i].ticks == 0)/*overflow,0 mean the texture used at this loop*/ { res_tex_sxy_bmp[i].ticks = HMI_MAX_RGL_OVERFLOW; } } } #endif #if HMI_DXY_IMAGELIST_NUMBER>0 for(i=0;i < HMI_DXY_IMAGELIST_NUMBER;i++) { if(res_tex_dxy_imagelist[i].pBuffer != NULL) { res_tex_dxy_imagelist[i].ticks++;  if(res_tex_dxy_imagelist[i].ticks == 0)/*overflow,0 mean the texture used at this loop*/ { res_tex_dxy_imagelist[i].ticks = HMI_MAX_RGL_OVERFLOW; } } } #endif #if HMI_SXY_IMAGELIST_NUMBER>0 for(i=0;i < HMI_SXY_IMAGELIST_NUMBER;i++) { if(res_tex_sxy_imagelist[i].pBuffer != NULL) { res_tex_sxy_imagelist[i].ticks++;  if(res_tex_sxy_imagelist[i].ticks == 0)/*overflow,0 mean the texture used at this loop*/ { res_tex_sxy_imagelist[i].ticks = HMI_MAX_RGL_OVERFLOW; } } } #endif #if HMI_DXY_SCROLLBAR_NUMBER>0  for(i=0;i < HMI_DXY_SCROLLBAR_NUMBER;i++) { if(res_tex_dxy_scrollbar[i].pBuffer != NULL) { res_tex_dxy_scrollbar[i].ticks++;  if(res_tex_dxy_scrollbar[i].ticks == 0)/*overflow,0 mean the texture used at this loop*/ { res_tex_dxy_scrollbar[i].ticks = HMI_MAX_RGL_OVERFLOW; } } } #endif #if HMI_SXY_SCROLLBAR_NUMBER>0 for(i=0;i < HMI_SXY_SCROLLBAR_NUMBER;i++) { if(res_tex_sxy_scrollbar[i].pBuffer != NULL) { res_tex_sxy_scrollbar[i].ticks++;  if(res_tex_sxy_scrollbar[i].ticks == 0)/*overflow,0 mean the texture used at this loop*/ { res_tex_sxy_scrollbar[i].ticks = HMI_MAX_RGL_OVERFLOW; } } } #endif #if HMI_DXY_BUTTON_NUMBER > 0  for(i=0;i < HMI_DXY_BUTTON_NUMBER;i++) { if(res_tex_dxy_button[i].pBuffer != NULL) { res_tex_dxy_button[i].ticks++;  if(res_tex_dxy_button[i].ticks == 0)/*overflow,0 mean the texture used at this loop*/ { res_tex_dxy_button[i].ticks = HMI_MAX_RGL_OVERFLOW; } } } #endif #if HMI_SXY_BUTTON_NUMBER>0  for(i=0;i < HMI_SXY_BUTTON_NUMBER;i++) { if(res_tex_sxy_button[i].pBuffer != NULL) { res_tex_sxy_button[i].ticks++;  if(res_tex_sxy_button[i].ticks == 0)/*overflow,0 mean the texture used at this loop*/ { res_tex_sxy_button[i].ticks = HMI_MAX_RGL_OVERFLOW; } } } #endif #endif  #if HMI_JPG_BITMAPS_NUMBER>0 for(i=0;i<HMI_JPG_BITMAPS_NUMBER;i++) { if(jpg_buffer_tex_manager[i].pBuffer != NULL)  { jpg_buffer_tex_manager[i].ticks++; if(jpg_buffer_tex_manager[i].ticks == 0)/*overflow,0 mean the texture used at this loop*/ { jpg_buffer_tex_manager[i].ticks = HMI_MAX_RGL_OVERFLOW; } } } #endif } #endif /*********************************************************** Function: hmi_error_handler  Error handler used for Drw2d errors */ static r_drw2d_Boolean_t hmi_error_handler(r_drw2d_Error_t Error) { loc_Error_hmi(Error); HMI_GFX_SET_STATUS(HMI_DYN_DRAW_ERROR); return R_TRUE; }  static void hmi_qd_error_handler(UINT32 error) {  HMI_GFX_SET_STATUS(error);  }   /* TFT Init HSFI Init Setup Mem Setup 2D SetupVout Initframebuffer */  /* R_CDI_Alloc R_CDI_AllocAlign Init2DImg */ /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: loc_RenderClear  Render function called each frame */ #if 0 static void loc_RenderClear() { r_drw2d_Error_t ret = R_DRW2D_ERR_OK;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set black(alpha=0) clear color and fill framebuffer */ ret |= R_DRW2D_CtxBgColor(HMI_LOC_DRW2D_DEV, 0x00000000/*ARGB*/); ret |= R_DRW2D_FramebufferClear(HMI_LOC_DRW2D_DEV);  if (R_DRW2D_ERR_OK != ret) { loc_Error_hmi(ret); } } #endif   /******************************************************************************* Function: loc_SetRenderTarget  Sets the target for the subsequent render commands to a current draw buffer of a window (its back-buffer) */ static void* locSetRenderTarget(void* Win) { r_drw2d_Framebuffer_t fb = {0}; hmi_qd_fbformat_t fmt = HMI_LOC_VOVIAL_FORMAT;  if(Win != NULL) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Init framebuffer struct */ fb.Flags = (r_drw2d_FramebufferFlags_t)0; fb.Handle = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr not used currently */ hmi_qd_getbufferinfo(Win, &fmt,  &fb.Buffer.Pitch,  &fb.Buffer.Size.Width, &fb.Buffer.Size.Height); fb.Buffer.PixelFormat = hmi_loc_drw2d_framebuffer_format; fb.Buffer.Data = hmi_qd_getframebuffer(Win); R_DRW2D_FramebufferSet(HMI_LOC_DRW2D_DEV, &fb); } return fb.Buffer.Data; }  /*added by pxguo */ /*Get current drawing frame buffer*/ static void* locGetRenderTarget(void* Win) { r_drw2d_Framebuffer_t fb = {0}; hmi_qd_fbformat_t fmt = HMI_LOC_VOVIAL_FORMAT; r_drw2d_Error_t err = R_DRW2D_ERR_OK;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Init framebuffer struct */ fb.Flags = (r_drw2d_FramebufferFlags_t)0; fb.Handle = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr not used currently */ hmi_qd_getbufferinfo(Win, &fmt, &fb.Buffer.Pitch,  &fb.Buffer.Size.Width,  &fb.Buffer.Size.Height);  fb.Buffer.PixelFormat = hmi_loc_drw2d_framebuffer_format; fb.Buffer.Data = hmi_qd_getcurframebuffer(Win); err=R_DRW2D_FramebufferSet(HMI_LOC_DRW2D_DEV, &fb); //fb.Buffer.Data=hmi_qd_getvisiblebuffer(Win); if(err) { HMI_GFX_SET_STATUS(HMI_RGL_GET_BUFFER_ERROR); } return fb.Buffer.Data; }   #if (HMI_INIT_HEAP_CUSTOM !=YES) static void hmi_locMemInit(void) { uint32_t x = 0; r_dev_Device_t dev = R_DEV_UNKNOWN_DEVICE;  dev = R_DEV_GetDev(); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr D1L2 */ if(dev == R_DEV_R7F701402 || dev == R_DEV_R7F701403) { hmi_loc_VRAM0 = D1L_VRAM0; hmi_loc_VRAM0_SIZE = D1L_VRAM0_SIZE; hmi_loc_VRAM0_WRAP_ARGB6666 = D1L_VRAM0_WRAP_ARGB6666; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr D1M1 */ else if(dev == R_DEV_R7F701404 || dev == R_DEV_R7F701405 || dev == R_DEV_R7F701406 || dev == R_DEV_R7F701407) { hmi_loc_VRAM0 = D1M1_VRAM0; hmi_loc_VRAM0_SIZE = D1M_VRAM0_SIZE; hmi_loc_VRAM0_WRAP_ARGB6666 = D1M1_VRAM0_WRAP_ARGB6666; hmi_loc_DHD_BASE = hmi_loc_VRAM0; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr D1M2 */ else if(dev == R_DEV_R7F701408 || dev == R_DEV_R7F701410 || dev == R_DEV_R7F701411 || dev == R_DEV_R7F701412) { hmi_loc_VRAM0 = D1M_SDRAM_BASE/*D1M2_VRAM0*/; hmi_loc_VRAM0_SIZE = D1M2H_SDRAM_SIZE/*D1M_VRAM0_SIZE + D1M2_VRAM1_SIZE*/; hmi_loc_VRAM0_WRAP_ARGB6666 = D1M2_VRAM0_WRAP_ARGB6666; hmi_loc_DHD_BASE = hmi_loc_VRAM0; hmi_loc_SFMA_BASE = D1M2H_SFMA_BASE; hmi_loc_SFMA_SIZE = D1M2H_SFMA_SIZE; } else { #if(HMI_ENDLESS_LOOP==YES) while(1); #endif }  x = R_CDI_InitHeapManager((uint32_t)&loc_lRAM_heapIdxList, HMI_LOC_LRAM_HEAP, 0, HMI_CPU_HP_BLOCK_NB, HMI_CPU_HP_BLOCK_SIZE); if (x == 1) { #if(HMI_ENDLESS_LOOP==YES) while(1); #endif }  x = R_CDI_InitHeapManager(HMI_VRAM_HEAP_BASE, HMI_LOC_VRAM_HEAP, 0, HMI_VID_HP_BLOCK_NB, HMI_VID_HP_BLOCK_SIZE); if (x == 1) { #if(HMI_ENDLESS_LOOP==YES) while(1); #endif }   #ifdef HMI_USE_LRAM_FB x = R_CDI_InitHeapManager((uint32_t) locFrameBufferLRAM, &loc_VOVIALRAM_heap, 0, sizeof(locFrameBufferLRAM) / 256, 256);  if (x == 1) { #if(HMI_ENDLESS_LOOP==YES) while(1); #endif } #endif } #endif  /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: init rgl called at reset */ void qd_rgl_driver_init(void) { int32_t i = 0; //r_drw2d_Error_t get_error=R_DRW2D_ERR_OK;  #if (HMI_INIT_RGL_CUSTOM != YES) int32_t err = R_DRW2D_ERR_OK; #endif if(HMI_LOC_VOVIAL_FORMAT==HMI_QD_RGB565) { hmi_loc_drw2d_framebuffer_format = R_DRW2D_PIXELFORMAT_RGB565; hmi_bpp = 2; } else if(HMI_LOC_VOVIAL_FORMAT==HMI_QD_ARGB1555) { hmi_loc_drw2d_framebuffer_format = R_DRW2D_PIXELFORMAT_ARGB1555; hmi_bpp = 2; } else { hmi_loc_drw2d_framebuffer_format = R_DRW2D_PIXELFORMAT_ARGB8888; hmi_bpp = 4; } #if (HMI_INIT_RGL_CUSTOM==YES) HMI_P_LOC_DRW2D_DEV = hmi_get_rgl_drw2dDevice(); //HMI_P_LOC_IMPL_DEV = hmi_get_rgl_deviceInternal(); if(HMI_P_LOC_DRW2D_DEV == NULL)//||(HMI_P_LOC_IMPL_DEV == NULL)) { hmi_qd_error_handler(HMI_RGL_DRW2D_INIT_ERROR); #if(HMI_ENDLESS_LOOP==YES) while(1); #endif } #else  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr start up gfx engine */ err |= R_DRW2D_Init(); err |= R_DRW2D_Open(0, R_DRW2D_UNIT_DHD0, &HMI_LOC_IMPL_DEV, &HMI_LOC_DRW2D_DEV); #endif  for(i=0;i < HMI_LAYER_MAX_CNT;i++) { locSurface[i] = NULL; }  #if (HMI_INIT_HEAP_CUSTOM==YES) HMI_LOC_LRAM_HEAP=hmi_get_CPU_heap(); HMI_LOC_VRAM_HEAP=hmi_get_video_heap(); if((HMI_LOC_LRAM_HEAP==NULL)||(HMI_LOC_VRAM_HEAP==NULL)) { hmi_qd_error_handler(HMI_RGL_MEM_INIT_ERROR); #if(HMI_ENDLESS_LOOP==YES) while(1); #endif } #else hmi_locMemInit(); #endif  #if(HMI_INIT_VOVIAL_CUSTOM==NO) #ifdef HMI_USE_LRAM_FB /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Use local RAM as framebuffer since VRAM is too small. */ hmi_qd_init(HMI_LOC_VOVIAL_UNIT, HMI_LOC_DISPLAY_NAME, HMI_LOC_LRAM_HEAP, &loc_VOVIALRAM_heap); #else hmi_qd_init(HMI_LOC_VOVIAL_UNIT, HMI_LOC_DISPLAY_NAME, HMI_LOC_LRAM_HEAP, HMI_LOC_VRAM_HEAP); hmi_qd_InitWm(HMI_LOC_DISPLAY_UNIT, HMI_LOC_DISPLAY_NAME, HMI_LOC_LRAM_HEAP, HMI_LOC_VRAM_HEAP); #endif #endif  }  void qd_layer_pos_init(void) { U08 loop = 0;  for(loop=0;loop < HMI_LAYER_MAX_CNT;loop++) { locSurface_rect[loop].x = 0; locSurface_rect[loop].y = 0; locSurface_rect[loop].w = 0; locSurface_rect[loop].h = 0; } }  void qd_variable_init(void) { rgl_err_list = R_DRW2D_ERR_OK;  /*capture parameter init*/ loc_CaptureDevice.Mode = (r_wm_CapMode_t)(R_WM_CAPMODE_NONE); loc_CaptureDevice.StartX = LOC_CAPTURE_INPUT_STARTX; loc_CaptureDevice.StrideX = 0; loc_CaptureDevice.StartY1 = 0; loc_CaptureDevice.StartY2 = 0; loc_CaptureDevice.Width = 0; loc_CaptureDevice.Height = 0; loc_CaptureDevice.ScaledWidth = 0; loc_CaptureDevice.ScaledHeight = 0;  loc_CaptureDevice.Window = NULL; loc_CaptureDevice.Delay = 0; loc_CaptureDevice.CapUnit = 0; /*global alpha, effect array init*/ c_alpha = 0; op0 = R_DRW2D_EFFECT_COLOR_OPERAND_RGBA;  effect_stages[0].Name = R_DRW2D_EFFECT_REPLACE;  effect_stages[0].Args[0].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[0].Args[0].Param.Color.Source.TextureUnit = 0; effect_stages[0].Args[0].Param.Color.Operand = op0;  effect_stages[0].Args[1].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[0].Args[1].Param.Color.Source.TextureUnit = 0; effect_stages[0].Args[1].Param.Color.Operand = op0;  effect_stages[0].Args[2].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[0].Args[2].Param.Color.Source.TextureUnit = 0; effect_stages[0].Args[2].Param.Color.Operand = op0;  effect_stages[0].Args[3].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[0].Args[3].Param.Color.Source.TextureUnit = 0; effect_stages[0].Args[3].Param.Color.Operand = op0;   effect_stages[1].Name = R_DRW2D_EFFECT_REPLACE;  effect_stages[1].Args[0].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[1].Args[0].Param.Color.Source.TextureUnit = 0; effect_stages[1].Args[0].Param.Color.Operand = op0;  effect_stages[1].Args[1].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[1].Args[1].Param.Color.Source.TextureUnit = 0; effect_stages[1].Args[1].Param.Color.Operand = op0;  effect_stages[1].Args[2].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[1].Args[2].Param.Color.Source.TextureUnit = 0; effect_stages[1].Args[2].Param.Color.Operand = op0;  effect_stages[1].Args[3].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[1].Args[3].Param.Color.Source.TextureUnit = 0; effect_stages[1].Args[3].Param.Color.Operand = op0;  }   /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: jpg init called at exit */ #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) void qd_jpg_init(void) {  #if HMI_JPG_BITMAPS_NUMBER>0 r_jcua_Error_t error = R_JCUA_ERR_OK; error |= R_JCUA_Init(LOC_JCUA_UNIT);  error |= R_JCUA_DecoderOpen(LOC_JCUA_UNIT, hmi_loc_JpegCallbackFunction, 0); #endif  } #endif void qd_sprite_manager_init(void) { UINT32 index = 0; UINT8 layer_index = 0; UINT8 sprite_layer_nb =0;  for(layer_index = 1/*sprite 1--3 layer*/;layer_index < HMI_LAYER_MAX_CNT;layer_index++) { if(hmi_layer_info[layer_index] == HMI_LAYER_SPRITE) { sprite_layer_nb = layer_index-1; if(sprite_layer_nb < HMI_MAX_SPRITE_LAYER) { for(index=0;index < HMI_MAX_SPRITE_NB;index++) { hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Surface = NULL; hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Status = HMI_QD_SPRITESTATUS_NOT_INITIALIZED; hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Data = NULL; hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Width = 0; hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Height = 0; hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.PosX = 0; hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.PosY = 0; hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.PosZ = 0; hmi_sprite_list[sprite_layer_nb][index].sprite_id = HMI_NB_ELEMENTS; hmi_sprite_list[sprite_layer_nb][index].next_status = HMI_QD_SPRITESTATUS_DISABLED; } } } } }  /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: init texture manager called at exit */ void qd_texture_manager_init(void) {  #if ((HMI_SXY_BITMAPS_NUMBER + HMI_DXY_BITMAPS_NUMBER+\ HMI_DXY_IMAGELIST_NUMBER + HMI_SXY_IMAGELIST_NUMBER+\ HMI_DXY_SCROLLBAR_NUMBER + HMI_SXY_SCROLLBAR_NUMBER +\ HMI_DXY_BUTTON_NUMBER + HMI_SXY_BUTTON_NUMBER +\ HMI_JPG_BITMAPS_NUMBER) > 0) uint32_t i = 0; #endif  #if HMI_DXY_BITMAPS_NUMBER>0 for(i=0;i < HMI_DXY_BITMAPS_NUMBER;i++) { res_tex_dxy_bmp[i].pBuffer = NULL; res_tex_dxy_bmp[i].pData = NULL; res_tex_dxy_bmp[i].ticks = 0; } #endif  #if HMI_SXY_BITMAPS_NUMBER>0 for(i=0;i < 1/*HMI_SXY_BITMAPS_NUMBER*/;i++) { res_tex_sxy_bmp[i].pBuffer = NULL; res_tex_sxy_bmp[i].pData = NULL; res_tex_sxy_bmp[i].ticks = 0; } #endif  #if HMI_DXY_IMAGELIST_NUMBER>0 for(i=0;i < HMI_DXY_IMAGELIST_NUMBER;i++) { res_tex_dxy_imagelist[i].pBuffer= NULL; res_tex_dxy_imagelist[i].pData = NULL; res_tex_dxy_imagelist[i].ticks = 0; } #endif  #if HMI_SXY_IMAGELIST_NUMBER>0 for(i=0;i < HMI_SXY_IMAGELIST_NUMBER;i++) { res_tex_sxy_imagelist[i].pBuffer= NULL; res_tex_sxy_imagelist[i].pData = NULL; res_tex_sxy_imagelist[i].ticks = 0; } #endif  #if HMI_DXY_SCROLLBAR_NUMBER > 0  for(i=0;i < HMI_DXY_SCROLLBAR_NUMBER;i++) { res_tex_dxy_scrollbar[i].pBuffer= NULL; res_tex_dxy_scrollbar[i].pData = NULL; res_tex_dxy_scrollbar[i].ticks = 0; } #endif  #if HMI_SXY_SCROLLBAR_NUMBER > 0 for(i=0;i < HMI_SXY_SCROLLBAR_NUMBER;i++) { res_tex_sxy_scrollbar[i].pBuffer= NULL; res_tex_sxy_scrollbar[i].pData = NULL; res_tex_sxy_scrollbar[i].ticks = 0; } #endif  #if HMI_DXY_BUTTON_NUMBER > 0  for(i=0;i < HMI_DXY_BUTTON_NUMBER;i++) { res_tex_dxy_button[i].pBuffer = NULL; res_tex_dxy_button[i].pData = NULL; res_tex_dxy_button[i].ticks = 0; } #endif  #if HMI_SXY_BUTTON_NUMBER>0  for(i=0;i < HMI_SXY_BUTTON_NUMBER;i++) { res_tex_sxy_button[i].pBuffer = NULL; res_tex_sxy_button[i].pData = NULL; res_tex_sxy_button[i].ticks = 0; } #endif  #if HMI_JPG_BITMAPS_NUMBER > 0 for(i=0;i < HMI_JPG_BITMAPS_NUMBER ;i++) {  jpg_buffer_tex_manager[i].ticks = 0; jpg_buffer_tex_manager[i].hmi_object_id = HMI_NB_ELEMENTS; jpg_buffer_tex_manager[i].pBuffer = NULL; } #endif  hmi_conv_buf.Data = NULL; hmi_conv_buf.Pitch = 0; hmi_conv_buf.PixelFormat = R_DRW2D_PIXELFORMAT_NONE; hmi_conv_buf.Size.Height = 0; hmi_conv_buf.Size.Width = 0; hmi_blur_buffer.Buffer.Data = NULL; hmi_blur_buffer.Buffer.Pitch = 0; hmi_blur_buffer.Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_NONE; hmi_blur_buffer.Buffer.Size.Height = 0; hmi_blur_buffer.Buffer.Size.Width = 0; hmi_blur_buffer.Flags = __R_DRW2D_FRAMEBUFFERFLAGS_PLACEHOLDER__; hmi_blur_buffer.Handle = NULL; hmi_jpg_blur_buffer.Buffer.Data = NULL; hmi_jpg_blur_buffer.Buffer.Pitch = 0; hmi_jpg_blur_buffer.Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_NONE; hmi_jpg_blur_buffer.Buffer.Size.Height = 0; hmi_jpg_blur_buffer.Buffer.Size.Width = 0; hmi_jpg_blur_buffer.Flags = __R_DRW2D_FRAMEBUFFERFLAGS_PLACEHOLDER__; hmi_jpg_blur_buffer.Handle = NULL; hmi_rle_blur_buffer.Buffer.Data = NULL; hmi_rle_blur_buffer.Buffer.Pitch = 0; hmi_rle_blur_buffer.Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_NONE; hmi_rle_blur_buffer.Buffer.Size.Height = 0; hmi_rle_blur_buffer.Buffer.Size.Width = 0; hmi_rle_blur_buffer.Flags = __R_DRW2D_FRAMEBUFFERFLAGS_PLACEHOLDER__; hmi_rle_blur_buffer.Handle = NULL; }   /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: init rgl called at exit */ void call_C_hmi_driver_deinit(void) { int32_t ret = R_DRW2D_ERR_OK;  int8_t loop = 0;  #ifndef _WIN32 //loc_StopSFMA();//removed by pxguo #endif //locCleanUpVRAM_hmi(); for(loop = 0;loop < HMI_LAYER_MAX_CNT;loop++) { off_all_sprite(loop); } free_all_jpg_buffer_res_manager(); free_all_buffer_res_manager(); hmi_driver_clear_rgl_window(); #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret |= R_JCUA_DeInit(LOC_JCUA_UNIT); #endif #if HMI_ALL_FONT_NUMBER > 0 hmi_release_font_buffer(); #endif }  /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: convert QD color to rgl window color */ r_wm_WinColorFmt_t convert_win_color_rgl() { r_wm_WinColorFmt_t color_fmt = R_WM_COLORFMT_RGBA8888;  #if(HMI_PIX_FORMAT == HMI_RGB565) { color_fmt = R_WM_COLORFMT_RGB565; } #elif(HMI_PIX_FORMAT == HMI_RGB888)//added by pxguo  { color_fmt = R_WM_COLORFMT_ARGB8888; } #elif(HMI_PIX_FORMAT == HMI_RGBA5551) { color_fmt = R_WM_COLORFMT_RGBA5551; } #elif(HMI_PIX_FORMAT == HMI_ARGB1555) { color_fmt = R_WM_COLORFMT_ARGB1555; } #elif(HMI_PIX_FORMAT == HMI_RGBA8888) { color_fmt = R_WM_COLORFMT_RGBA8888; } #elif(HMI_PIX_FORMAT == HMI_ARGB8888) { color_fmt = R_WM_COLORFMT_ARGB8888; } #else { #error RGL not support! } #endif return color_fmt; }  /* texture and framebuffer color format */ #if 0 r_drw2d_PixelFormat_t convert_texture_color_rgl() { r_drw2d_PixelFormat_t pixel_fmt = R_DRW2D_PIXELFORMAT_ARGB8888;  #if(HMI_PIX_FORMAT == HMI_RGB565) { pixel_fmt = R_DRW2D_PIXELFORMAT_RGB565; } #elif(HMI_PIX_FORMAT == HMI_RGB888) { pixel_fmt = R_DRW2D_PIXELFORMAT_RGBA8888; } #elif(HMI_PIX_FORMAT == HMI_RGBA5551) { pixel_fmt = R_DRW2D_PIXELFORMAT_RGBA5551 ; } #elif(HMI_PIX_FORMAT == HMI_ARGB1555) {  #error RGL not support ARGB1555 format,Please check QD Plus.Configure->Color_Depth  } #elif(HMI_PIX_FORMAT == HMI_RGBA8888) { pixel_fmt = R_DRW2D_PIXELFORMAT_RGBA8888; } #elif(HMI_PIX_FORMAT == HMI_ARGB8888) { pixel_fmt = R_DRW2D_PIXELFORMAT_ARGB8888; }  #else { #error RGL not support ARGB1555 format,Please check QD Plus.Configure->Color_Depth  } #endif return pixel_fmt;//added by pxguo } #endif  /*get color format length*/ #if 0 BYTE get_color_len(r_wm_WinColorFmt_t color_fmt) { BYTE len = 0;  if(color_fmt == R_WM_COLORFMT_RGB565 ) { len = 2; } else if((color_fmt == R_WM_COLORFMT_ARGB8888 )|| (color_fmt == R_WM_COLORFMT_RGBA8888 )) { len = 4; } else if((color_fmt == R_WM_COLORFMT_RLE24ARGB8888 )|| (color_fmt == R_WM_COLORFMT_RLE24RGB0888)) { len = 3; }  else { len = 3; } return len; } #endif  #if(HMI_BUFFER_NUMBER == HMI_ONE_BUFFER)  void locVBlank_hmi(void) { r_drw2d_Error_t wm_err =R_DRW2D_ERR_OK; //HMI_RECT_STR dirty_zone[4]={0};  if(HMI_GFX_GET_STATUS(HMI_RGL_FINISH_FLAG)!=0) { wm_err = R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV, HMI_GPU_FINISH_FLAG); HMI_GFX_CLEAR_STATUS(HMI_RGL_FINISH_FLAG); HMI_GFX_CLEAR_STATUS(HMI_SEND_EVENT); } } #endif  /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: clear 4 layer */ void hmi_driver_clear_rgl_window(void) {  uint32_t i = 0;  for(i=0;i < HMI_LAYER_MAX_CNT;i++) { if(locSurface[i] != NULL) { hmi_qd_disablesurface(locSurface[i]); hmi_qd_deletesurface(locSurface[i]); } locSurface_rect[i].x = 0; locSurface_rect[i].y = 0; locSurface_rect[i].w = 0; locSurface_rect[i].h = 0; }  } /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: create layer */  void hmi_driver_create_rgl_window(HMI_RECT_STR hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml pRect,UINT8 layer) {  //static UINT8 loc_vbank = 0;  if((pRect != NULL)&&(layer < HMI_LAYER_MAX_CNT)) { if((hmi_layer_info[layer] == HMI_LAYER_RLE)&& (layer == 0/*only layer 0 can be rle window*/)) { /*RLE*/ if(locSurface[layer] == NULL) { locSurface[layer] = hmi_qd_createsurface(HMI_LOC_VOVIAL_UNIT,  HMI_QD_RLE24RGB0888,//HMI_QD_RLE24RGB0888,  pRect->x,pRect->y,  layer,  ((HMI_STRIDE(pRect->w*HMI_ARGB_LEN)+HMI_RGL_WND_BURST_LEN)/HMI_ARGB_LEN),//pitch pRect->w,pRect->h,  0xff/*alpha*/, 1, HMI_QD_CRFLAG_RLE);  } else  { if((locSurface_rect[layer].w != pRect->w) ||(locSurface_rect[layer].h != pRect->h)) {  if(locSurface[layer] != NULL) { hmi_qd_disablesurface(locSurface[layer]); hmi_qd_deletesurface(locSurface[layer]); locSurface[layer] = hmi_qd_createsurface(HMI_LOC_VOVIAL_UNIT,  HMI_QD_RLE24RGB0888,//HMI_QD_RLE24ARGB8888,  pRect->x,pRect->y,  layer,  ((HMI_STRIDE(pRect->w*HMI_ARGB_LEN)+HMI_RGL_WND_BURST_LEN)/HMI_ARGB_LEN),//pitch pRect->w,pRect->h,  0xff/*alpha*/, 1, HMI_QD_CRFLAG_RLE); hmi_driver_send_cmdlist();// lq } } else if((locSurface_rect[layer].x != pRect->x)|| (locSurface_rect[layer].y != pRect->y)) { hmi_qd_movesurface(locSurface[layer], pRect->x,pRect->y,0/*only layer 0 can be rle window*/);  } else { } } if(locSurface[layer] == NULL)/*Create layer failed*/ {  hmi_error_handler(R_DRW2D_ERR_FRAMEBUFFER); #if(HMI_ENDLESS_LOOP==YES) while(1); #endif } else { locSurface_rect[layer].x = pRect->x; locSurface_rect[layer].y = pRect->y; locSurface_rect[layer].w = pRect->w; locSurface_rect[layer].h = pRect->h;  } } else if((hmi_layer_info[layer] == HMI_LAYER_SPRITE)&& ((layer == 1)||(layer == 2)||(layer == 3)))/*only window 1,2,3 can be sprite window*/ { /*sprite*/ if(locSurface[layer] == NULL )/*first build the layer*/ { locSurface[layer] = hmi_qd_createsurface(HMI_LOC_VOVIAL_UNIT,  HMI_LOC_SPRITE_VOVIAL_FORMAT/*ARGB*/,  pRect->x, pRect->y, layer, 0, pRect->w,pRect->h,  0xff, 1,  HMI_QD_CRFLAG_SPRITE);  } else { if((locSurface_rect[layer].w != pRect->w)|| (locSurface_rect[layer].h != pRect->h)) {  if(locSurface[layer] != NULL) { off_all_sprite(layer); hmi_qd_disablesurface(locSurface[layer]); hmi_qd_deletesurface(locSurface[layer]); locSurface[layer] = hmi_qd_createsurface(HMI_LOC_VOVIAL_UNIT,  HMI_LOC_VOVIAL_FORMAT/*ARGB*/,  pRect->x, pRect->y, layer, 0, pRect->w,pRect->h,  0xff, 1,  HMI_QD_CRFLAG_SPRITE); hmi_driver_send_cmdlist();// lq } } else if((locSurface_rect[layer].x != pRect->x) ||(locSurface_rect[layer].y != pRect->y)) { hmi_qd_movesurface(locSurface[layer], pRect->x,pRect->y,0);  } else { } } if(locSurface[layer] == NULL)/*Create layer failed*/ { hmi_error_handler(R_DRW2D_ERR_FRAMEBUFFER);  #if(HMI_ENDLESS_LOOP==YES) while(1); #endif } else { locSurface_rect[layer].x = pRect->x; locSurface_rect[layer].y = pRect->y; locSurface_rect[layer].w = pRect->w; locSurface_rect[layer].h = pRect->h;  } } else if(hmi_layer_info[layer] == HMI_LAYER_VIDEOIN) { #if 0 if(layer_video_element[layer] != NULL)/*Capture video container*/ { if((*layer_video_element[layer])&HMI_VIDEO_ENABLE_STATUS) { pRect->w=(pRect->w*4/4); pRect->h=(pRect->h*4/4); } } #endif /*video in*/ if(locSurface[layer] == NULL) { locSurface[layer] = hmi_qd_createsurface(HMI_LOC_VOVIAL_UNIT,  HMI_LOC_VOVIAL_FORMAT/*ARGB*/,  pRect->x, pRect->y, layer,  ((HMI_STRIDE(pRect->w*hmi_bpp))/hmi_bpp), pRect->w, pRect->h,  0xff/*alpha*/, HMI_BUFFER_NUMBER, 0);  } else {  #if 1 if((locSurface_rect[layer].w!=pRect->w)||(locSurface_rect[layer].h!=pRect->h)) {  if(locSurface[layer] != NULL) { hmi_qd_disablesurface(locSurface[layer]); hmi_qd_deletesurface(locSurface[layer]);  locSurface[layer] = hmi_qd_createsurface(HMI_LOC_VOVIAL_UNIT,  HMI_LOC_VOVIAL_FORMAT/*ARGB*/,  pRect->x, pRect->y, layer,  ((HMI_STRIDE(pRect->w*hmi_bpp))/hmi_bpp),//pitch/*HMI_STRIDE(rect->w)*/, pRect->w, pRect->h,  0xff/*alpha*/, HMI_BUFFER_NUMBER, 0); hmi_driver_send_cmdlist();// lq } } else if((locSurface_rect[layer].x!=pRect->x)||(locSurface_rect[layer].y!=pRect->y)) { hmi_qd_movesurface(locSurface[layer], pRect->x,pRect->y,0);  } else { } #endif } if(locSurface[layer] == NULL)/*Create layer failed*/ { hmi_error_handler(R_DRW2D_ERR_FRAMEBUFFER);  #if(HMI_ENDLESS_LOOP==YES) while(1); #endif } else { locSurface_rect[layer].x = pRect->x; locSurface_rect[layer].y = pRect->y; locSurface_rect[layer].w = pRect->w; locSurface_rect[layer].h = pRect->h; //hmi_qd_register_vi_vblankisr(locSurface[layer], &loc_VI_VBlank_hmi); hmi_qd_enablesurface(locSurface[layer]); } } else if(hmi_layer_info[layer] == HMI_LAYER_BUFFER) { /*buffer*/ if(locSurface[layer] == NULL) { locSurface[layer] = hmi_qd_createsurface(HMI_LOC_VOVIAL_UNIT,  HMI_LOC_VOVIAL_FORMAT/*ARGB*/,  pRect->x, pRect->y, layer,  ((HMI_STRIDE(pRect->w*hmi_bpp))/hmi_bpp)/*HMI_STRIDE(rect->w) lq.2016.9.20*/, pRect->w, pRect->h,  0xff/*alpha*/, HMI_BUFFER_NUMBER, 0);  } else { if((locSurface_rect[layer].w != pRect->w)|| (locSurface_rect[layer].h != pRect->h)) {  if(locSurface[layer] != NULL) { hmi_qd_disablesurface(locSurface[layer]); hmi_qd_deletesurface(locSurface[layer]);  locSurface[layer] = hmi_qd_createsurface(HMI_LOC_VOVIAL_UNIT,  HMI_LOC_VOVIAL_FORMAT/*ARGB*/,  pRect->x, pRect->y, layer,  ((HMI_STRIDE(pRect->w*hmi_bpp))/hmi_bpp), pRect->w, pRect->h,  0xff/*alpha*/, HMI_BUFFER_NUMBER, 0); hmi_driver_send_cmdlist();// lq } } else if((locSurface_rect[layer].x != pRect->x)|| (locSurface_rect[layer].y != pRect->y)) { hmi_qd_movesurface(locSurface[layer], pRect->x,pRect->y,0);  } else { } } if(locSurface[layer] == NULL)/*Create layer failed*/ { hmi_error_handler(R_DRW2D_ERR_FRAMEBUFFER);  #if(HMI_ENDLESS_LOOP==YES) while(1); #endif } else { locSurface_rect[layer].x = pRect->x;  locSurface_rect[layer].y = pRect->y; locSurface_rect[layer].w = pRect->w; locSurface_rect[layer].h = pRect->h; #if 0 if(i==0)  { // hmi_qd_registervblankisr(locSurface[layer], &locVBlank_hmi); hmi_qd_register_vi_vblankisr(locSurface[HMI_LAYER_VIDEOIN], &loc_VI_VBlank_hmi);  i=1; } #endif //wm_err = R_WM_FrameEndMark(HMI_LOC_VOVIAL_UNIT, 0);  //wm_err = R_WM_FrameWait(HMI_LOC_VOVIAL_UNIT, 0); } } else {  } } }  /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: get window by layer called at reset */ void *hmi_get_window(UINT8 layer) {  void *GetlocSurface = NULL;  if(layer >= HMI_LAYER_MAX_CNT) { layer = HMI_LAYER_MAX_CNT-1; } #if 0 GetlocSurface=(void*)LOC_ENCODE_SURF1(HMI_LOC_VOVIAL_UNIT, layer); #else GetlocSurface = locSurface[layer]; #endif return GetlocSurface; }  /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: get framebuffer from window called at reset */ #if 0 r_drw2d_Framebuffer_t *hmi_get_window_fm(UINT8 layer) { return 0; } #endif /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: convert QD rect struct to RGL rect struct */ BOOLEAN convertRect2RectRGL(HMI_RECT_STR *prect,r_drw2d_Rect_t *prect_rgl,BOOLEAN fix_point) { BOOLEAN success = FALSE;  if((prect != NULL)&&(prect_rgl != NULL)) { if(fix_point) { prect_rgl->Pos.X = R_DRW2D_2X(prect->x); prect_rgl->Pos.Y = R_DRW2D_2X(prect->y); prect_rgl->Size.Height = R_DRW2D_2X(prect->h); prect_rgl->Size.Width = R_DRW2D_2X(prect->w); } else { prect_rgl->Pos.X = prect->x; prect_rgl->Pos.Y = prect->y; prect_rgl->Size.Height = prect->h; prect_rgl->Size.Width = prect->w;  } success=TRUE; } return success; }   /*API bottom level*/ /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: init rgl called at reset */ void call_C_hmi_driver_init(void) { qd_rgl_driver_init(); qd_layer_pos_init(); qd_variable_init(); qd_texture_manager_init(); #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) #if( HMI_JPG_BITMAPS_NUMBER>0) qd_jpg_init(); #endif #endif qd_sprite_manager_init(); clear_layer_video_status(); #if HMI_ALL_FONT_NUMBER > 0 hmi_init_font_buffer(); #endif }   #if ((HMI_DYN_EDIT_TEXTS_NUMBER > 0U) || (HMI_STATIC_TEXTS_NUMBER > 0U)) static void hmi_driver_copy_image(HMI_RECT_STR CONST *pscreen_target,  HMI_BITMAP_STR CONST *pimage_prop_info, UINT8 image_format, HMI_COLOR_STR color, HMI_RECT_STR *pclip_rect, HMI_RECT_STR *pdirty_rect, BOOLEAN transp_flag, UINT8 layer #ifdef HMI_GRAPHIC_RGL ,UINT8 father_alpha ,UINT8 font_id ,HMI_FONT_CHAR_STR hmi_char #endif )  {  CONST UINT8 hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml pImage_data = pimage_prop_info->pbitmap_data;  HMI_RECT_STR image_rect = {0,0,0,0}; r_drw2d_Error_t ret = R_DRW2D_ERR_OK; r_drw2d_Texture_t tex = {NULL,{0},{0}}; r_drw2d_Rect_t rect = {0,0,0,0}; r_drw2d_Rect_t src_rect = {0,0,0,0}; r_drw2d_IntRect_t clip_rect = {0,0,0,0};  void* setlocSurface =NULL; HMI_RECT_STR hmi_disp_target = {0,0,0,0}; UINT8 image_alpha = 0; rgl_image_type_str image_type = HMI_IMAGE_NO_COMPRESS; UINT8 clip_index = 0; UINT8 next_clip_index = 0; HMI_RECT_STR hmi_min_dirty_rect = {0,0,0,0}; /*set window*/ setlocSurface = hmi_get_window(layer); locGetRenderTarget(setlocSurface); hmi_disp_target.x = pscreen_target->x; hmi_disp_target.y = pscreen_target->y; hmi_disp_target.w = pscreen_target->w; hmi_disp_target.h = pscreen_target->h; /*convert screen coordinate to layer coordinate*/ hmi_disp_target.x -= locSurface_rect[layer].x; hmi_disp_target.y -= locSurface_rect[layer].y;  image_rect.x = hmi_disp_target.x; image_rect.y = hmi_disp_target.y; image_rect.w = pimage_prop_info->w; image_rect.h = pimage_prop_info->h;  #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret |= R_DRW2D_CtxImgQuality(HMI_LOC_DRW2D_DEV, R_DRW2D_IMGQUALITY_MEDIUM); #endif if(R_DRW2D_ERR_OK == ret) { ret |= R_DRW2D_CtxTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TRANSFORM_2D); }  if( (image_rect.h != 0U)&&  (image_rect.w != 0U)&&  (pclip_rect != NULL)&& (pImage_data != NULL)) { if(image_format == HMI_1BPP) { image_type = HMI_IMAGE_ALPHA1; } else if(image_format == HMI_2BPP) { image_type = HMI_IMAGE_ALPHA2; } else if(image_format == HMI_4BPP) { image_type = HMI_IMAGE_ALPHA4; } else if(image_format == HMI_8BPP) { image_type = HMI_IMAGE_ALPHA8; } else { image_type = HMI_IMAGE_ALPHA8;  }  get_texture_res_manager((HMI_OBJECT_ID_STR)font_id/*HMI_NB_ELEMENTS*//*not used*/, &tex,(U08 *)pImage_data, 0xff/*not used*/, image_rect.w, image_rect.h, FALSE/*no rotation*/, image_type, 0, hmi_char); if(tex.Buffer.Data !=NULL) { ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); setlocSurface = hmi_get_window(layer); locGetRenderTarget(setlocSurface); /*@20170831 gpx hmi_driver modify*/ ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_SRC_OVER/*R_DRW2D_BLENDMODE_SRC_OVER*/);  /*ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_CUSTOM);  ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV, R_DRW2D_BLEND_SRC_ALPHA, R_DRW2D_BLEND_ONE_MINUS_SRC_ALPHA, R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE  );*/ ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE); image_alpha = HMI_RGL_ALLPHA(color); if(father_alpha < image_alpha) { image_alpha = father_alpha; }  color = HMI_RGL_SET_ALPHA(image_alpha,color); effect_stages[0].Name = R_DRW2D_EFFECT_MODULATE; effect_stages[0].Args[0].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[0].Args[0].Param.Color.Source.TextureUnit = 0; effect_stages[0].Args[0].Param.Color.Operand = R_DRW2D_EFFECT_COLOR_OPERAND_RGBA; effect_stages[0].Args[1].Source = R_DRW2D_EFFECT_SOURCE_CONSTANT_COLOR;  effect_stages[0].Args[1].Param.Color.Source.ConstantColor = color;  effect_stages[0].Args[1].Param.Color.Operand = R_DRW2D_EFFECT_COLOR_OPERAND_RGBA;  ret |= R_DRW2D_CtxEffectsSet(HMI_LOC_DRW2D_DEV, effect_stages, 1);  ret |= R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0, &tex);  convertRect2RectRGL(&hmi_disp_target/*&image_rect*/, &rect,TRUE/*fix point*/);//changed by pxguo 160827  src_rect.Pos.X = R_DRW2D_2X(0); src_rect.Pos.Y = R_DRW2D_2X(0); src_rect.Size.Height= R_DRW2D_2X(image_rect.h); src_rect.Size.Width = R_DRW2D_2X(image_rect.w); next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV, &src_rect,&rect); } clip_index++; next_clip_index++; } ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); if (R_DRW2D_ERR_OK != ret) { loc_Error_hmi(ret); } } } }  #endif  //#endif  #if ((HMI_DYN_EDIT_TEXTS_NUMBER > 0U) || (HMI_STATIC_TEXTS_NUMBER > 0U)) HMI_FONT_CHAR_STR hmi_get_value_char(HMI_CHAR_STR hmi_hb_char,HMI_CHAR_STR hmi_lb_char,UINT8 *text_offset) { HMI_FONT_CHAR_STR hmi_value_char = HMI_INVALID_CHAR;  if(hmi_lb_char == 0U) { #if (HMI_FONT_CODE==HMI_FONT_CODE_UNICODE) hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; #endif #if (HMI_FONT_CODE == HMI_FONT_CODE_GB2312) if(hmi_hb_char < HMI_GB2312_HB_MIN) { hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; } else { hmi_value_char = HMI_INVALID_CHAR; *text_offset = 0U; } #endif #if(HMI_FONT_CODE == HMI_FONT_CODE_GBK) if(hmi_hb_char < HMI_GBK_HB_MIN) { hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; } else { hmi_value_char = HMI_INVALID_CHAR; *text_offset = 0U; } #endif #if(HMI_FONT_CODE == HMI_FONT_CODE_BIG5) if(hmi_hb_char < HMI_BIG5_HB_MIN) { hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; } else { hmi_value_char = HMI_INVALID_CHAR; *text_offset = 0U; } #endif #if(HMI_FONT_CODE == HMI_FONT_CODE_IBM) hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; #endif #if(HMI_FONT_CODE == HMI_FONT_CODE_SJIS) if(((hmi_hb_char >= HMI_SJIS_ASCII_MIN)&&(hmi_hb_char <= HMI_SJIS_ASCII_MID2))|| ((hmi_hb_char >= HMI_SJIS_ASCII_MID1)&&(hmi_hb_char <= HMI_SJIS_ASCII_MAX))) { hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; } else { hmi_value_char = HMI_INVALID_CHAR; *text_offset = 0U; } #endif  } else { #if(HMI_FONT_CODE == HMI_FONT_CODE_UNICODE) hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U;  #endif #if(HMI_FONT_CODE == HMI_FONT_CODE_GB2312) if(hmi_hb_char < HMI_GB2312_HB_MIN) { hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; } else if(((hmi_hb_char >= HMI_GB2312_HB_MIN)&&(hmi_hb_char <= HMI_GB2312_HB_MAX))&& ((hmi_lb_char >= HMI_GB2312_LB_MIN)&&(hmi_lb_char <= HMI_GB2312_LB_MAX))) { hmi_value_char = (HMI_FONT_CHAR_STR)((hmi_hb_char << 8)+hmi_lb_char); *text_offset = 1U; } else { hmi_value_char = HMI_INVALID_CHAR; *text_offset = 1U; } #endif #if(HMI_FONT_CODE == HMI_FONT_CODE_GBK)  if(hmi_hb_char < HMI_GBK_HB_MIN) { hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; } else if(((hmi_hb_char >= HMI_GBK_HB_MIN)&&(hmi_hb_char <= HMI_GBK_HB_MAX))&& ((hmi_lb_char >= HMI_GBK_LB_MIN)&&(hmi_lb_char <= HMI_GBK_LB_MAX)&& (hmi_lb_char != HMI_GBK_LB_INVALID))) { hmi_value_char = (HMI_FONT_CHAR_STR)((hmi_hb_char << 8)+hmi_lb_char); *text_offset = 1U; } else { hmi_value_char = HMI_INVALID_CHAR; *text_offset = 1U; } #endif #if(HMI_FONT_CODE == HMI_FONT_CODE_BIG5)  if(hmi_hb_char < HMI_BIG5_HB_MIN) { hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; } else if((hmi_hb_char >= HMI_BIG5_HB_MIN)&&(hmi_hb_char <= HMI_BIG5_HB_MAX))  { if(((hmi_lb_char >= HMI_BIG5_LB_MIN)&&(hmi_lb_char <= HMI_BIG5_LB_MID2))|| ((hmi_lb_char >= HMI_BIG5_LB_MID1)&&(hmi_lb_char <= HMI_BIG5_LB_MAX))) { hmi_value_char = (HMI_FONT_CHAR_STR)((hmi_hb_char << 8)+hmi_lb_char); *text_offset = 1U; } else { hmi_value_char = HMI_INVALID_CHAR; *text_offset = 1U; } } else { hmi_value_char = HMI_INVALID_CHAR; *text_offset = 1U; } #endif #if(HMI_FONT_CODE == HMI_FONT_CODE_IBM) hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; #endif #if(HMI_FONT_CODE == HMI_FONT_CODE_SJIS) if(((hmi_hb_char >= HMI_SJIS_HB_MIN)&&(hmi_hb_char <= HMI_SJIS_HB_MID2))|| ((hmi_hb_char >= HMI_SJIS_HB_MID1)&&(hmi_hb_char <= HMI_SJIS_HB_MAX))) { if(((hmi_lb_char >= HMI_SJIS_LB_MIN)&&(hmi_lb_char <= HMI_SJIS_LB_MID2))||((hmi_lb_char>=HMI_SJIS_LB_MID1)&&(hmi_lb_char<=HMI_SJIS_LB_MAX))) { hmi_value_char = (HMI_FONT_CHAR_STR)((hmi_hb_char << 8)+hmi_lb_char); *text_offset = 1U; } else { hmi_value_char = HMI_INVALID_CHAR; *text_offset = 1U; } } else if(((hmi_hb_char >= HMI_SJIS_ASCII_MIN)&&(hmi_hb_char <= HMI_SJIS_ASCII_MID2))|| ((hmi_hb_char >= HMI_SJIS_ASCII_MID1)&&(hmi_hb_char <= HMI_SJIS_ASCII_MAX))) { hmi_value_char = (HMI_FONT_CHAR_STR)hmi_hb_char; *text_offset = 0U; } else { hmi_value_char = HMI_INVALID_CHAR; *text_offset = 1U; } #endif } return(hmi_value_char); }    HMI_FONT_CHAR_STR hmi_get_last_value_char(HMI_CHAR_STR *phmi_char_array,UINT8 cur_index,UINT8 *text_offset) { HMI_FONT_CHAR_STR hmi_value_char = HMI_INVALID_CHAR; HMI_FONT_CHAR_STR hmi_temp_char = HMI_INVALID_CHAR; UINT8 hmi_text_index = 0U; UINT8 hmi_offset = 0U;  while(hmi_text_index <= cur_index) { hmi_offset = 0U; if(hmi_text_index == cur_index) { hmi_temp_char = hmi_get_value_char(phmi_char_array[hmi_text_index],0U,&hmi_offset); } else { hmi_temp_char = hmi_get_value_char(phmi_char_array[hmi_text_index],phmi_char_array[hmi_text_index+1],&hmi_offset); } hmi_text_index += 1; hmi_text_index += hmi_offset; } hmi_value_char = hmi_temp_char; *text_offset = hmi_offset;  return (hmi_value_char); }  static HMI_FONT_CHAR_PROP CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_driver_get_char_data(HMI_FONT_CHAR_STR hmi_char,  HMI_FONT_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml phmi_font_table, UINT8 hmi_font_id)  { HMI_FONT_RANGE_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml phmi_font_range = phmi_font_table->p_range_table; HMI_FONT_CHAR_PROP CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml phmi_temp_font_data = NULL; #if (HMI_CHAR_SEARCH_MODE == HMI_HYBRID_ENCODE_STR) || (HMI_CHAR_SEARCH_MODE == HMI_LINEAR_ENCODE_STR) #if (HMI_CHAR_SEARCH_MODE == HMI_HYBRID_ENCODE_STR) if(phmi_font_table->number_table <= 8U ) #endif { HMI_FONT_CHAR_STR hmi_base_char_data = 0U; HMI_FONT_CHAR_STR hmi_linear_count = 0U; hmi_linear_count = 0U; while( hmi_linear_count < phmi_font_table->number_table) { hmi_linear_count++; if(hmi_char == phmi_font_range->ch_code) { phmi_temp_font_data = phmi_font_range->p_char_config; break; } else if(hmi_char > phmi_font_range->ch_code) { if((phmi_font_range->attributes &HMI_FONT_SEARCH_MODE_TLUP) == HMI_FONT_SEARCH_MODE_TLUP) { phmi_temp_font_data = phmi_font_range->p_char_config; hmi_base_char_data = phmi_font_range->ch_code; phmi_font_range++; if(hmi_char == phmi_font_range->ch_code)/*add by pxguo*/ { phmi_temp_font_data = phmi_font_range->p_char_config; break; } else if(hmi_char < phmi_font_range->ch_code) { if(hmi_char != phmi_font_range->ch_code) { phmi_temp_font_data = &phmi_temp_font_data[hmi_char-hmi_base_char_data]; } break; } else { } hmi_linear_count++; } } else { break; } phmi_font_range++; } } #endif #if HMI_CHAR_SEARCH_MODE==HMI_HYBRID_ENCODE_STR else #endif #if (HMI_CHAR_SEARCH_MODE==HMI_HYBRID_ENCODE_STR)||(HMI_CHAR_SEARCH_MODE==HMI_BINARY_ENCODE_STR) { UINT16 hmi_high = phmi_font_table->number_table-1U; UINT16 hmi_low = 0U; UINT16 hmi_mid = 0U;  while(hmi_high > hmi_low) { hmi_mid = (hmi_high-hmi_low) >> 1U;  if(hmi_mid != 0U) { if(phmi_font_range[hmi_mid].ch_code < hmi_char) { hmi_low = hmi_mid+hmi_low; } else { hmi_high = hmi_mid; } } else { if((phmi_font_range[hmi_low].attributes &HMI_FONT_SEARCH_MODE_TLUP)==HMI_FONT_SEARCH_MODE_TLUP) { if(hmi_char >= phmi_font_range[hmi_low].ch_code) { phmi_temp_font_data = phmi_font_range[hmi_low].p_char_config; phmi_temp_font_data = &phmi_temp_font_data[hmi_char - phmi_font_range[hmi_low].ch_code]; } } else { if(hmi_char == phmi_font_range[hmi_high].ch_code) { phmi_temp_font_data = phmi_font_range[hmi_high].p_char_config; phmi_temp_font_data = &phmi_temp_font_data[0];  } else if(hmi_char == phmi_font_range[hmi_low].ch_code) { phmi_temp_font_data = phmi_font_range[hmi_low].p_char_config; phmi_temp_font_data = &phmi_temp_font_data[0];  }  else { } } break; } }  } #endif return(phmi_temp_font_data); } #endif /***common rect***/ void hmi_get_union_rect(HMI_RECT_STR CONST *p_r1,HMI_RECT_STR CONST *p_r2,HMI_RECT_STR *phmi_temp_rect) {  HMI_X_STR min_right = 0; HMI_Y_STR min_bottom = 0;  if((p_r1 != NULL)&&(p_r2 != NULL)&&(phmi_temp_rect != NULL)) {  phmi_temp_rect->x = HMI_INVALID_COOR; phmi_temp_rect->y = HMI_INVALID_COOR; phmi_temp_rect->w = 0; phmi_temp_rect->h = 0; if((p_r1->x) > (p_r2->x)) { phmi_temp_rect->x = p_r1->x; } else { phmi_temp_rect->x = p_r2->x; } if((p_r1->y) > (p_r2->y)) { phmi_temp_rect->y = p_r1->y; } else { phmi_temp_rect->y = p_r2->y; }  if((p_r1->x+p_r1->w) < (p_r2->x+p_r2->w)) { min_right = p_r1->x + p_r1->w; } else { min_right =p_r2->x + p_r2->w; } if((p_r1->y+p_r1->h) < (p_r2->y+p_r2->h)) { min_bottom = p_r1->y + p_r1->h; } else { min_bottom = p_r2->y + p_r2->h; } if(phmi_temp_rect->x <= min_right) { phmi_temp_rect->w = min_right-phmi_temp_rect->x; } else { phmi_temp_rect->x = HMI_INVALID_COOR; phmi_temp_rect->y = HMI_INVALID_COOR; phmi_temp_rect->w = 0; phmi_temp_rect->h = 0; } if(phmi_temp_rect->y <= min_bottom) { phmi_temp_rect->h = min_bottom-phmi_temp_rect->y; } else { phmi_temp_rect->x = HMI_INVALID_COOR; phmi_temp_rect->y = HMI_INVALID_COOR; phmi_temp_rect->w = 0; phmi_temp_rect->h = 0; } }  }   /*for Top API call */ #if HMI_ALL_FONT_NUMBER > 0 #if ((HMI_DYN_EDIT_TEXTS_NUMBER > 0U) || (HMI_STATIC_TEXTS_NUMBER > 0U)) void call_C_hmi_driver_draw_text(HMI_TEXT_RECT_STR CONST *phmi_text_copy_rect/*screen target and color*/, HMI_TEXT_PROP_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml phmi_text_prop_info, HMI_RECT_STR *pclip_rect, HMI_RECT_STR *pdirty_rect, U08 font_id, UINT8 layer #ifdef HMI_CLIP_TEXT ,HMI_CHAR_STR CONST *phmi_clip_char #endif #ifdef HMI_GRAPHIC_RGL  ,UINT8 father_alpha #endif ) { HMI_RECT_STR text_copy_rect = {0U,0U,0U,0U}; HMI_RECT_STR text_clip_rect = {0U,0U,0U,0U}; HMI_RECT_STR copy_rect = {0U,0U,0U,0U}; HMI_X_STR hmi_copy_start_x = phmi_text_copy_rect->text_rect.x; CONST HMI_Y_STR hmi_copy_start_y = phmi_text_copy_rect->text_rect.y; HMI_CHAR_STR *phmi_temp_string = phmi_text_prop_info->hmi_string;  HMI_CHAR_STR *phmi_disp_string = phmi_text_prop_info->hmi_string; CONST HMI_FONT_STR *phmi_font_table = NULL; HMI_FONT_CHAR_PROP CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml phmi_font_config= 0U; HMI_WIDTH_STR hmi_text_width_temp = phmi_text_copy_rect->text_rect.w; HMI_WIDTH_STR hmi_text_width = 0U; HMI_Y_STR hmi_current_y = 0U; HMI_X_STR hmi_current_x = 0U; HMI_COLOR_STR hmi_text_color = 0U; UINT8 hmi_string_index = 0U; UINT8 hmi_string_temp_index = 0U; UINT8 hmi_text_offset = 0U; HMI_FONT_CHAR_STR hmi_char = 0U; #ifdef HMI_CLIP_TEXT BOOLEAN hmi_text_default_flag = FALSE; HMI_WIDTH_STR hmi_extend_text_len = 0U; HMI_WIDTH_STR hmi_extend_text_width = 0U; UINT8 hmi_extend_text_index = 0U; HMI_X_STR hmi_extext_copy_start_x = 0U; BOOLEAN hmi_ct_width_flag = FALSE; #endif #if HMI_SCROLL_TEXT_SUPPORT != 0U SINT16 hmi_scroll_offset_temp = 0; UINT16 hmi_text_real_width = 0U; SINT16 hmi_modify_scroll_offset= 0; #endif #if (HMI_SCROLL_TEXT_SUPPORT != 0U) || (HMI_DRAW_BITMAP_CLIP_SUPPORT != 0) SINT16 hmi_scroll_offset = 0; #endif HMI_BITMAP_STR text_data = {0,0,NULL}; UINT8 font_format = 0U; #ifdef HMI_CLIP_TEXT UINT8 index = 0U; #endif  if(phmi_disp_string !=NULL) { if(font_id == HMI_INVALIATE_FONT_ID) { font_id =phmi_text_prop_info->font_id; phmi_font_table = &hmi_font_table[phmi_text_prop_info->font_id]; } else { if(font_id < HMI_ALL_FONT_NUMBER) { phmi_font_table = &hmi_font_table[font_id]; } else { phmi_font_table = &hmi_font_table[0]; } } if(phmi_font_table->p_range_table != NULL)/*added lq*/ { if((phmi_font_table->p_range_table->attributes &HMI_FONT_ENCODING_1BPP) ==HMI_FONT_ENCODING_1BPP) { font_format = HMI_1BPP; } else if((phmi_font_table->p_range_table->attributes &HMI_FONT_ENCODING_2BPP) ==HMI_FONT_ENCODING_2BPP) { font_format = HMI_2BPP; } else if((phmi_font_table->p_range_table->attributes &HMI_FONT_ENCODING_4BPP) ==HMI_FONT_ENCODING_4BPP) { font_format = HMI_4BPP; } else if((phmi_font_table->p_range_table->attributes &HMI_FONT_ENCODING_8BPP) ==HMI_FONT_ENCODING_8BPP) { font_format = HMI_8BPP; } else { font_format = HMI_PIX_FORMAT; } #ifdef HMI_CLIP_TEXT while(phmi_clip_char[index]!=0U) { hmi_text_offset = 0U; hmi_char = hmi_get_value_char(phmi_clip_char[index],phmi_clip_char[index+1],&hmi_text_offset); phmi_font_config = hmi_driver_get_char_data(hmi_char, phmi_font_table, phmi_text_prop_info->font_id); hmi_extend_text_len += phmi_font_config->owidth; index += hmi_text_offset; index++; } hmi_extend_text_width = hmi_extend_text_len; #endif if(HMI_TEXT_PROP_ALIGN_IS_RIGHT(phmi_text_prop_info->properties)) { hmi_copy_start_x += hmi_text_width_temp-1; } else if(HMI_TEXT_PROP_ALIGN_IS_CENTRE(phmi_text_prop_info->properties)) { hmi_copy_start_x += (hmi_text_width_temp >> 0x01); } else { }  #if HMI_SCROLL_TEXT_SUPPORT != 0U if((phmi_text_prop_info->properties & HMI_TEXT_PROP_SCROLABLE) != 0) { #if HMI_FONT_CODE==HMI_FONT_CODE_UNICODE hmi_scroll_offset = phmi_temp_string[phmi_text_prop_info->length+1]; #else hmi_scroll_offset = (phmi_temp_string[phmi_text_prop_info->length+1]<<8); hmi_scroll_offset += phmi_temp_string[phmi_text_prop_info->length+2]; #endif hmi_modify_scroll_offset = hmi_scroll_offset; if(hmi_scroll_offset < 0U) { hmi_scroll_offset = -hmi_scroll_offset; if(hmi_scroll_offset < hmi_text_width_temp) { hmi_text_width_temp -= hmi_scroll_offset; if(HMI_TEXT_PROP_ALIGN_IS_RIGHT(phmi_text_prop_info->properties)) { hmi_copy_start_x -= hmi_scroll_offset; } else { hmi_copy_start_x += hmi_scroll_offset; } hmi_scroll_offset = 0U; } else { hmi_text_width_temp = 0U; } } hmi_scroll_offset_temp =hmi_scroll_offset; } else { hmi_scroll_offset = 0; hmi_scroll_offset_temp = 0; } #elif (HMI_DRAW_BITMAP_CLIP_SUPPORT != 0U) hmi_scroll_offset = 0; #endif  if((hmi_text_width_temp > 0U) && (phmi_disp_string[0] != 0U)) { if(HMI_TEXT_PROP_ALIGN_IS_RIGHT(phmi_text_prop_info->properties)) { #if HMI_SCROLL_TEXT_SUPPORT != 0U hmi_scroll_offset =0; #endif while(phmi_disp_string[hmi_string_temp_index] != 0U) { hmi_string_temp_index += 1; } while(&phmi_disp_string[hmi_string_temp_index] > phmi_temp_string) { hmi_string_temp_index -= 1; hmi_text_offset = 0U; hmi_char = hmi_get_last_value_char(phmi_temp_string,hmi_string_temp_index,&hmi_text_offset); hmi_string_temp_index -= hmi_text_offset; phmi_font_config = hmi_driver_get_char_data(hmi_char, phmi_font_table, phmi_text_prop_info->font_id); if(phmi_font_config != 0U) { #if HMI_SCROLL_TEXT_SUPPORT != 0U  if(hmi_scroll_offset_temp >=(phmi_font_config->owidth+HMI_CHAR_SPACE)) { hmi_scroll_offset_temp -= (phmi_font_config->owidth+HMI_CHAR_SPACE); } else #endif { #if HMI_SCROLL_TEXT_SUPPORT != 0U  if(hmi_text_width == 0U) { hmi_text_width =(HMI_WIDTH_STR)(phmi_font_config->owidth-hmi_scroll_offset_temp)+HMI_CHAR_SPACE; hmi_scroll_offset_temp = 0; } else #endif { hmi_text_width += phmi_font_config->owidth+HMI_CHAR_SPACE; } #ifdef HMI_CLIP_TEXT if((!hmi_ct_width_flag)&& ((phmi_text_prop_info->properties & HMI_TEXT_PROP_SCROLABLE) == 0)) { if(hmi_extend_text_width == hmi_extend_text_len) { hmi_extend_text_width += hmi_text_width; } else { hmi_extend_text_width += phmi_font_config->owidth+HMI_CHAR_SPACE; }  if(hmi_extend_text_width == hmi_text_width_temp) { hmi_extend_text_index = hmi_string_temp_index; hmi_ct_width_flag = TRUE; } else if(hmi_extend_text_width > hmi_text_width_temp) { hmi_extend_text_index = hmi_string_temp_index+1U; hmi_extend_text_index += hmi_text_offset; hmi_extend_text_width -= (phmi_font_config->owidth+HMI_CHAR_SPACE); hmi_ct_width_flag = TRUE; } else { } } #endif if(hmi_text_width == hmi_text_width_temp) { /*add 130627*/ hmi_string_index = hmi_string_temp_index; break; } else if(hmi_text_width > hmi_text_width_temp) { #ifdef HMI_CLIP_TEXT if((phmi_text_prop_info->properties & HMI_TEXT_PROP_SCROLABLE) == 0) { hmi_text_default_flag = TRUE; } #endif #if (HMI_SCROLL_TEXT_SUPPORT != 0U) || (HMI_DRAW_BITMAP_CLIP_SUPPORT != 0U) if(HMI_TEXT_PROP_IS_CLIP_NORMAL(phmi_text_prop_info->properties)) { hmi_scroll_offset = (hmi_text_width-hmi_text_width_temp); hmi_text_width = hmi_text_width_temp; hmi_string_index = hmi_string_temp_index; } else #endif { hmi_string_index = hmi_string_temp_index+1U; hmi_string_index = hmi_string_temp_index+hmi_text_offset; hmi_text_width -= (phmi_font_config->owidth+HMI_CHAR_SPACE); } break; } else { } } } } #ifdef HMI_CLIP_TEXT if(((&phmi_disp_string[hmi_string_temp_index] > phmi_temp_string) &&((phmi_text_prop_info->properties & HMI_TEXT_PROP_SCROLABLE) == 0)) ||(hmi_text_default_flag == TRUE)) { if(hmi_extend_text_width > hmi_extend_text_len) { hmi_text_default_flag = TRUE; hmi_text_width = hmi_extend_text_width; hmi_string_index = hmi_extend_text_index; } else { hmi_text_default_flag = FALSE; hmi_text_width = 0U; } } #endif if(hmi_text_width > 0U) { hmi_text_width_temp = hmi_text_width; hmi_text_width_temp--; hmi_copy_start_x -= hmi_text_width_temp; #if 0//changed by pxguo 160304 if(hmi_copy_start_x > hmi_text_width_temp) {  hmi_copy_start_x -=hmi_text_width_temp;  }  else  {  hmi_copy_start_x =0U;  }  #endif #ifdef HMI_CLIP_TEXT if(hmi_text_default_flag == TRUE) { hmi_extext_copy_start_x = hmi_copy_start_x; hmi_copy_start_x += hmi_extend_text_len; } #endif } } else { while(phmi_temp_string[hmi_string_temp_index] != 0U) { hmi_text_offset = 0U; hmi_char = hmi_get_value_char(phmi_temp_string[hmi_string_temp_index], phmi_temp_string[hmi_string_temp_index+1], &hmi_text_offset); phmi_font_config= hmi_driver_get_char_data(hmi_char,phmi_font_table, phmi_text_prop_info->font_id); if(phmi_font_config != 0U) { #if HMI_SCROLL_TEXT_SUPPORT != 0U  if(hmi_scroll_offset_temp >= (phmi_font_config->owidth+HMI_CHAR_SPACE)) { hmi_scroll_offset_temp -= (phmi_font_config->owidth+HMI_CHAR_SPACE); } else #endif { #if HMI_SCROLL_TEXT_SUPPORT != 0U  if(hmi_text_width == 0U) { hmi_string_index = hmi_string_temp_index; hmi_text_width = (HMI_WIDTH_STR)(phmi_font_config->owidth+HMI_CHAR_SPACE-hmi_scroll_offset_temp); hmi_scroll_offset = hmi_scroll_offset_temp; hmi_scroll_offset_temp = 0; } else #endif { hmi_text_width += phmi_font_config->owidth+HMI_CHAR_SPACE; } #ifdef HMI_CLIP_TEXT if((!hmi_ct_width_flag)&& ((phmi_text_prop_info->properties & HMI_TEXT_PROP_SCROLABLE) == 0)) { if(hmi_extend_text_width == hmi_extend_text_len) { hmi_extend_text_width += hmi_text_width; } else  { hmi_extend_text_width += phmi_font_config->owidth+HMI_CHAR_SPACE; } if(hmi_extend_text_width == hmi_text_width_temp) { hmi_ct_width_flag = TRUE; } else if(hmi_extend_text_width > hmi_text_width_temp) { hmi_extend_text_width -= (phmi_font_config->owidth+HMI_CHAR_SPACE); hmi_ct_width_flag = TRUE; } else { } } #endif if(hmi_text_width == hmi_text_width_temp) { hmi_string_temp_index += 1U;//add hmi_string_temp_index += hmi_text_offset;//add break; } else if(hmi_text_width > hmi_text_width_temp) { #ifdef HMI_CLIP_TEXT if(((phmi_text_prop_info->properties & HMI_TEXT_PROP_SCROLABLE) == 0) &&(HMI_TEXT_PROP_ALIGN_IS_LEFT(phmi_text_prop_info->properties))) { hmi_text_default_flag = TRUE; } #endif #if (HMI_DRAW_BITMAP_CLIP_SUPPORT != 0U)  if(HMI_TEXT_PROP_IS_CLIP_NORMAL(phmi_text_prop_info->properties)) { hmi_text_width = hmi_text_width_temp; } else #endif { hmi_text_width -= (phmi_font_config->owidth+HMI_CHAR_SPACE); } break; } else { } } } hmi_string_temp_index += 1U; hmi_string_temp_index += hmi_text_offset; }  #ifdef HMI_CLIP_TEXT if(((phmi_temp_string[hmi_string_temp_index] != 0U) &&((phmi_text_prop_info->properties & HMI_TEXT_PROP_SCROLABLE) == 0) &&(HMI_TEXT_PROP_ALIGN_IS_LEFT(phmi_text_prop_info->properties))) ||(hmi_text_default_flag == TRUE)) { if(hmi_extend_text_width > hmi_extend_text_len) { hmi_text_default_flag = TRUE; hmi_text_width = hmi_extend_text_width; } else { hmi_text_default_flag = FALSE; hmi_text_width = 0U; } } #endif if(HMI_TEXT_PROP_ALIGN_IS_CENTRE(phmi_text_prop_info->properties)) { hmi_text_width_temp = (hmi_text_width>>1); hmi_copy_start_x -= hmi_text_width_temp; #if 0//changed by pxguo 160304 if(hmi_copy_start_x>hmi_text_width_temp) {  hmi_copy_start_x -=hmi_text_width_temp;  }  else  {  hmi_copy_start_x =0U;  }  #endif } }  if(HMI_TEXT_PROP_IS_DRAW_REVERSE(phmi_text_prop_info->properties)) { HMI_FILL_PAGE_STR hmi_fill_page_prop = {0U};  hmi_fill_page_prop.color= phmi_text_copy_rect->color; call_C_hmi_driver_draw_fill_page(&hmi_fill_page_prop,  pclip_rect, pdirty_rect, layer #ifdef HMI_GRAPHIC_RGL ,father_alpha #endif ); hmi_text_color = (HMI_WHITE_COLOR_ARGB-phmi_text_copy_rect->color); } else { hmi_text_color = phmi_text_copy_rect->color; } //add #ifdef HMI_CLIP_TEXT if(hmi_text_default_flag == TRUE) { if(hmi_text_width > hmi_extend_text_len) { hmi_text_default_flag = TRUE; hmi_text_width -= hmi_extend_text_len; } else { hmi_text_default_flag = FALSE; hmi_text_width = 0U; } } #endif  while((phmi_disp_string[hmi_string_index]!= 0U)&&(hmi_text_width>0U)) { hmi_text_offset = 0U; hmi_char = hmi_get_value_char(phmi_disp_string[hmi_string_index],phmi_disp_string[hmi_string_index+1],&hmi_text_offset); phmi_font_config = hmi_driver_get_char_data(hmi_char, phmi_font_table, phmi_text_prop_info->font_id); if(phmi_font_config != 0U) { /*when extend text,no clip*/ #ifdef HMI_CLIP_TEXT if((hmi_text_default_flag == TRUE)) { if(hmi_text_width < (phmi_font_config->owidth+HMI_CHAR_SPACE)) { hmi_text_width = 0U; } } #endif if(hmi_text_width != 0U) { hmi_current_y = (hmi_copy_start_y + phmi_font_config->y_soffset); #if (HMI_SCROLL_TEXT_SUPPORT!= 0U)||(HMI_DRAW_BITMAP_CLIP_SUPPORT!= 0U)  hmi_text_width_temp = phmi_font_config->owidth+HMI_CHAR_SPACE; hmi_text_width_temp -= hmi_scroll_offset; if(hmi_text_width >= hmi_text_width_temp) { hmi_text_width -= hmi_text_width_temp; } else { hmi_text_width_temp = hmi_text_width; hmi_scroll_offset = 0; hmi_text_width = 0U; } hmi_current_x = hmi_copy_start_x; hmi_copy_start_x += hmi_text_width_temp;  if(hmi_text_width_temp == (phmi_font_config->owidth+HMI_CHAR_SPACE)) { hmi_current_x += phmi_font_config->x_soffset; hmi_text_width_temp = phmi_font_config->w; } else { if(hmi_scroll_offset < phmi_font_config->x_soffset) { hmi_scroll_offset = (phmi_font_config->x_soffset-hmi_scroll_offset); if(hmi_text_width_temp > hmi_scroll_offset) { hmi_text_width_temp-= hmi_scroll_offset; hmi_current_x += hmi_scroll_offset; hmi_scroll_offset = 0; if(hmi_text_width_temp > phmi_font_config->w) { hmi_text_width_temp = phmi_font_config->w; } } else { hmi_text_width_temp = 0U; } } else { hmi_scroll_offset -= phmi_font_config->x_soffset; if((hmi_text_width_temp+hmi_scroll_offset) > phmi_font_config->w) { hmi_text_width_temp = (HMI_WIDTH_STR)(phmi_font_config->w-hmi_scroll_offset); } } } text_copy_rect.x = hmi_current_x-hmi_scroll_offset; text_copy_rect.y = hmi_current_y; text_copy_rect.w = phmi_font_config->w; text_copy_rect.h = phmi_font_config->h; text_data.w = phmi_font_config->w; text_data.h = phmi_font_config->h; text_data.pbitmap_data = phmi_font_config->char_data; text_clip_rect.x = hmi_current_x; text_clip_rect.y = hmi_current_y; text_clip_rect.w = hmi_text_width_temp; text_clip_rect.h = phmi_font_config->h; hmi_get_union_rect(&text_clip_rect,pclip_rect,&copy_rect); if(hmi_text_color != 0U) { if(HMI_TEXT_PROP_IS_DRAW_TRANSP(phmi_text_prop_info->properties)) { hmi_driver_copy_image(&text_copy_rect, &text_data, font_format, hmi_text_color, &copy_rect, pdirty_rect, TRUE, layer #ifdef HMI_GRAPHIC_RGL ,father_alpha ,font_id ,hmi_char #endif ); } else { hmi_driver_copy_image(&text_copy_rect, &text_data, font_format, hmi_text_color, &copy_rect, pdirty_rect, FALSE, layer #ifdef HMI_GRAPHIC_RGL ,father_alpha ,font_id ,hmi_char #endif ); } } else { } hmi_scroll_offset=0; #else hmi_copy_start_x += phmi_font_config->x_soffset; text_copy_rect.x = hmi_copy_start_x; text_copy_rect.y = hmi_current_y; text_copy_rect.w = phmi_font_config->w; text_copy_rect.h = phmi_font_config->h; text_data.w = phmi_font_config->w; text_data.h = phmi_font_config->h; text_data.pbitmap_data = phmi_font_config->char_data; if(hmi_text_color != 0U) { if(HMI_TEXT_PROP_IS_DRAW_TRANSP(phmi_text_prop_info->properties)) { hmi_driver_copy_image(&text_copy_rect, &text_data, font_format, hmi_text_color, pclip_rect, pdirty_rect, TRUE, layer #ifdef HMI_GRAPHIC_RGL ,father_alpha ,font_id ,hmi_char #endif ); } else { hmi_driver_copy_image(&text_copy_rect, &text_data, font_format, hmi_text_color, pclip_rect, pdirty_rect, FALSE, layer #ifdef HMI_GRAPHIC_RGL ,father_alpha ,font_id ,hmi_char #endif ); } } else { } hmi_copy_start_x += phmi_font_config->x_eoffset; if(hmi_text_width >= (phmi_font_config->owidth+HMI_CHAR_SPACE)) { hmi_text_width -= (phmi_font_config->owidth+HMI_CHAR_SPACE); } else { hmi_text_width = 0U; } #endif } } hmi_string_index++; hmi_string_index += hmi_text_offset; } }  #ifdef HMI_CLIP_TEXT if(hmi_text_default_flag == TRUE) { index = 0U; if(HMI_TEXT_PROP_ALIGN_IS_RIGHT(phmi_text_prop_info->properties)) { hmi_copy_start_x = hmi_extext_copy_start_x; } while(phmi_clip_char[index] != 0U) { hmi_text_offset = 0U; hmi_char = hmi_get_value_char(phmi_clip_char[index], phmi_clip_char[index+1], &hmi_text_offset); phmi_font_config= hmi_driver_get_char_data(hmi_char, phmi_font_table,  phmi_text_prop_info->font_id); if(phmi_font_config != 0U) { hmi_current_y = (hmi_copy_start_y + phmi_font_config->y_soffset); hmi_copy_start_x += phmi_font_config->x_soffset; text_copy_rect.x = hmi_copy_start_x-hmi_scroll_offset; text_copy_rect.y = hmi_current_y; text_copy_rect.w = phmi_font_config->w; text_copy_rect.h = phmi_font_config->h; text_data.w = phmi_font_config->w; text_data.h = phmi_font_config->h; text_data.pbitmap_data = phmi_font_config->char_data; text_clip_rect.x = hmi_copy_start_x; text_clip_rect.y = hmi_current_y; text_clip_rect.w = hmi_text_width_temp; text_clip_rect.h = phmi_font_config->h; hmi_get_union_rect(&text_clip_rect,pclip_rect,&copy_rect); if(hmi_text_color != 0U) { if(HMI_TEXT_PROP_IS_DRAW_TRANSP(phmi_text_prop_info->properties)) { hmi_driver_copy_image(&text_copy_rect, &text_data, font_format, hmi_text_color, pclip_rect, pdirty_rect, TRUE, layer #ifdef HMI_GRAPHIC_RGL ,father_alpha ,font_id ,hmi_char #endif ); } else { hmi_driver_copy_image(&text_copy_rect, &text_data, font_format, hmi_text_color, &copy_rect, pdirty_rect, FALSE, layer #ifdef HMI_GRAPHIC_RGL ,father_alpha ,font_id ,hmi_char #endif ); } } else { } hmi_copy_start_x += phmi_font_config->x_eoffset; } index += hmi_text_offset; index++; } } #endif /*judge scroll step*/ /*add by pxguo 130627*/ #if HMI_SCROLL_TEXT_SUPPORT!=0U if((phmi_text_prop_info->properties&HMI_TEXT_PROP_SCROLABLE) != 0U) { hmi_string_temp_index = 0U; while(phmi_temp_string[hmi_string_temp_index] != 0U) { hmi_text_offset = 0U; hmi_char = hmi_get_value_char(phmi_temp_string[hmi_string_temp_index], phmi_temp_string[hmi_string_temp_index+1], &hmi_text_offset); phmi_font_config = hmi_driver_get_char_data(hmi_char, phmi_font_table, phmi_text_prop_info->font_id); if(phmi_font_config != 0U) { #if HMI_SCROLL_TEXT_SUPPORT != 0U /*get text real length*/ hmi_text_real_width += phmi_font_config->owidth+HMI_CHAR_SPACE; #endif } hmi_string_temp_index += 1U; hmi_string_temp_index += hmi_text_offset; } if(hmi_modify_scroll_offset < 0) { hmi_modify_scroll_offset = -hmi_modify_scroll_offset; } if(hmi_modify_scroll_offset >= hmi_text_real_width) {  #if HMI_FONT_CODE == HMI_FONT_CODE_UNICODE//pxguo phmi_temp_string[phmi_text_prop_info->length+1] = 0U; #else phmi_temp_string[phmi_text_prop_info->length+1] = 0U; phmi_temp_string[phmi_text_prop_info->length+2] = 0U; #endif  } } #endif } R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); loc_IncMsgCount(HMI_LOC_VOVIAL_UNIT);  } } #endif #endif /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: fill rect with a color */ void call_C_hmi_driver_draw_fill_page( HMI_FILL_PAGE_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml phmi_fill_page_prop, HMI_RECT_STR *pclip_rect, HMI_RECT_STR *pdirty_rect, UINT8 layer #ifdef HMI_GRAPHIC_RGL ,UINT8 father_alpha #endif ) { r_drw2d_Error_t ret = R_DRW2D_ERR_OK; r_drw2d_Color_t Color = 0; r_drw2d_Rect_t rect = {{0,0},{0,0}}; void* setlocSurface = NULL;  UINT8 image_alpha = 0; HMI_RECT_STR hmi_disp_target = {0,0,0,0}; r_drw2d_IntRect_t clip_rect = {{0,0},{0,0}}; UINT8 clip_index = 0; UINT8 next_clip_index = 0; HMI_RECT_STR hmi_min_dirty_rect = {0,0,0,0}; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr rect */ if((pclip_rect != NULL)&&(phmi_fill_page_prop != NULL)&&(pdirty_rect != NULL))  {  hmi_disp_target.x = pclip_rect->x; hmi_disp_target.y = pclip_rect->y;  hmi_disp_target.w = pclip_rect->w; hmi_disp_target.h = pclip_rect->h; /*convert screen coordinate to layer coordinate*/ hmi_disp_target.x -= locSurface_rect[layer].x; hmi_disp_target.y -= locSurface_rect[layer].y; /*reset status*/ #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret |= R_DRW2D_CtxImgQuality(HMI_LOC_DRW2D_DEV, R_DRW2D_IMGQUALITY_MEDIUM);  #endif //ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV);  ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TRANSFORM_2D); ret |= R_DRW2D_CtxTextureTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TEX_TRANSFORM_2D);  /*get framebuffer*/  setlocSurface = hmi_get_window(layer); locGetRenderTarget(setlocSurface); /*Blend mode*/ #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV,R_DRW2D_BLENDMODE_CUSTOM);  ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV, R_DRW2D_BLEND_SRC_ALPHA, R_DRW2D_BLEND_ONE_MINUS_SRC_ALPHA, R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE  ); #else ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV,R_DRW2D_BLENDMODE_SRC); #endif /*Fill mode*/ ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_SOLID);  Color = phmi_fill_page_prop->color;/*RGL ARGB32*/ image_alpha = HMI_RGL_ALLPHA(Color); if(father_alpha < image_alpha) { image_alpha = father_alpha; } Color = HMI_RGL_SET_ALPHA(image_alpha,Color); ret |= R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, Color); convertRect2RectRGL(&hmi_disp_target,&rect,TRUE/*fix point*/); next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_DrawRect(HMI_LOC_DRW2D_DEV, (CONST r_drw2d_Rect_t *)(&rect)); } clip_index++; next_clip_index ++; }  if (R_DRW2D_ERR_OK != ret) { loc_Error_hmi(ret); }  loc_IncMsgCount(HMI_LOC_VOVIAL_UNIT);  } }  void call_C_hmi_driver_gradient_fill_page(HMI_RECT_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml phmi_gfill_page_rect, HMI_GRADIENT_FILL_STR CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml phmi_gfill_page_prop, HMI_RECT_STR *pclip_rect #ifdef HMI_GRAPHIC_RGL ,UINT8 father_alpha #endif ) { }  void set_alpha_effect(BYTE alpha) { c_alpha = R_DRW2D_2X(alpha/255.0f);  op0 = R_DRW2D_EFFECT_COLOR_OPERAND_RGBA; effect_stages[0].Name = R_DRW2D_EFFECT_REPLACE; effect_stages[0].Args[0].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[0].Args[0].Param.Color.Source.TextureUnit = 0; effect_stages[0].Args[0].Param.Color.Operand = op0; effect_stages[1].Name = R_DRW2D_EFFECT_CONSTANT_ALPHA; effect_stages[1].Args[0].Source = R_DRW2D_EFFECT_SOURCE_CONSTANT; effect_stages[1].Args[0].Param.Constant = c_alpha;  R_DRW2D_CtxEffectsSet(HMI_LOC_DRW2D_DEV, effect_stages, 2); }  #if 0 BOOLEAN is_jpg_compress(HMI_IMAGE_ATTR_STR img_attr) { BOOLEAN bmp_jpg_compress = FALSE; UINT8 bmp_compress = 0;  bmp_compress = (img_attr.image_attr)&0x0f; if(bmp_compress == HMI_IMAGE_COMPRESS_JPG) { bmp_jpg_compress = TRUE; }  return bmp_jpg_compress; } #endif  rgl_image_type_str get_compress_fmt(HMI_IMAGE_ATTR_STR img_attr) { UINT8 bmp_compress = 0; rgl_image_type_str image_type = HMI_IMAGE_NO_COMPRESS; bmp_compress = (img_attr.image_attr)&0x0f; switch(bmp_compress) { case HMI_IMAGE_COMPRESS_NONE: image_type = HMI_IMAGE_NO_COMPRESS; break; case HMI_IMAGE_COMPRESS_NO_LOSS: image_type = HMI_IMAGE_RLE; break; case HMI_IMAGE_COMPRESS_LOSSY: image_type = HMI_IMAGE_RLE; break; case HMI_IMAGE_COMPRESS_JPG: image_type = HMI_IMAGE_JPG; break; default: image_type = HMI_IMAGE_NO_COMPRESS; } return image_type; }  #if 0 r_drw2d_PixelFormat_t get_texture_color_fmt(HMI_IMAGE_ATTR_STR img_attr) { r_drw2d_PixelFormat_t PixelFormat = R_DRW2D_PIXELFORMAT_RGBA8888; UINT8 alpha = 0;  UINT8 color_format= 0;  color_format = HMI_PIX_FORMAT; alpha = (((img_attr.image_attr)&0xf0)>>4);  switch(color_format) { case HMI_RGB565: case HMI_BGR565: PixelFormat = R_DRW2D_PIXELFORMAT_RGB565; break;  case HMI_RGB555: case HMI_BGR555:/*rgba5551*/  PixelFormat = R_DRW2D_PIXELFORMAT_RGBA5551;;  break;  case HMI_RGB888: case HMI_BGR888: PixelFormat = R_DRW2D_PIXELFORMAT_RGBA8888;  break;  default: ; }  return PixelFormat; } #endif  #if 0 uint8_t get_color_dep(r_drw2d_PixelFormat_t color_fmt) { uint8_t color_dep = 0;  switch(color_fmt) { case R_DRW2D_PIXELFORMAT_RGB565: case R_DRW2D_PIXELFORMAT_ARGB1555: case R_DRW2D_PIXELFORMAT_RGBA5551: color_dep = 2; break; case R_DRW2D_PIXELFORMAT_ARGB8888: case R_DRW2D_PIXELFORMAT_RGBA8888: color_dep = 4; break;  default: color_dep = 4;  }  return color_dep; } #endif #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) BOOLEAN jpeg_decode_buffer(void *src, void* pdraw_date,HMI_WIDTH_STR w,HMI_HEIGHT_STR h)  { r_jcua_Error_t error = R_JCUA_ERR_OK; r_jcua_FrameBuffer_t frame_buffer = {0}; r_jcua_DecodeSetting_t option = {0}; BOOLEAN decode_success =FALSE; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Setup frame buffer information. */ frame_buffer.Address= pdraw_date; frame_buffer.Size = HMI_STRIDE(w*hmi_bpp)*h;//HMI_STRIDE(w)*HMI_STRIDE_8(h)*hmi_bpp/*4 lq modify*/; frame_buffer.Stride = HMI_STRIDE(w*hmi_bpp);//HMI_STRIDE(w)*hmi_bpp/*4 lq modify*/;//?? lq review align ? frame_buffer.Format = R_JCUA_OUTPUT_FORMAT_ARGB8888; #if 1 if(HMI_LOC_VOVIAL_FORMAT==HMI_QD_ARGB8888) { frame_buffer.Format = R_JCUA_OUTPUT_FORMAT_ARGB8888; } else { frame_buffer.Format = R_JCUA_OUTPUT_FORMAT_RGB565; } #endif frame_buffer.Swap = R_JCUA_SWAP_LONG; option.OptionFlag = R_JCUA_DECODE_OPTION_NONE; option.ImgInfo = R_NULL; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Start JPEG decode.*/ loc_CallbackReached = 0;   error = R_JCUA_DecoderStart(LOC_JCUA_UNIT,  src,/*ptexture_jpg->Buffer.Data,*/  &frame_buffer,  &option); if (R_JCUA_ERR_OK == error) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Waite decode complete. */ while (loc_CallbackReached == 0)  { };  } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Close the decoder. */ //error = R_JCUA_DecoderClose(LOC_JCUA_UNIT);//removed by pxguo 160906 }  if (R_JCUA_ERR_OK != error) { hmi_qd_error_handler(HMI_RGL_DRW2D_DECODE_JPG_ERROR); decode_success =FALSE; } else { decode_success =TRUE; } loc_IncMsgCount(HMI_LOC_VOVIAL_UNIT);  return decode_success; } #endif  /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: SetSFMAConfig  Fills the flash device config and command structure according to the target device. */ #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) void decode_JPG2Mem(r_drw2d_Texture_t *ptexture_jpg,U08 layer, HMI_RECT_ALPHA_ANGEL_STR *palpha_pos_angel, HMI_RECT_STR disp_rect) { void* setlocSurface = NULL; BOOLEAN blur_alloc = FALSE; UINT8 hmi_blur_flag = 0; UINT32 jpg_size = 0; BOOLEAN decode_success = FALSE; r_drw2d_Error_t ret = R_DRW2D_ERR_OK;  r_drw2d_Rect_t dst_rect = {{0,0},{0,0}}; r_drw2d_Rect_t src_rect = {{0,0},{0,0}}; r_drw2d_IntRect_t clip_rect = {{0,0},{0,0}}; UINT8 hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml phmi_layer_buffer=NULL; r_drw2d_Framebuffer_t fb = {0}; hmi_qd_fbformat_t fmt = HMI_LOC_VOVIAL_FORMAT;  /*set window*/  setlocSurface = hmi_get_window(layer); phmi_layer_buffer=(UINT8 *)(locGetRenderTarget(setlocSurface)); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Init framebuffer struct */ if((disp_rect.x != 0) || (disp_rect.y != 0)) { hmi_qd_getbufferinfo(setlocSurface, &fmt, &fb.Buffer.Pitch,  &fb.Buffer.Size.Width,  &fb.Buffer.Size.Height); if(phmi_layer_buffer !=NULL) { phmi_layer_buffer +=((((fb.Buffer.Pitch)*(disp_rect.y))+(disp_rect.x))*hmi_bpp); } disp_rect.w =disp_rect.x+ptexture_jpg->Buffer.Size.Width; disp_rect.h =disp_rect.y+ptexture_jpg->Buffer.Size.Height; } if((ptexture_jpg->Buffer.Data!= NULL)&& (ptexture_jpg->Buffer.Size.Width!= 0)&& (ptexture_jpg->Buffer.Size.Height!= 0)&& (layer < HMI_LAYER_MAX_CNT)&& (disp_rect.w <= locSurface_rect[layer].w)&& (disp_rect.h <= locSurface_rect[layer].h)) {  hmi_blur_flag=palpha_pos_angel->attr&HMI_BLUR_FLAG; if(hmi_blur_flag !=0) { blur_alloc=hmi_alloc_blur_buffer(ptexture_jpg); /*alloc buffer and decode to buffer */ if(blur_alloc) { if((hmi_jpg_blur_buffer.Buffer.Size.Width!=ptexture_jpg->Buffer.Size.Width)|| (hmi_jpg_blur_buffer.Buffer.Size.Height!=ptexture_jpg->Buffer.Size.Height)) { if(hmi_jpg_blur_buffer.Buffer.Data!=NULL) { R_CDI_Free((uint32_t)(hmi_jpg_blur_buffer.Buffer.Data),HMI_LOC_VRAM_HEAP); hmi_jpg_blur_buffer.Buffer.Data = NULL; } hmi_jpg_blur_buffer.Flags = (r_drw2d_FramebufferFlags_t)R_DRW2D_TEX_BILINEAR; hmi_jpg_blur_buffer.Handle = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr not used currently */ hmi_jpg_blur_buffer.Buffer = ptexture_jpg->Buffer; hmi_jpg_blur_buffer.Buffer.Pitch = hmi_jpg_blur_buffer.Buffer.Size.Width; jpg_size = HMI_STRIDE(hmi_bpp*hmi_jpg_blur_buffer.Buffer.Size.Width)* hmi_jpg_blur_buffer.Buffer.Size.Height; hmi_jpg_blur_buffer.Buffer.Data = R_CDI_Alloc(HMI_LOC_VRAM_HEAP, jpg_size); if((hmi_jpg_blur_buffer.Buffer.Data)!=NULL)  { decode_success=jpeg_decode_buffer(ptexture_jpg->Buffer.Data, hmi_jpg_blur_buffer.Buffer.Data, hmi_jpg_blur_buffer.Buffer.Size.Width, hmi_jpg_blur_buffer.Buffer.Size.Height); } } } /*blur and draw to layer buffer */ if(decode_success) {  R_DRW2D_CtxConvolutionKernelPreset2d(HMI_LOC_DRW2D_DEV, R_DRW2D_CONV2D_GAUSSIAN_BLUR_5x5); R_DRW2D_CtxStripingEnable(HMI_LOC_DRW2D_DEV); Blur_Buffer(&hmi_jpg_blur_buffer.Buffer,&hmi_blur_buffer.Buffer); ptexture_jpg->Flags |=R_DRW2D_TEX_BILINEAR; ptexture_jpg->Buffer.Data=hmi_blur_buffer.Buffer.Data; /*set window*/  //setlocSurface = hmi_get_window(layer); //locGetRenderTarget(setlocSurface); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Identity and Set texture */ //ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV);  ret |= R_DRW2D_CtxTextureTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TEX_TRANSFORM_2D); ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_CUSTOM);  ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV, R_DRW2D_BLEND_SRC_ALPHA, R_DRW2D_BLEND_ONE_MINUS_SRC_ALPHA, R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE  ); ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE); ret |= R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0, ptexture_jpg); /*Texture position*/ src_rect.Pos.X = R_DRW2D_2X(0);  src_rect.Pos.Y = R_DRW2D_2X(0); src_rect.Size.Width = R_DRW2D_2X(ptexture_jpg->Buffer.Size.Width); src_rect.Size.Height= R_DRW2D_2X(ptexture_jpg->Buffer.Size.Height);/*Clip position*/ clip_rect.Pos.X =0;  clip_rect.Pos.Y =0; clip_rect.Size.Width = ptexture_jpg->Buffer.Size.Width; clip_rect.Size.Height = ptexture_jpg->Buffer.Size.Height;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); /*Screen position*/  dst_rect.Pos.X = R_DRW2D_2X(0); dst_rect.Pos.Y = R_DRW2D_2X(0); dst_rect.Size.Width = R_DRW2D_2X(ptexture_jpg->Buffer.Size.Width); dst_rect.Size.Height= R_DRW2D_2X(ptexture_jpg->Buffer.Size.Height); ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV, &src_rect,&dst_rect);  ret |= R_DRW2D_CtxStripingDisable(HMI_LOC_DRW2D_DEV); } else {  decode_success=jpeg_decode_buffer(ptexture_jpg->Buffer.Data, phmi_layer_buffer, locSurface_rect[layer].w, locSurface_rect[layer].h);   } } else #if 1 { decode_success=jpeg_decode_buffer(ptexture_jpg->Buffer.Data, phmi_layer_buffer, locSurface_rect[layer].w, locSurface_rect[layer].h);  } #endif }  } #endif  /* x0=xcosA-ysinA y0=xsinA+ycosA */ #if 0 void getRotated2DPoint(SPOINT_TP *pcenter,HMI_ROTATION_STR *protationPoint,SPOINT_TP *pnewCenter,float_32 angel) { float_32 x=0; float_32 y=0; float_32 x0=0; float_32 y0=0; float_32 cos0=0; float_32 sin0=0; r_drw2d_FixedP_t r_angel=0; float_32 f_angel=0; #if 1 r_drw2d_FixedP_t cosA=0; r_drw2d_FixedP_t sinA=0; #endif float_32 cosA_f=0; float_32 sinA_f=0; SINT16 new_x_origin=0; SINT16 new_y_origin=0; SINT16 angel_sint=0;  if((pnewCenter!=NULL)&&(pcenter!=NULL)&&(protationPoint!=NULL)) { x=pcenter->x-protationPoint->x; y=pcenter->y-protationPoint->y; new_x_origin=0-protationPoint->x; new_y_origin=0-protationPoint->y; f_angel=(angel*HMI_PI)/180.0; cosA_f=cosf(f_angel); sinA_f=sinf(f_angel); x0=x*cosA_f-y*sinA_f; y0=x*sinA_f+y*cosA_f;  x0=x0-new_x_origin; y0=y0-new_y_origin;   pnewCenter->x=x0; pnewCenter->y=y0;  } } #endif void locCleanUpVRAM_hmi(void) { #if 0 int32_t i = 0;  for(i = 0; i < LOC_VRAM_IMAGE_COUNT; ++i) { if(locAllocedVRAM[i] != NULL) { R_CDI_Free((uint32_t)locAllocedVRAM[i], &HMI_LOC_VRAM_HEAP); locAllocedVRAM[i] = NULL; } } #endif }   /*added by pxguo*/ void hmi_MoveSprite(hmi_qd_Sprite_t *image_sprite, uint32_t PosX, uint32_t PosY, uint32_t PosZ) { hmi_qd_movesprite(image_sprite, PosX, PosY, PosZ); } #if USE_V2_HMI_SDK  void hmi_draw_SpriteSurface(void hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml pbuffer, HMI_X_STR x,  HMI_Y_STR y,  HMI_WIDTH_STR w, HMI_HEIGHT_STR h, UINT8 layer, HMI_OBJECT_ID_STR hmi_object_id, HMI_RECT_STR sprite_rect, HMI_RECT_ALPHA_ANGEL_STR *palpha_pos_angel,  UINT8 father_alpha ) { hmi_qd_Sprite_t *pimage_sprite = NULL; void* setlocSurface = NULL;  r_drw2d_IntRect_t clip_rect = {0}; UINT8 image_alpha = 0;  UINT8 sprite_index = HMI_MAX_SPRITE_NB; UINT8 sprite_free_index = HMI_MAX_SPRITE_NB; UINT8 sprite_layer = 0; UINT8 index = 0; BOOLEAN search_success = FALSE;  setlocSurface = hmi_get_window(layer); /*Clip position*/ clip_rect.Pos.X = sprite_rect.x;  clip_rect.Pos.Y = sprite_rect.y; clip_rect.Size.Width = sprite_rect.w; clip_rect.Size.Height = sprite_rect.h;  R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); sprite_layer = layer - 1;  if((NULL != pbuffer)&&(setlocSurface != NULL)&&(sprite_layer < HMI_MAX_SPRITE_LAYER)) { /*global angel*/  if(father_alpha > palpha_pos_angel->alpha) { image_alpha = palpha_pos_angel->alpha; } else { image_alpha = father_alpha; } if(image_alpha != HMI_OPAQUE) { set_alpha_effect(image_alpha);  }  while((index < HMI_MAX_SPRITE_NB)&&(search_success == FALSE)) {  if(hmi_sprite_list[sprite_layer][index].sprite_id == hmi_object_id) { sprite_index = index; search_success = TRUE; } else if(hmi_sprite_list[sprite_layer][index].hmi_sprite.Data == NULL) {  sprite_free_index = index;  } else { } index++; } if(search_success == TRUE)  { if(sprite_index < HMI_MAX_SPRITE_NB) { if(hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Data == NULL) { hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Surface = setlocSurface; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Status = HMI_QD_SPRITESTATUS_NOT_INITIALIZED; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Data = (void*)pbuffer; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Width = w; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Height = h; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosX = x; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosY = y; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosZ = 0; hmi_sprite_list[sprite_layer][sprite_index].sprite_id = hmi_object_id; } else { if((hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosX !=x)|| (hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosY != y)) { hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosX = x; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosY = y; pimage_sprite = (&(hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite)); hmi_MoveSprite(pimage_sprite,x,y,0); } if(hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Data !=(void*)pbuffer) { hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Data = (void*)pbuffer; pimage_sprite = (&(hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite)); hmi_qd_setspritebuffer(pimage_sprite,(void*)pbuffer); } } } } else if(search_success == FALSE) { if(sprite_free_index < HMI_MAX_SPRITE_NB)/*priority select free node*/ { hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.Surface = setlocSurface; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.Status = HMI_QD_SPRITESTATUS_NOT_INITIALIZED; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.Data = (void*)pbuffer; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.Width = w; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.Height = h; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.PosX = x; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.PosY = y; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.PosZ = 0; hmi_sprite_list[sprite_layer][sprite_free_index].sprite_id = hmi_object_id; } else { } } else { }  if(search_success == TRUE) { if(sprite_index < HMI_MAX_SPRITE_NB) { hmi_sprite_list[sprite_layer][sprite_index].next_status = HMI_QD_SPRITESTATUS_ENABLED; } } else { if(sprite_free_index < HMI_MAX_SPRITE_NB) { hmi_sprite_list[sprite_layer][sprite_free_index].next_status = HMI_QD_SPRITESTATUS_ENABLED; } }  R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); //R_DRW2D_CtxStripingDisable(HMI_LOC_DRW2D_DEV); }  }  #else void hmi_draw_SpriteSurface(void hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml pbuffer, HMI_X_STR x,  HMI_Y_STR y,  HMI_WIDTH_STR w, HMI_HEIGHT_STR h, UINT8 layer, HMI_OBJECT_ID_STR hmi_object_id, HMI_RECT_STR sprite_rect, HMI_RECT_ALPHA_ANGEL_STR *palpha_pos_angel,  UINT8 father_alpha ) { hmi_qd_Sprite_t *pimage_sprite = NULL; void* setlocSurface = NULL;  r_drw2d_IntRect_t clip_rect = {0}; UINT8 image_alpha = 0;  UINT8 sprite_index = HMI_MAX_SPRITE_NB; UINT8 sprite_free_index = HMI_MAX_SPRITE_NB; UINT8 sprite_disable_index= HMI_MAX_SPRITE_NB; UINT8 sprite_layer = 0; UINT8 index = 0; BOOLEAN search_success = FALSE; BOOLEAN del_sprite = FALSE;  setlocSurface = hmi_get_window(layer); /*Clip position*/ clip_rect.Pos.X = sprite_rect.x;  clip_rect.Pos.Y = sprite_rect.y; clip_rect.Size.Width = sprite_rect.w; clip_rect.Size.Height = sprite_rect.h;  R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); sprite_layer = layer-1;  if((NULL != pbuffer)&&(setlocSurface != NULL)&&(sprite_layer < HMI_MAX_SPRITE_LAYER)) { /*global angel*/  if(father_alpha > palpha_pos_angel->alpha) { image_alpha = palpha_pos_angel->alpha; } else { image_alpha = father_alpha; } if(image_alpha != HMI_OPAQUE) { set_alpha_effect(image_alpha);  }  while((index < HMI_MAX_SPRITE_NB)&&(search_success == FALSE)) {  if(hmi_sprite_list[sprite_layer][index].sprite_id == hmi_object_id) { sprite_index = index; search_success = TRUE; } else if(hmi_sprite_list[sprite_layer][index].hmi_sprite.Data == NULL) {  sprite_free_index = index;  } else if(hmi_sprite_list[sprite_layer][index].next_status == HMI_QD_SPRITESTATUS_DISABLED) {  sprite_disable_index= index;  } else { } index++; } if(search_success == TRUE)  { if(sprite_index < HMI_MAX_SPRITE_NB) { if(hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Data == NULL) { hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Surface = setlocSurface; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Status = HMI_QD_SPRITESTATUS_NOT_INITIALIZED; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Data = (void*)pbuffer; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Width = w; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.Height = h; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosX = x; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosY = y; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosZ = 0; hmi_sprite_list[sprite_layer][sprite_index].sprite_id = hmi_object_id; } else { hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosX = x; hmi_sprite_list[sprite_layer][sprite_index].hmi_sprite.PosY = y; } } } else if(search_success == FALSE) { if(sprite_free_index < HMI_MAX_SPRITE_NB)/*priority select free node*/ { hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.Surface = setlocSurface; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.Status = HMI_QD_SPRITESTATUS_NOT_INITIALIZED; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.Data = (void*)pbuffer; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.Width = w; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.Height = h; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.PosX = x; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.PosY = y; hmi_sprite_list[sprite_layer][sprite_free_index].hmi_sprite.PosZ = 0; hmi_sprite_list[sprite_layer][sprite_free_index].sprite_id = hmi_object_id; } else if(sprite_disable_index < HMI_MAX_SPRITE_NB)/*second select disable node*/ { /*delete the sprite*/ if(hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite.Data != NULL) { hmi_qd_disablesprite(&hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite); hmi_qd_deletesprite(&hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite); hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite.Data = NULL; del_sprite = TRUE; }  /*record another sprite*/ hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite.Surface = setlocSurface; hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite.Status = HMI_QD_SPRITESTATUS_NOT_INITIALIZED; hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite.Data = (void*)pbuffer; hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite.Width = w; hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite.Height = h; hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite.PosX = x; hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite.PosY = y; hmi_sprite_list[sprite_layer][sprite_disable_index].hmi_sprite.PosZ = 0; hmi_sprite_list[sprite_layer][sprite_disable_index].sprite_id = hmi_object_id; } else { } } else { }  if(search_success == TRUE) { if(sprite_index < HMI_MAX_SPRITE_NB) { hmi_sprite_list[sprite_layer][sprite_index].next_status = HMI_QD_SPRITESTATUS_ENABLED; } } else { if(sprite_free_index < HMI_MAX_SPRITE_NB) { hmi_sprite_list[sprite_layer][sprite_free_index].next_status = HMI_QD_SPRITESTATUS_ENABLED; } else if(sprite_disable_index < HMI_MAX_SPRITE_NB) { hmi_sprite_list[sprite_layer][sprite_disable_index].next_status = HMI_QD_SPRITESTATUS_ENABLED; } else { } } if(del_sprite == TRUE)  { hmi_driver_send_cmdlist(); } R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); //R_DRW2D_CtxStripingDisable(HMI_LOC_DRW2D_DEV); }  } #endif void hmi_draw_RLESurface(void* pbuffer,UINT8 layer) { void* setlocSurface = NULL;  setlocSurface = hmi_get_window(layer);  hmi_qd_setbufferaddr(setlocSurface, 1,(void**)(&pbuffer)); hmi_qd_enablesurface(setlocSurface); loc_IncMsgCount(HMI_LOC_VOVIAL_UNIT);  } #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) /*********************************************************** Function: Blur_Texture_Frb */ void Blur_Texture_Frb(r_drw2d_Texture_t *texture_p, r_drw2d_Framebuffer_t *frb_p, uint32_t is_x)  { r_drw2d_Error_t ret = R_DRW2D_ERR_OK; r_drw2d_IntRect_t rect; ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0, texture_p);  ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE); #if 0 ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_SRC_OVER); #else ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_CUSTOM);  ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV, R_DRW2D_BLEND_SRC_ALPHA, R_DRW2D_BLEND_ONE_MINUS_SRC_ALPHA, R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE  ); #endif  rect.Pos.X = 0; rect.Pos.Y = 0; rect.Size.Width = texture_p->Buffer.Size.Width; rect.Size.Height = texture_p->Buffer.Size.Height; #if 1 R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &rect); #endif R_DRW2D_FramebufferSet(HMI_LOC_DRW2D_DEV, frb_p);  R_DRW2D_CtxBgColor(HMI_LOC_DRW2D_DEV, 0x00000000); R_DRW2D_FramebufferClear(HMI_LOC_DRW2D_DEV); R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG); #ifdef R_USE_FASTSOFTDAVE R_UTIL_DHD_FSDRegBuf(frb_p->Buffer.Data, frb_p->Buffer.Pitch hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml frb_p->Buffer.Size.Height hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml 4); #endif if(is_x)  { ret |=R_DRW2D_DrawRectConvolve1dx(HMI_LOC_DRW2D_DEV, &rect, 0,0); }  else  { ret |=R_DRW2D_DrawRectConvolve1dy(HMI_LOC_DRW2D_DEV, &rect, 0,0); } }  /*********************************************************** Function: Blur_Buffer */  void Blur_Buffer(r_drw2d_Buffer_t *src_p, r_drw2d_Buffer_t *dst_p) { r_drw2d_Texture_t texture_blur; r_drw2d_Framebuffer_t frb;  R_DRW2D_CtxStripingEnable(HMI_LOC_DRW2D_DEV); texture_blur.Handle = R_NULL; texture_blur.Flags = R_DRW2D_TEX_VT; texture_blur.Buffer = *src_p;   frb.Handle = R_NULL; frb.Flags = (r_drw2d_FramebufferFlags_t)0;  frb.Buffer = hmi_conv_buf;   Blur_Texture_Frb(&texture_blur,&frb,1); texture_blur.Buffer = hmi_conv_buf;  frb.Buffer = *dst_p; Blur_Texture_Frb(&texture_blur,&frb,0); R_DRW2D_CtxStripingDisable(HMI_LOC_DRW2D_DEV); }   BOOLEAN hmi_alloc_blur_buffer(r_drw2d_Texture_t *ptexture) { UINT32 size = 0; BOOLEAN alloc_success =FALSE; if((hmi_blur_buffer.Buffer.Size.Width!=ptexture->Buffer.Size.Width)|| (hmi_blur_buffer.Buffer.Size.Height!=ptexture->Buffer.Size.Height)|| (hmi_blur_buffer.Buffer.PixelFormat!=ptexture->Buffer.PixelFormat)) { if((hmi_blur_buffer.Buffer.Data)!=NULL) { R_CDI_Free((uint32_t)(hmi_blur_buffer.Buffer.Data),HMI_LOC_VRAM_HEAP); hmi_blur_buffer.Buffer.Data = NULL; } hmi_blur_buffer.Flags = (r_drw2d_FramebufferFlags_t)R_DRW2D_TEX_BILINEAR; hmi_blur_buffer.Handle = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr not used currently */ hmi_blur_buffer.Buffer = ptexture->Buffer; size = hmi_blur_buffer.Buffer.Size.Width* hmi_blur_buffer.Buffer.Size.Height* 4; hmi_blur_buffer.Buffer.Data = R_CDI_Alloc(HMI_LOC_VRAM_HEAP, size); if(hmi_conv_buf.Data!=NULL) { R_CDI_Free((uint32_t)(hmi_conv_buf.Data),HMI_LOC_VRAM_HEAP); hmi_conv_buf.Data = NULL; } hmi_conv_buf = hmi_blur_buffer.Buffer; size = hmi_conv_buf.Size.Width hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_conv_buf.Size.Height hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml 4; hmi_conv_buf.Data = R_CDI_Alloc(HMI_LOC_VRAM_HEAP, size); } if((hmi_blur_buffer.Buffer.Data == NULL)||(hmi_blur_buffer.Buffer.Data == NULL)) { alloc_success = FALSE; } else { alloc_success = TRUE; } return alloc_success;  } /*********************************************************** Function: hmi_scale_blit_Texture */  void hmi_scale_blit_Texture(r_drw2d_Framebuffer_t *pfrb,r_drw2d_Texture_t *ptex ,const r_drw2d_Rect_t *srcRect,const r_drw2d_Rect_t *dstRect) { r_drw2d_IntRect_t clip_rect = {0}; r_drw2d_Error_t ret = R_DRW2D_ERR_OK;   ret |= R_DRW2D_FramebufferSet(HMI_LOC_DRW2D_DEV, pfrb); ret |= R_DRW2D_CtxBgColor(HMI_LOC_DRW2D_DEV, 0x00000000); /*Clip position*/ clip_rect.Pos.X = 0;  clip_rect.Pos.Y = 0; clip_rect.Size.Width= ptex->Buffer.Size.Width; clip_rect.Size.Height= ptex->Buffer.Size.Height;  #if 1 R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); #endif ret |= R_DRW2D_FramebufferClear(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG); ret |= R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, ptex); ret |= R_DRW2D_CtxImgQuality(HMI_LOC_DRW2D_DEV, R_DRW2D_IMGQUALITY_HIGH); ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); //ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV);  ret |= R_DRW2D_CtxTextureTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TEX_TRANSFORM_2D); ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_CUSTOM);  ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV, R_DRW2D_BLEND_SRC_ALPHA, R_DRW2D_BLEND_ONE_MINUS_SRC_ALPHA, R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE  ); ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE);  ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV,srcRect,dstRect); //ret |= R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG);  } #endif  U08 *hmi_Init2DImg(U08 *pdata/*flash data address*/,U32 data_len) { void *p_varm_data = NULL; U08 *p_buffer_data = NULL;  if (pdata != NULL) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr copy image data to video memory HMI_Data/ HMI_Source/ HMI_Tool/  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr check colourformat and calc bpp */ p_varm_data = (void*)R_CDI_Alloc(HMI_LOC_VRAM_HEAP, data_len); if (!p_varm_data) { hmi_qd_error_handler(HMI_RGL_IMAGE_NOT_ENOUGH_MEM); p_buffer_data = pdata; } else { memcpy(p_varm_data, (void*)pdata, data_len); p_buffer_data = p_varm_data; }  } return p_buffer_data; } #if 0 void call_C_hmi_driver_2buffer_copy(HMI_RECT_STR *pdirty_rect,UINT8 layer) { r_drw2d_Error_t ret = R_DRW2D_ERR_OK;  r_drw2d_Rect_t dst_rect = {{0,0},{0,0}}; r_drw2d_IntRect_t clip_rect = {{0,0},{0,0}}; void* setlocSurface = NULL; r_drw2d_Texture_t texture = {0};  UINT8 clip_index = 0; UINT8 next_clip_index = 0; r_drw2d_Framebuffer_t fb = {0}; hmi_qd_fbformat_t fmt = HMI_LOC_VOVIAL_FORMAT;  if((pdirty_rect != NULL)&& (locSurface[layer] != NULL)&& (pdirty_rect[layer].w > 0)&& (pdirty_rect[layer].h > 0)) {  /*test*/  /******/ if((hmi_layer_info[layer] == HMI_LAYER_BUFFER)|| (hmi_layer_info[layer] == HMI_LAYER_VIDEOIN)) { setlocSurface = hmi_get_window(layer); locGetRenderTarget(setlocSurface); hmi_qd_getbufferinfo(setlocSurface, &fmt, &fb.Buffer.Pitch,  &fb.Buffer.Size.Width,  &fb.Buffer.Size.Height);  /*get texture*/ texture.Handle = R_NULL; texture.Flags = R_DRW2D_TEX_NONE;  texture.Buffer.Pitch = fb.Buffer.Pitch;//HMI_TEXTURE_STRIDE(width*LOC_BYTE_PER_PIXEL1); texture.Buffer.Size.Width = fb.Buffer.Size.Width; texture.Buffer.Size.Height = fb.Buffer.Size.Height; texture.Buffer.PixelFormat = hmi_loc_drw2d_framebuffer_format; texture.Buffer.Data = hmi_qd_getvisiblebuffer(setlocSurface);  if(texture.Buffer.Data !=NULL) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Identity and Set texture */ ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV);  ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV);  ret |= R_DRW2D_CtxTextureTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TEX_TRANSFORM_2D); ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_SRC);   ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE); ret |= R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0, &texture);  next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ clip_rect.Pos.X = pdirty_rect[next_clip_index].x-locSurface_rect[layer].x;  clip_rect.Pos.Y = pdirty_rect[next_clip_index].y-locSurface_rect[layer].y; clip_rect.Size.Width = pdirty_rect[next_clip_index].w; clip_rect.Size.Height = pdirty_rect[next_clip_index].h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); dst_rect.Pos.X = R_DRW2D_2X(clip_rect.Pos.X); dst_rect.Pos.Y = R_DRW2D_2X(clip_rect.Pos.Y); dst_rect.Size.Width = R_DRW2D_2X(clip_rect.Size.Width); dst_rect.Size.Height= R_DRW2D_2X(clip_rect.Size.Height); ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV, &dst_rect,&dst_rect); clip_index++; next_clip_index ++; }  /*error*/  if (R_DRW2D_ERR_OK != ret) { loc_Error_hmi(ret); } loc_IncMsgCount(HMI_LOC_VOVIAL_UNIT);  }  } } } #endif void call_C_hmi_driver_draw_image(HMI_RECT_STR CONST *pscreen_target, HMI_IMAGE_ATTR_STR img_compress, HMI_RECT_ALPHA_ANGEL_STR *palpha_pos_angel,  HMI_BITMAP_STR CONST *pimage_prop_info, HMI_RECT_STR *pclip_rect, HMI_RECT_STR *pdirty_rect, UINT8 layer,  HMI_ROTATION_STR *protation,/*rotation point,NULL mean center point*/ HMI_OBJECT_ID_STR hmi_object_id #ifdef HMI_GRAPHIC_RGL ,UINT8 father_alpha #endif ) { r_drw2d_Error_t ret = R_DRW2D_ERR_OK;  r_drw2d_Rect_t dst_rect = {{0,0},{0,0}}; r_drw2d_Rect_t src_rect = {{0,0},{0,0}}; r_drw2d_IntRect_t clip_rect = {{0,0},{0,0}}; void* setlocSurface= NULL; r_drw2d_Texture_t texture = {0};  BOOLEAN rotation = FALSE; BOOLEAN alpha = FALSE; SPOINT_TP center = {0,0};  SPOINT_TP newCenter = {0,0}; rgl_image_type_str bmp_compress= HMI_IMAGE_NO_COMPRESS;  UINT8 bmp_alpha_rotation_flag=((img_compress.image_attr)&0xf0); r_drw2d_Point_t rot_center = {0,0}; r_drw2d_Point_t tex_rot_center = {0,0}; HMI_RECT_STR hmi_disp_target = {0,0,0,0}; UINT8 image_alpha = HMI_OPAQUE; float_32 scale_x = 1.0f; float_32 scale_y = 1.0f; float_32 source_scale_x = 1.0f; float_32 source_scale_y = 1.0f; HMI_RECT_STR hmi_sprite_target= {0,0,0,0}; UINT8 hmi_blur_flag = 0; BOOLEAN blur_alloc = FALSE; UINT32 rle_size = 0; UINT8 clip_index = 0; UINT8 next_clip_index = 0; HMI_RECT_STR hmi_min_dirty_rect = {0,0,0,0};  #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret = R_DRW2D_CtxImgQuality(HMI_LOC_DRW2D_DEV, R_DRW2D_IMGQUALITY_MEDIUM); #endif if(R_DRW2D_ERR_OK == ret) { ret |= R_DRW2D_CtxTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TRANSFORM_2D); } if((pscreen_target != NULL)&&(palpha_pos_angel != NULL)&& (pimage_prop_info != NULL)&&(pclip_rect != NULL)) {  /*display zone*/ hmi_disp_target.x = pscreen_target->x; hmi_disp_target.y = pscreen_target->y;  hmi_disp_target.w = pscreen_target->w; hmi_disp_target.h = pscreen_target->h; /*convert screen coordinate to layer coordinate*/ hmi_disp_target.x -= locSurface_rect[layer].x; hmi_disp_target.y -= locSurface_rect[layer].y; /*scaleX,ScaleY*/ if((pscreen_target->w != 0)&&(pimage_prop_info->w != 0)) { scale_x = ((float_32)(pimage_prop_info->w))/pscreen_target->w; source_scale_x = ((float_32)(pscreen_target->w))/pimage_prop_info->w; } else { scale_x = 1; source_scale_x = 1; } if((pscreen_target->h!=0)&&(pimage_prop_info->h != 0)) { scale_y = ((float_32)(pimage_prop_info->h))/pscreen_target->h; source_scale_y = ((float_32)(pscreen_target->h))/pimage_prop_info->h; } else { scale_y = 1; source_scale_y = 1; } hmi_blur_flag = palpha_pos_angel->attr&HMI_BLUR_FLAG; bmp_compress = get_compress_fmt(img_compress); rotation = bmp_alpha_rotation_flag&HMI_ROTATION_IMAGE_FLAG; alpha = bmp_alpha_rotation_flag&HMI_ALPHA_IMAGE_FLAG; /*get texture*/  get_texture_res_manager(hmi_object_id,  &texture, (uint8_t *)(pimage_prop_info->pbitmap_data), pimage_prop_info->data_len, pimage_prop_info->w, pimage_prop_info->h, rotation, bmp_compress, alpha, 0); if(texture.Buffer.Data !=NULL) { if(bmp_compress == HMI_IMAGE_JPG) { #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) if((hmi_layer_info[layer] == HMI_LAYER_BUFFER)|| (hmi_layer_info[layer] == HMI_LAYER_VIDEOIN))/*only buffer and video display JPG*/ { /*Clip position*/ clip_rect.Pos.X = pclip_rect->x-locSurface_rect[layer].x;  clip_rect.Pos.Y = pclip_rect->y-locSurface_rect[layer].y; clip_rect.Size.Width = pclip_rect->w; clip_rect.Size.Height = pclip_rect->h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); decode_JPG2Mem(&texture,layer,palpha_pos_angel,hmi_disp_target);  } #endif } else if((hmi_layer_info[layer] == HMI_LAYER_BUFFER)|| (hmi_layer_info[layer] == HMI_LAYER_VIDEOIN)) {  #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) if(hmi_blur_flag !=0) { blur_alloc=hmi_alloc_blur_buffer(&texture); if(blur_alloc) { R_DRW2D_CtxConvolutionKernelPreset2d(HMI_LOC_DRW2D_DEV, R_DRW2D_CONV2D_GAUSSIAN_BLUR_5x5); R_DRW2D_CtxStripingEnable(HMI_LOC_DRW2D_DEV); if(bmp_compress == HMI_IMAGE_RLE) { if((hmi_rle_blur_buffer.Buffer.Size.Width!=pimage_prop_info->w)|| (hmi_rle_blur_buffer.Buffer.Size.Height!=pimage_prop_info->h)|| (hmi_blur_buffer.Buffer.PixelFormat!=texture.Buffer.PixelFormat)) { if((hmi_rle_blur_buffer.Buffer.Data)!=NULL) { R_CDI_Free((uint32_t)(hmi_rle_blur_buffer.Buffer.Data),HMI_LOC_VRAM_HEAP); hmi_rle_blur_buffer.Buffer.Data = NULL; } hmi_rle_blur_buffer.Flags = (r_drw2d_FramebufferFlags_t)R_DRW2D_TEX_BILINEAR; hmi_rle_blur_buffer.Handle = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr not used currently */ hmi_rle_blur_buffer.Buffer = texture.Buffer; rle_size = hmi_bpp*hmi_rle_blur_buffer.Buffer.Size.Width* hmi_rle_blur_buffer.Buffer.Size.Height; hmi_rle_blur_buffer.Buffer.Data = R_CDI_Alloc(HMI_LOC_VRAM_HEAP, rle_size); /*Texture position*/ src_rect.Pos.X = R_DRW2D_2X(0);  src_rect.Pos.Y = R_DRW2D_2X(0); src_rect.Size.Width = R_DRW2D_2X(pimage_prop_info->w); src_rect.Size.Height= R_DRW2D_2X(pimage_prop_info->h);  if((hmi_rle_blur_buffer.Buffer.Data)!=NULL) { hmi_scale_blit_Texture(&hmi_rle_blur_buffer,&texture,&src_rect,&src_rect); texture.Flags = R_DRW2D_TEX_NONE;  Blur_Buffer(&hmi_rle_blur_buffer.Buffer,&hmi_blur_buffer.Buffer); texture.Flags |=R_DRW2D_TEX_BILINEAR; texture.Buffer.Data=hmi_blur_buffer.Buffer.Data; } } } else { Blur_Buffer(&texture.Buffer,&hmi_blur_buffer.Buffer); texture.Flags |=R_DRW2D_TEX_BILINEAR; texture.Buffer.Data=hmi_blur_buffer.Buffer.Data; }  } } #endif /*set window*/  setlocSurface = hmi_get_window(layer); locGetRenderTarget(setlocSurface); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Identity and Set texture */ ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV);  ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV);  ret |= R_DRW2D_CtxTextureTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TEX_TRANSFORM_2D); #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_CUSTOM);  ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV, R_DRW2D_BLEND_SRC_ALPHA, R_DRW2D_BLEND_ONE_MINUS_SRC_ALPHA, R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE  ); #else ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_SRC_OVER); #endif ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE); ret |= R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0, &texture); /*Texture position*/ src_rect.Pos.X = R_DRW2D_2X(0);  src_rect.Pos.Y = R_DRW2D_2X(0); src_rect.Size.Width = R_DRW2D_2X(pimage_prop_info->w); src_rect.Size.Height= R_DRW2D_2X(pimage_prop_info->h);  /*global angel*/  if(father_alpha > palpha_pos_angel->alpha) { image_alpha = palpha_pos_angel->alpha; } else { image_alpha = father_alpha; } if(image_alpha != HMI_OPAQUE) { set_alpha_effect(image_alpha);  } if((pscreen_target->w != pimage_prop_info->w)|| (pscreen_target->h != pimage_prop_info->h)) { texture.Flags |= R_DRW2D_TEX_BILINEAR; }  /*rotation*/ if(fabs(palpha_pos_angel->angel) > HMI_FLOAT_TOLERANCE ) {  if(protation == NULL)/*rotation center pointer*/ { rot_center.X = R_DRW2D_2X(hmi_disp_target.x+pimage_prop_info->w/2); rot_center.Y = R_DRW2D_2X(hmi_disp_target.y+pimage_prop_info->h/2); tex_rot_center.X= R_DRW2D_2X(pimage_prop_info->w/2); tex_rot_center.Y= R_DRW2D_2X(pimage_prop_info->h/2); dst_rect.Pos.X = R_DRW2D_2X(0); dst_rect.Pos.Y = R_DRW2D_2X(0); dst_rect.Size.Width = R_DRW2D_2X(pimage_prop_info->w); dst_rect.Size.Height= R_DRW2D_2X(pimage_prop_info->h);  }  else {  /*convert screen coordinate to layer coordinate*/ center.x = pscreen_target->x - locSurface_rect[layer].x; center.y = pscreen_target->y - locSurface_rect[layer].y;  protation->x -= locSurface_rect[layer].x;  protation->y -= locSurface_rect[layer].y;  newCenter.x = protation->x; newCenter.y = protation->y;  /*Screen position*/ rot_center.X = R_DRW2D_2X(newCenter.x); rot_center.Y = R_DRW2D_2X(newCenter.y);  tex_rot_center.X= R_DRW2D_2X((newCenter.x-center.x)); tex_rot_center.Y= R_DRW2D_2X((newCenter.y-center.y));  dst_rect.Pos.X = R_DRW2D_2X(0); dst_rect.Pos.Y = R_DRW2D_2X(0); dst_rect.Size.Width = R_DRW2D_2X(pimage_prop_info->w); dst_rect.Size.Height= R_DRW2D_2X(pimage_prop_info->h); }  ret |= R_DRW2D_CtxTextureTranslate(HMI_LOC_DRW2D_DEV, rot_center.X, rot_center.Y); ret |= R_DRW2D_CtxTextureRotate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(palpha_pos_angel->angel)); ret |= R_DRW2D_CtxTextureTranslate(HMI_LOC_DRW2D_DEV, -tex_rot_center.X , -tex_rot_center.Y); if((pscreen_target->w != pimage_prop_info->w)|| (pscreen_target->h != pimage_prop_info->h)) { ret |= R_DRW2D_CtxTextureScale(HMI_LOC_DRW2D_DEV,R_DRW2D_2X(scale_x),R_DRW2D_2X(scale_y)); } ret |= R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, rot_center.X , rot_center.Y, 0); ret |= R_DRW2D_CtxRotate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(palpha_pos_angel->angel)); ret |= R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, -tex_rot_center.X, -tex_rot_center.Y, 0); if((pscreen_target->w != pimage_prop_info->w)|| (pscreen_target->h != pimage_prop_info->h)) { ret |= R_DRW2D_CtxScale(HMI_LOC_DRW2D_DEV,R_DRW2D_2X(source_scale_x),R_DRW2D_2X(source_scale_y),0); } next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_DrawRect(HMI_LOC_DRW2D_DEV, &dst_rect); } clip_index++; next_clip_index ++; }  if(image_alpha != HMI_OPAQUE) { ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); } if((hmi_blur_flag !=0)&&(blur_alloc==TRUE)) { ret |= R_DRW2D_CtxStripingDisable(HMI_LOC_DRW2D_DEV); } } else { /*Screen position*/  dst_rect.Pos.X = R_DRW2D_2X(hmi_disp_target.x); dst_rect.Pos.Y = R_DRW2D_2X(hmi_disp_target.y); dst_rect.Size.Width = R_DRW2D_2X(pscreen_target->w); dst_rect.Size.Height= R_DRW2D_2X(pscreen_target->h); next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV, &src_rect,&dst_rect); } clip_index++; next_clip_index ++; }   if((hmi_blur_flag !=0)&&(blur_alloc==TRUE)) { ret |= R_DRW2D_CtxStripingDisable(HMI_LOC_DRW2D_DEV); } if(image_alpha != HMI_OPAQUE) { ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); } }  /*error*/  if (R_DRW2D_ERR_OK != ret) { loc_Error_hmi(ret); } loc_IncMsgCount(HMI_LOC_VOVIAL_UNIT);  } #if 1//removed by pxguo allframebuffer else if(hmi_layer_info[layer] == HMI_LAYER_RLE) { /*Clip position*/ clip_rect.Pos.X = pclip_rect[layer].x-locSurface_rect[layer].x;  clip_rect.Pos.Y = pclip_rect[layer].y-locSurface_rect[layer].y; clip_rect.Size.Width = pclip_rect[layer].w; clip_rect.Size.Height = pclip_rect[layer].h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); hmi_draw_RLESurface((void*)texture.Buffer.Data,layer); } #endif #if 1 else if(hmi_layer_info[layer] == HMI_LAYER_SPRITE) { hmi_sprite_target.x = hmi_disp_target.x; hmi_sprite_target.y = hmi_disp_target.y; hmi_sprite_target.w = pscreen_target->w; hmi_sprite_target.h = pscreen_target->h; hmi_draw_SpriteSurface((void*)texture.Buffer.Data, hmi_disp_target.x, hmi_disp_target.y, pimage_prop_info->w, pimage_prop_info->h, layer, hmi_object_id, hmi_sprite_target, palpha_pos_angel,  father_alpha ); }  #endif else { }  }  } }  #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX )))  /*********************************************************** Function: SetupLightPara */  r_drw2d_Color_t SetupLightPara(vector3d_t vec){ r_drw2d_Color_t tmp = 0xff000000; int x,y,z;  x = (int)(vec.X hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml 127.0f) + 128; y = (int)(vec.Y hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml 127.0f) + 128; z = (int)(vec.Z hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml 127.0f) + 128;  tmp |= (x & 0xff)<<16 | (y & 0xff)<<8 | z & 0xff; return tmp; } void set_bump_effect(vector3d_t vec) { effect_stages[0].Name = R_DRW2D_EFFECT_DOT3; effect_stages[0].Args[0].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT;  effect_stages[0].Args[0].Param.Color.Source.TextureUnit = 0; effect_stages[0].Args[0].Param.Color.Operand = R_DRW2D_EFFECT_COLOR_OPERAND_RGBA;  effect_stages[0].Args[1].Source = R_DRW2D_EFFECT_SOURCE_CONSTANT_COLOR; effect_stages[0].Args[1].Param.Color.Source.ConstantColor = SetupLightPara(vec); effect_stages[0].Args[1].Param.Color.Operand = R_DRW2D_EFFECT_COLOR_OPERAND_RGBA;  effect_stages[0].Args[2].Source = R_DRW2D_EFFECT_SOURCE_CONSTANT_COLOR; effect_stages[0].Args[2].Param.Color.Source.ConstantColor = 0x00080808; //0x00171717; effect_stages[0].Args[2].Param.Color.Operand = R_DRW2D_EFFECT_COLOR_OPERAND_RGBA;  effect_stages[1].Name = R_DRW2D_EFFECT_MODULATE; effect_stages[1].Args[0].Source = R_DRW2D_EFFECT_SOURCE_PREV_STAGE; effect_stages[1].Args[0].Param.Color.Operand = R_DRW2D_EFFECT_COLOR_OPERAND_RGBA;  effect_stages[1].Args[1].Source = R_DRW2D_EFFECT_SOURCE_TEXTURE_UNIT; effect_stages[1].Args[1].Param.Color.Source.TextureUnit = 1; effect_stages[1].Args[1].Param.Color.Operand = R_DRW2D_EFFECT_COLOR_OPERAND_RGBA; }   vector3d_t locVertexTransform3d(vector3d_t Vec, CONST double *m) { /* (a e i m) (x) (a*x + e*y + i*z + m*w) (b f j n) hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml (y) = (b*x + f*y + j*z + n*w) (c g k o) (z) (c*x + g*y + k*z + o*w) (d h l p) (w) (d*x + h*y + l*z + p*w)  w = 1 */  vector3d_t ret;   double w = (m[ 3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.X) + (m[ 7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Y) + (m[11] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Z) + m[15]; double w_reciprocal = 1.0 / w;   ret.X = ((((m[ 0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.X) + (m[ 4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Y) + (m[ 8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Z) + m[12]) hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml w_reciprocal)); ret.Y = ((((m[ 1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.X) + (m[ 5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Y) + (m[ 9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Z) + m[13]) hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml w_reciprocal)); ret.Z = ((((m[ 2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.X) + (m[ 6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Y) + (m[10] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Z) + m[14]) hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml w_reciprocal));  return ret; }   /*********************************************************** Function: locVertexTransform4d */  vector4d_t locVertexTransform4d(vector4d_t Vec, CONST double *m) { /* (a e i m) (x) (a*x + e*y + i*z + m*w) (b f j n) hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml (y) = (b*x + f*y + j*z + n*w) (c g k o) (z) (c*x + g*y + k*z + o*w) (d h l p) (w) (d*x + h*y + l*z + p*w) */  vector4d_t ret;   ret.X = ((m[ 0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.X) + (m[ 4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Y) + (m[ 8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Z) + (m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.W)); ret.Y = ((m[ 1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.X) + (m[ 5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Y) + (m[ 9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Z) + (m[13] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.W)); ret.Z = ((m[ 2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.X) + (m[ 6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Y) + (m[10] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Z) + (m[14] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.W)); ret.W = ((m[ 3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.X) + (m[ 7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Y) + (m[11] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.Z) + (m[15] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml Vec.W));   return ret; }   uint8_t invertMatrix(CONST double m[16], double invOut[16]) { double inv[16], det; int i;  inv[0] = m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] -  m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] -  m[9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] +  m[9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] + m[13] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] -  m[13] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10];  inv[4] = -m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] +  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] +  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] -  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] -  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] +  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10];  inv[8] = m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] -  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] -  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] +  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] +  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] -  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9];  inv[12] = -m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] +  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] + m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] -  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] -  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] +  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9];  inv[1] = -m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] +  m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] +  m[9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] -  m[9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] -  m[13] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] +  m[13] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10];  inv[5] = m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] -  m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] -  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] +  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] +  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] -  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10];  inv[9] = -m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] +  m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] +  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] -  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] -  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] +  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9];  inv[13] = m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] -  m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] -  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] +  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] +  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] -  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9];  inv[2] = m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] -  m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] -  m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] +  m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] +  m[13] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] -  m[13] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6];  inv[6] = -m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] +  m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] +  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] -  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] -  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] +  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6];  inv[10] = m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] -  m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] -  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[15] +  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] +  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] -  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5];  inv[14] = -m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] +  m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] +  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[14] -  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[13] -  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] +  m[12] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5];  inv[3] = -m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] +  m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] +  m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] -  m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] -  m[9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] +  m[9] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6];  inv[7] = m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] -  m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] -  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] +  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] +  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] -  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6];  inv[11] = -m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] +  m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9] +  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[11] -  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9] -  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[7] +  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5];  inv[15] = m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] -  m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9] -  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[10] +  m[4] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[9] +  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[6] -  m[8] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml m[5];  det = m[0] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml inv[0] + m[1] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml inv[4] + m[2] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml inv[8] + m[3] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml inv[12];  if (det == 0) return 0;  det = 1.0 / det;  for (i = 0; i < 16; i++) invOut[i] = inv[i] hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml det;  return 1; }    void locCalcLightSource( CONST r_drw2d_Vec4_t *Points) {  #if 0 vector3d_t pointA; vector3d_t pointB;  vector3d_t lightVector; vector3d_t locLightPoint;  pointA.X = 0.5f; pointA.Y = 0.5f; pointA.Z = 0.5f;   pointB = locVertexTransform3d(pointA,mModelView);  invertMatrix(mModelView,mInverseModelView);  locLightPoint = locVertexTransform3d(lightPoint,mInverseModelView);  lightVector = subtractVector(locLightPoint,pointA);  lightVector = vectorNormalize(lightVector);  vecLight = lightVector;  #endif }  /*********************************************************** Function: loc_setFrustrumMatrix */ static r_drw2d_Error_t loc_setFrustrumMatrix(void) { static float szz = SZ;  return R_DRW2D_CtxFrustum(HMI_LOC_DRW2D_DEV, #if 1 R_DRW2D_2X(-(szz*FB_SX)/FB_SY), /*left*/ R_DRW2D_2X((szz*FB_SX)/FB_SY), /*right*/ R_DRW2D_2X(szz), /*bottom*/ R_DRW2D_2X(-szz), /*top*/ R_DRW2D_2X(4/*4*/), /*znear*/ R_DRW2D_2X(5/*5*/) /*zfar*/ #else R_DRW2D_2X(-1), /*left*/ R_DRW2D_2X(1), /*right*/ R_DRW2D_2X(szz), /*bottom*/ R_DRW2D_2X(-szz), /*top*/ R_DRW2D_2X(4), /*znear*/ R_DRW2D_2X(5) /*zfar*/ #endif ); } void hmi_get_cube_texture(HMI_CUBE_FACE_STR *pface_prop,r_drw2d_Texture_t *ptexture) { BOOLEAN alpha = FALSE; BOOLEAN rotation = FALSE; rgl_image_type_str bmp_compress= HMI_IMAGE_NO_COMPRESS; /*get texture*/  if(pface_prop->cube_face1_texture.tex_id !=HMI_ALL_OBJECT) { rotation= (((pface_prop->cube_face1_texture.tex_attr.image_attr)&0xf0)&HMI_ROTATION_IMAGE_FLAG); alpha = (((pface_prop->cube_face1_texture.tex_attr.image_attr)&0xf0)&HMI_ALPHA_IMAGE_FLAG); bmp_compress=get_compress_fmt(pface_prop->cube_face1_texture.tex_attr); get_texture_res_manager(pface_prop->cube_face1_texture.tex_id, &ptexture[0], (uint8_t *)(pface_prop->cube_face1_texture.tex_prop.pbitmap_data), pface_prop->cube_face1_texture.tex_prop.data_len, pface_prop->cube_face1_texture.tex_prop.w, pface_prop->cube_face1_texture.tex_prop.h, rotation, bmp_compress, alpha, 0);  ptexture[0].Flags|= R_DRW2D_TEX_PERSPECTIVE|R_DRW2D_TEX_BILINEAR; } if(pface_prop->cube_face2_texture.tex_id !=HMI_ALL_OBJECT) { rotation= (((pface_prop->cube_face2_texture.tex_attr.image_attr)&0xf0)&HMI_ROTATION_IMAGE_FLAG); alpha = (((pface_prop->cube_face2_texture.tex_attr.image_attr)&0xf0)&HMI_ALPHA_IMAGE_FLAG); bmp_compress=get_compress_fmt(pface_prop->cube_face2_texture.tex_attr); get_texture_res_manager(pface_prop->cube_face2_texture.tex_id, &ptexture[1], (uint8_t *)(pface_prop->cube_face2_texture.tex_prop.pbitmap_data), pface_prop->cube_face2_texture.tex_prop.data_len, pface_prop->cube_face2_texture.tex_prop.w, pface_prop->cube_face2_texture.tex_prop.h, rotation, bmp_compress, alpha, 0);  ptexture[1].Flags|= R_DRW2D_TEX_PERSPECTIVE|R_DRW2D_TEX_BILINEAR; } if(pface_prop->cube_face3_texture.tex_id !=HMI_ALL_OBJECT) { rotation= (((pface_prop->cube_face3_texture.tex_attr.image_attr)&0xf0)&HMI_ROTATION_IMAGE_FLAG); alpha = (((pface_prop->cube_face3_texture.tex_attr.image_attr)&0xf0)&HMI_ALPHA_IMAGE_FLAG); bmp_compress=get_compress_fmt(pface_prop->cube_face3_texture.tex_attr); get_texture_res_manager(pface_prop->cube_face3_texture.tex_id, &ptexture[2], (uint8_t *)(pface_prop->cube_face3_texture.tex_prop.pbitmap_data), pface_prop->cube_face3_texture.tex_prop.data_len, pface_prop->cube_face3_texture.tex_prop.w, pface_prop->cube_face3_texture.tex_prop.h, rotation, bmp_compress, alpha, 0); ptexture[2].Flags|= R_DRW2D_TEX_PERSPECTIVE|R_DRW2D_TEX_BILINEAR; } if(pface_prop->cube_face4_texture.tex_id !=HMI_ALL_OBJECT) { rotation= (((pface_prop->cube_face4_texture.tex_attr.image_attr)&0xf0)&HMI_ROTATION_IMAGE_FLAG); alpha = (((pface_prop->cube_face4_texture.tex_attr.image_attr)&0xf0)&HMI_ALPHA_IMAGE_FLAG); bmp_compress=get_compress_fmt(pface_prop->cube_face4_texture.tex_attr); get_texture_res_manager(pface_prop->cube_face4_texture.tex_id, &ptexture[3], (uint8_t *)(pface_prop->cube_face4_texture.tex_prop.pbitmap_data), pface_prop->cube_face4_texture.tex_prop.data_len, pface_prop->cube_face4_texture.tex_prop.w, pface_prop->cube_face4_texture.tex_prop.h, rotation, bmp_compress, alpha, 0); ptexture[3].Flags|= R_DRW2D_TEX_PERSPECTIVE|R_DRW2D_TEX_BILINEAR; } if(pface_prop->cube_face5_texture.tex_id !=HMI_ALL_OBJECT) { rotation= (((pface_prop->cube_face5_texture.tex_attr.image_attr)&0xf0)&HMI_ROTATION_IMAGE_FLAG); alpha = (((pface_prop->cube_face5_texture.tex_attr.image_attr)&0xf0)&HMI_ALPHA_IMAGE_FLAG); bmp_compress=get_compress_fmt(pface_prop->cube_face5_texture.tex_attr); get_texture_res_manager(pface_prop->cube_face5_texture.tex_id, &ptexture[4], (uint8_t *)(pface_prop->cube_face5_texture.tex_prop.pbitmap_data), pface_prop->cube_face5_texture.tex_prop.data_len, pface_prop->cube_face5_texture.tex_prop.w, pface_prop->cube_face5_texture.tex_prop.h, rotation,  bmp_compress, alpha, 0); ptexture[4].Flags|= R_DRW2D_TEX_PERSPECTIVE|R_DRW2D_TEX_BILINEAR; } if(pface_prop->cube_face6_texture.tex_id !=HMI_ALL_OBJECT) { rotation= (((pface_prop->cube_face6_texture.tex_attr.image_attr)&0xf0)&HMI_ROTATION_IMAGE_FLAG); alpha = (((pface_prop->cube_face6_texture.tex_attr.image_attr)&0xf0)&HMI_ALPHA_IMAGE_FLAG); bmp_compress=get_compress_fmt(pface_prop->cube_face6_texture.tex_attr); get_texture_res_manager(pface_prop->cube_face6_texture.tex_id, &ptexture[5], (uint8_t *)(pface_prop->cube_face6_texture.tex_prop.pbitmap_data), pface_prop->cube_face6_texture.tex_prop.data_len, pface_prop->cube_face6_texture.tex_prop.w, pface_prop->cube_face6_texture.tex_prop.h, rotation, bmp_compress, alpha, 0); ptexture[5].Flags|= R_DRW2D_TEX_PERSPECTIVE|R_DRW2D_TEX_BILINEAR; }  }  void call_C_hmi_driver_draw_cube(HMI_RECT_STR CONST *pscreen_target, HMI_CUBE_STR CONST *pcube_str, HMI_CUBE_FACE_STR *pcube_textrue, HMI_CUBE_FACE_STR *pbump_textrue, HMI_RECT_STR *pclip_rect, HMI_RECT_STR *pdirty_rect, UINT8 layer,  /*HMI_OBJECT_ID_STR hmi_object_id,*/ UINT8 father_alpha, HMI_CUBE_AXIS_PROP CONST *paxis, S3POINT_TP *protation_axis  ) { r_drw2d_Error_t ret = R_DRW2D_ERR_OK;  r_drw2d_IntRect_t clip_rect = {0}; void* setlocSurface = NULL; r_drw2d_Texture_t texture[6] = {0};  r_drw2d_Texture_t bump_texture[6] = {0};  INT32 ang = (0.0f); INT32 private_ang = (0.0f); float_32 zTrans = Z_TRANS; UINT32 cubeMask = 0x00;  vector3d_t vecLight = {0.5f,0.5f,0.5f}; UINT8 locEdgeFlags = 0x00; UINT8 side = 0; UINT8 rotation_axis = 0;  float_32 normal_x = 0; float_32 normal_y = 0; float_32 normal_z = 0; float_32 private_normal_x = 0; float_32 private_normal_y = 0; float_32 private_normal_z = 0; float_32 normal_vec_len = 0; float_32 cube_w = ((float_32)(pscreen_target->w)/((float_32)(FB_SY)));  float_32 cube_h = ((float_32)(pscreen_target->h)/((float_32)(FB_SY)));  #if 0 float_32 cube_x = (float_32)(((float_32)((FB_SX/2)-(pscreen_target->x-locSurface_rect[layer].x +(pscreen_target->w/2))))/((float_32)(FB_SX/2))); float_32 cube_y = (float_32)(((float_32)((FB_SY/2)-(pscreen_target->y-locSurface_rect[layer].y +(pscreen_target->w/2))))/((float_32)(FB_SY)));  #endif float_32 cube_x = 0; float_32 cube_y = 0;  float_32 pos_to_public1_x= 0; float_32 pos_to_public1_y= 0; float_32 pos_to_public1_z= 0;  UINT8 clip_index = 0; UINT8 next_clip_index = 0; HMI_RECT_STR hmi_min_dirty_rect = {0,0,0,0}; S3POINT_FLOAT_TP axis[HMI_ROTATION_AXIS_CNT] = {{0.0f,0.0f,0.0f},{0.0f,0.0f,0.0f},{0.0f,0.0f,0.0f}};  if((pscreen_target != NULL)&&(pclip_rect != NULL)&& (paxis != NULL)&&(protation_axis != NULL)) {  /*convert pscreen_target to layer coordinate*/ cube_x = pscreen_target->x+pscreen_target->w/2;// - locSurface_rect[layer].x; cube_y = pscreen_target->y+pscreen_target->h/2;// - locSurface_rect[layer].y; /*convert cube_x,cube_y to layer center as origin(x to left,y to up)*/ cube_x = FB_SX/2-cube_x;//(locSurface_rect[layer].x + locSurface_rect[layer].w/2)-cube_x; cube_y = FB_SY/2-cube_y;//(locSurface_rect[layer].y + locSurface_rect[layer].h/2)-cube_y; /*convert cube_x,cube_y to layer view coordinate.origin at layer center*/ cube_x = cube_x/((float_32)(FB_SX/2.0f)); cube_y = cube_y/((float_32)(FB_SY));   /*draw rect*/ cube_rect1_4.Pos.X = R_DRW2D_2X(-(cube_w/2.0)); cube_rect1_4.Pos.Y = R_DRW2D_2X(-(cube_h/2.0)); cube_rect1_4.Size.Width = R_DRW2D_2X(cube_w); cube_rect1_4.Size.Height = R_DRW2D_2X(cube_h);  cube_rect5_6.Pos.X = R_DRW2D_2X(-(cube_w/2.0)); cube_rect5_6.Pos.Y = R_DRW2D_2X(-(cube_w/2.0)); cube_rect5_6.Size.Width = R_DRW2D_2X(cube_w); cube_rect5_6.Size.Height = R_DRW2D_2X(cube_w);  /*get face mask*/ if(pcube_textrue->cube_face1_texture.tex_prop.pbitmap_data != NULL) { cubeMask = cubeMask|(1 << 1);  } if(pcube_textrue->cube_face2_texture.tex_prop.pbitmap_data != NULL) { cubeMask = cubeMask|(1 << 2);  } if(pcube_textrue->cube_face3_texture.tex_prop.pbitmap_data != NULL) { cubeMask = cubeMask|(1 << 3);  } if(pcube_textrue->cube_face4_texture.tex_prop.pbitmap_data != NULL) { cubeMask = cubeMask|(1 << 4);  } if(pcube_textrue->cube_face5_texture.tex_prop.pbitmap_data != NULL) { cubeMask = cubeMask|(1 << 5);  } if(pcube_textrue->cube_face6_texture.tex_prop.pbitmap_data != NULL) { cubeMask = cubeMask|(1 << 6);  } /*Rotaion axis*/ rotation_axis = paxis->attribute&HMI_CUBE_ROTATION_MASK;  if(rotation_axis == HMI_CUBE_ROTATION_USERDEFINE) {  zTrans = pcube_str->z;//Z_TRANS;  zTrans = (zTrans/((float_32)(FB_SY)));  axis[HMI_ROTATION_PRIVATE_AXIS].x = protation_axis[HMI_ROTATION_PRIVATE_AXIS].x; axis[HMI_ROTATION_PRIVATE_AXIS].y = protation_axis[HMI_ROTATION_PRIVATE_AXIS].y; axis[HMI_ROTATION_PRIVATE_AXIS].z = protation_axis[HMI_ROTATION_PRIVATE_AXIS].z;  axis[HMI_ROTATION_PUBLIC_AXIS1].x = protation_axis[HMI_ROTATION_PUBLIC_AXIS1].x; axis[HMI_ROTATION_PUBLIC_AXIS1].y = protation_axis[HMI_ROTATION_PUBLIC_AXIS1].y; axis[HMI_ROTATION_PUBLIC_AXIS1].z = protation_axis[HMI_ROTATION_PUBLIC_AXIS1].z;  axis[HMI_ROTATION_PUBLIC_AXIS2].x = protation_axis[HMI_ROTATION_PUBLIC_AXIS2].x; axis[HMI_ROTATION_PUBLIC_AXIS2].y = protation_axis[HMI_ROTATION_PUBLIC_AXIS2].y; axis[HMI_ROTATION_PUBLIC_AXIS2].z = protation_axis[HMI_ROTATION_PUBLIC_AXIS2].z; /*convert pscreen_target to layer coordinate*/  //axis[HMI_ROTATION_PUBLIC_AXIS1].x -= locSurface_rect[layer].x; //axis[HMI_ROTATION_PUBLIC_AXIS1].y -= locSurface_rect[layer].y;  //axis[HMI_ROTATION_PUBLIC_AXIS2].x -= locSurface_rect[layer].x; //axis[HMI_ROTATION_PUBLIC_AXIS2].y -= locSurface_rect[layer].y;  /*convert cube_x,cube_y to layer center as origin*/  axis[HMI_ROTATION_PUBLIC_AXIS1].x = (FB_SX/2)-axis[HMI_ROTATION_PUBLIC_AXIS1].x; axis[HMI_ROTATION_PUBLIC_AXIS1].y = (FB_SY/2)-axis[HMI_ROTATION_PUBLIC_AXIS1].y;  axis[HMI_ROTATION_PUBLIC_AXIS2].x = (FB_SX/2)-axis[HMI_ROTATION_PUBLIC_AXIS2].x; axis[HMI_ROTATION_PUBLIC_AXIS2].y = (FB_SY/2)-axis[HMI_ROTATION_PUBLIC_AXIS2].y; /*convert cube_x,cube_y to layer view coordinate.origin at layer center*/ axis[HMI_ROTATION_PRIVATE_AXIS].x = axis[HMI_ROTATION_PRIVATE_AXIS].x/(FB_SX/2.0f); axis[HMI_ROTATION_PRIVATE_AXIS].y = axis[HMI_ROTATION_PRIVATE_AXIS].y/FB_SY;  axis[HMI_ROTATION_PRIVATE_AXIS].z = (axis[HMI_ROTATION_PRIVATE_AXIS].z/((float_32)(FB_SY)));  axis[HMI_ROTATION_PUBLIC_AXIS1].x = axis[HMI_ROTATION_PUBLIC_AXIS1].x/(FB_SX/2.0f); axis[HMI_ROTATION_PUBLIC_AXIS1].y = axis[HMI_ROTATION_PUBLIC_AXIS1].y/FB_SY;  axis[HMI_ROTATION_PUBLIC_AXIS1].z = (axis[HMI_ROTATION_PUBLIC_AXIS1].z/((float_32)(FB_SY))); axis[HMI_ROTATION_PUBLIC_AXIS2].x = axis[HMI_ROTATION_PUBLIC_AXIS2].x/(FB_SX/2.0f); axis[HMI_ROTATION_PUBLIC_AXIS2].y = axis[HMI_ROTATION_PUBLIC_AXIS2].y/FB_SY;  axis[HMI_ROTATION_PUBLIC_AXIS2].z = (axis[HMI_ROTATION_PUBLIC_AXIS2].z/((float_32)(FB_SY)));  /*get private axis normal vector*/ private_normal_x = axis[HMI_ROTATION_PRIVATE_AXIS].x; private_normal_y = axis[HMI_ROTATION_PRIVATE_AXIS].y; private_normal_z = axis[HMI_ROTATION_PRIVATE_AXIS].z; normal_vec_len = sqrt(private_normal_x*private_normal_x+private_normal_y*private_normal_y+private_normal_z*private_normal_z); if(normal_vec_len > HMI_FLOAT_TOLERANCE) { private_normal_x = private_normal_x/normal_vec_len; private_normal_y = private_normal_y/normal_vec_len; private_normal_z = private_normal_z/normal_vec_len; } else { private_normal_x = 0.0f; private_normal_y = 0.0f; private_normal_z = 1.0f; }  /*get public axis normal vector*/ normal_x = axis[HMI_ROTATION_PUBLIC_AXIS2].x-axis[HMI_ROTATION_PUBLIC_AXIS1].x; normal_y = axis[HMI_ROTATION_PUBLIC_AXIS2].y-axis[HMI_ROTATION_PUBLIC_AXIS1].y; normal_z = axis[HMI_ROTATION_PUBLIC_AXIS2].z-axis[HMI_ROTATION_PUBLIC_AXIS1].z; normal_vec_len = sqrt(normal_x*normal_x+normal_y*normal_y+normal_z*normal_z); if(normal_vec_len > HMI_FLOAT_TOLERANCE) { normal_x = normal_x/normal_vec_len; normal_y = normal_y/normal_vec_len; normal_z = normal_z/normal_vec_len; } else { normal_x = 0.0f; normal_y = 0.0f; normal_z = 1.0f; } }  ang = (INT32)(pcube_str->angel+0.5f); ang = ang%HMI_CIRCLE_ANGEL;  private_ang = (INT32)(pcube_str->private_angel+0.5f); private_ang = private_ang%HMI_CIRCLE_ANGEL; /*set render side*/ side = paxis->attribute&HMI_SURFACE_SIDE_MASK; if(side == HMI_SURFACE_CCW) { R_DRW2D_CtxCullMode(HMI_LOC_DRW2D_DEV, R_DRW2D_CULLMODE_CCW); } else if(side == HMI_SURFACE_CW) { R_DRW2D_CtxCullMode(HMI_LOC_DRW2D_DEV, R_DRW2D_CULLMODE_CW); } else if(side == HMI_SURFACE_DOUBLE_SIDE) { R_DRW2D_CtxCullMode(HMI_LOC_DRW2D_DEV, R_DRW2D_CULLMODE_NONE); } else { R_DRW2D_CtxCullMode(HMI_LOC_DRW2D_DEV, R_DRW2D_CULLMODE_NONE); }  if(R_DRW2D_ERR_OK == ret) { ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTextureTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TEX_TRANSFORM_2D);  ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE); if(R_DRW2D_ERR_OK == ret) { ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_CUSTOM); ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV, R_DRW2D_BLEND_SRC_ALPHA, R_DRW2D_BLEND_ONE_MINUS_SRC_ALPHA, R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE);  if(R_DRW2D_ERR_OK == ret) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Enable antialiasing HMI_Data/ HMI_Source/ HMI_Tool/  ret |= R_DRW2D_CtxImgQuality(HMI_LOC_DRW2D_DEV, R_DRW2D_IMGQUALITY_HIGH); if(R_DRW2D_ERR_OK == ret) { ret |= R_DRW2D_CtxTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TRANSFORM_3D); } } } } /*set window*/  setlocSurface = hmi_get_window(layer); if(setlocSurface != NULL) { locGetRenderTarget(setlocSurface); }   ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect);  if(pcube_textrue != NULL) { hmi_get_cube_texture(pcube_textrue,texture); } if(pcube_str->bump == TRUE) { R_DRW2D_CtxStripingEnable(HMI_LOC_DRW2D_DEV );  set_bump_effect(vecLight); if(pcube_textrue != NULL) { hmi_get_cube_texture(pbump_textrue,bump_texture); } cubeCoords1_4[0].X = R_DRW2D_2X(-(cube_w/2)); cubeCoords1_4[0].Y = R_DRW2D_2X(-(cube_h/2)); cubeCoords1_4[0].Z = R_DRW2D_2X(0.0f); cubeCoords1_4[0].W = R_DRW2D_2X(1.0f);  cubeCoords1_4[1].X = R_DRW2D_2X((cube_w/2)); cubeCoords1_4[1].Y = R_DRW2D_2X(-(cube_h/2)); cubeCoords1_4[1].Z = R_DRW2D_2X(0.0f); cubeCoords1_4[1].W = R_DRW2D_2X(1.0f);  cubeCoords1_4[2].X = R_DRW2D_2X((cube_w/2)); cubeCoords1_4[2].Y = R_DRW2D_2X((cube_h/2)); cubeCoords1_4[2].Z = R_DRW2D_2X(0.0f); cubeCoords1_4[2].W = R_DRW2D_2X(1.0f);  cubeCoords1_4[3].X=R_DRW2D_2X(-(cube_w/2)); cubeCoords1_4[3].Y=R_DRW2D_2X((cube_h/2)); cubeCoords1_4[3].Z=R_DRW2D_2X(0.0f); cubeCoords1_4[3].W=R_DRW2D_2X(1.0f);  cubeCoords5_6[0].X = R_DRW2D_2X(-(cube_w/2)); cubeCoords5_6[0].Y = R_DRW2D_2X(-(cube_w/2)); cubeCoords5_6[0].Z = R_DRW2D_2X(0.0f); cubeCoords5_6[0].W = R_DRW2D_2X(1.0f);  cubeCoords5_6[1].X = R_DRW2D_2X((cube_w/2)); cubeCoords5_6[1].Y = R_DRW2D_2X(-(cube_w/2)); cubeCoords5_6[1].Z = R_DRW2D_2X(0.0f); cubeCoords5_6[1].W = R_DRW2D_2X(1.0f);  cubeCoords5_6[2].X = R_DRW2D_2X((cube_w/2)); cubeCoords5_6[2].Y = R_DRW2D_2X((cube_w/2)); cubeCoords5_6[2].Z = R_DRW2D_2X(0.0f); cubeCoords5_6[2].W = R_DRW2D_2X(1.0f);  cubeCoords5_6[3].X=R_DRW2D_2X(-(cube_w/2)); cubeCoords5_6[3].Y=R_DRW2D_2X((cube_w/2)); cubeCoords5_6[3].Z=R_DRW2D_2X(0.0f); cubeCoords5_6[3].W=R_DRW2D_2X(1.0f); }  /************************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr face 6 */ if(cubeMask & (1<<6) ) { R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV);  loc_setFrustrumMatrix();  if(rotation_axis == HMI_CUBE_ROTATION_PRESET1) { R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(zTrans) );  R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(0.0f) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(ang) );  R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(90.0f) );   R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), -R_DRW2D_2X(ang) );  R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-cube_w/2.0)); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(180.0));  R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-cube_w)); } else if(rotation_axis == HMI_CUBE_ROTATION_USERDEFINE) {  #if 0 /*translate,rotate to cube center*/ R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(90.0f) );  R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-cube_w/2.0)); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(180.0)); #endif  /*translate userdefine point*/ R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(zTrans) ); if(ang !=0) {  pos_to_public1_x = axis[HMI_ROTATION_PUBLIC_AXIS1].x-cube_x; pos_to_public1_y = axis[HMI_ROTATION_PUBLIC_AXIS1].y-cube_y; pos_to_public1_z = axis[HMI_ROTATION_PUBLIC_AXIS1].z-zTrans; R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(pos_to_public1_x), R_DRW2D_2X(pos_to_public1_y), R_DRW2D_2X(pos_to_public1_z) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(normal_x), R_DRW2D_2X(normal_y), R_DRW2D_2X(normal_z), R_DRW2D_2X(ang) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(-pos_to_public1_x), R_DRW2D_2X(-pos_to_public1_y), R_DRW2D_2X(-pos_to_public1_z) ); } if(private_ang != 0) { R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(private_normal_x), R_DRW2D_2X(private_normal_y), R_DRW2D_2X(private_normal_z), R_DRW2D_2X(private_ang) ); }  R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(-90.0f) ); if(cubeMask != 2)/* cube,not one face.the private axis at center of cube*/ { R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-cube_h/2.0)); } } else { }  if(pcube_str->bump != TRUE)  { if((texture[5].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[5]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xccffffffu); clip_index = 0; next_clip_index = HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_DrawRectUV(HMI_LOC_DRW2D_DEV, &cube_rect5_6, uvcoords1); } clip_index++; next_clip_index ++; }  } } else { if((texture[5].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[5]);  if((bump_texture[5].Buffer.Data)!=NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 1u, &bump_texture[5]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xccffffffu); effect_stages[0].Args[1].Param.Color.Source.ConstantColor = SetupLightPara(vecLight); R_DRW2D_CtxEffectsSet(HMI_LOC_DRW2D_DEV, effect_stages,2);  } next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |=R_DRW2D_DrawQuads3dUV(HMI_LOC_DRW2D_DEV,cubeCoords5_6,4,&locEdgeFlags , uvcoords1); } clip_index++; next_clip_index ++; }  R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); } } }  /************************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr face 5 */  if (cubeMask & (1<<5) ) { R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV);  loc_setFrustrumMatrix();  if(rotation_axis == HMI_CUBE_ROTATION_PRESET1) { R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(zTrans) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(0.0f) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(ang) );  R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(90.0f) );  R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), -R_DRW2D_2X(ang) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-(cube_w/2.0))); }  else if(rotation_axis == HMI_CUBE_ROTATION_USERDEFINE) { #if 0 /*translate,rotate to center of cube*/ R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(90.0f) ); #endif /*translate userdefine point*/ R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(zTrans) ); if(ang !=0) {  pos_to_public1_x = axis[HMI_ROTATION_PUBLIC_AXIS1].x-cube_x; pos_to_public1_y = axis[HMI_ROTATION_PUBLIC_AXIS1].y-cube_y; pos_to_public1_z = axis[HMI_ROTATION_PUBLIC_AXIS1].z-zTrans; R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(pos_to_public1_x), R_DRW2D_2X(pos_to_public1_y), R_DRW2D_2X(pos_to_public1_z) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(normal_x), R_DRW2D_2X(normal_y), R_DRW2D_2X(normal_z), R_DRW2D_2X(ang) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(-pos_to_public1_x), R_DRW2D_2X(-pos_to_public1_y), R_DRW2D_2X(-pos_to_public1_z) ); } if(private_ang != 0) { R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(private_normal_x), R_DRW2D_2X(private_normal_y), R_DRW2D_2X(private_normal_z), R_DRW2D_2X(private_ang) ); }  R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(90) ); if(cubeMask != 2)/* cube,not one face.the private axis at center of cube*/ { R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-cube_h/2.0)); }  } else { }  if(pcube_str->bump!=TRUE) { if((texture[4].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[4]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xccff00ffu); clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_DrawRectUV(HMI_LOC_DRW2D_DEV, &cube_rect5_6, uvcoords3); } clip_index++; next_clip_index ++; }   } } else { if((texture[4].Buffer.Data)!=NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[4]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xccff00ffu);  if((bump_texture[4].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 1u, &bump_texture[4]); effect_stages[0].Args[1].Param.Color.Source.ConstantColor = SetupLightPara(vecLight); R_DRW2D_CtxEffectsSet(HMI_LOC_DRW2D_DEV, effect_stages,2);  } clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |=R_DRW2D_DrawQuads3dUV(HMI_LOC_DRW2D_DEV,cubeCoords5_6,4,&locEdgeFlags , uvcoords3); } clip_index++; next_clip_index ++; }  R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); } } }  /************************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr face 1 */ if (cubeMask & (1<<1) )  { R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); loc_setFrustrumMatrix();  if(rotation_axis == HMI_CUBE_ROTATION_PRESET1) {  R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(zTrans) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(0.0f) );  R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(ang) );  R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(ang) );  R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-cube_w/2.0));  } else if(rotation_axis == HMI_CUBE_ROTATION_USERDEFINE) {  //zTrans=1.0; R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(zTrans) );  if(ang !=0) {  pos_to_public1_x = axis[HMI_ROTATION_PUBLIC_AXIS1].x-cube_x; pos_to_public1_y = axis[HMI_ROTATION_PUBLIC_AXIS1].y-cube_y; pos_to_public1_z = axis[HMI_ROTATION_PUBLIC_AXIS1].z-zTrans; R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(pos_to_public1_x), R_DRW2D_2X(pos_to_public1_y), R_DRW2D_2X(pos_to_public1_z) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(normal_x), R_DRW2D_2X(normal_y), R_DRW2D_2X(normal_z), R_DRW2D_2X(ang) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(-pos_to_public1_x), R_DRW2D_2X(-pos_to_public1_y), R_DRW2D_2X(-pos_to_public1_z) ); } if(private_ang != 0) { R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(private_normal_x), R_DRW2D_2X(private_normal_y), R_DRW2D_2X(private_normal_z), R_DRW2D_2X(private_ang) ); }  if(cubeMask != 2)/* cube,not one face.the private axis at center of cube*/ { R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-cube_w/2.0)); }  } else { ; }  if(pcube_str->bump != TRUE) { if((texture[0].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[0]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xccffff00u); clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_DrawRectUV(HMI_LOC_DRW2D_DEV, &cube_rect1_4, uvcoords1); } clip_index++; next_clip_index ++; }   } } else { if((texture[0].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[0]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xccffff00u); if((bump_texture[0].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 1u, &bump_texture[0]); effect_stages[0].Args[1].Param.Color.Source.ConstantColor = SetupLightPara(vecLight); R_DRW2D_CtxEffectsSet(HMI_LOC_DRW2D_DEV, effect_stages,2); } clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |=R_DRW2D_DrawQuads3dUV(HMI_LOC_DRW2D_DEV,cubeCoords1_4,4,&locEdgeFlags , uvcoords2); } clip_index++; next_clip_index ++; }  R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); } } }  /************************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr face 2 */ if (cubeMask & (1<<2) ) { R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); loc_setFrustrumMatrix();  if(rotation_axis == HMI_CUBE_ROTATION_PRESET1) { R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(-180.0f) );  R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(zTrans) );  R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(-cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(0.0f) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(ang) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), -R_DRW2D_2X(ang) );  R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(cube_w/2.0)); } else if(rotation_axis == HMI_CUBE_ROTATION_USERDEFINE) { #if 0 /*translate,rotate to cube center*/ R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(-180.0f) ); #endif  /*translate userdefine point*/ R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(zTrans) ); if(ang !=0) {  pos_to_public1_x = axis[HMI_ROTATION_PUBLIC_AXIS1].x-cube_x; pos_to_public1_y = axis[HMI_ROTATION_PUBLIC_AXIS1].y-cube_y; pos_to_public1_z = axis[HMI_ROTATION_PUBLIC_AXIS1].z-zTrans; R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(pos_to_public1_x), R_DRW2D_2X(pos_to_public1_y), R_DRW2D_2X(pos_to_public1_z) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(normal_x), R_DRW2D_2X(normal_y), R_DRW2D_2X(normal_z), R_DRW2D_2X(ang) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(-pos_to_public1_x), R_DRW2D_2X(-pos_to_public1_y), R_DRW2D_2X(-pos_to_public1_z) ); } if(private_ang != 0) { R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(private_normal_x), R_DRW2D_2X(private_normal_y), R_DRW2D_2X(private_normal_z), R_DRW2D_2X(private_ang) ); }  /*translate,rotate to cube center*/ R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(180.0f) );  if(cubeMask != 2)/* cube,not one face.the private axis at center of cube*/ { R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-cube_w/2.0)); }  } else { }  if(pcube_str->bump!=TRUE) { if((texture[1].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[1]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xccff0000u); clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_DrawRectUV(HMI_LOC_DRW2D_DEV, &cube_rect1_4, uvcoords1); } clip_index++; next_clip_index ++; }   } } else { if((texture[1].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[1]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xccff0000u); if((bump_texture[1].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 1u, &bump_texture[1]); effect_stages[0].Args[1].Param.Color.Source.ConstantColor = SetupLightPara(vecLight); R_DRW2D_CtxEffectsSet(HMI_LOC_DRW2D_DEV, effect_stages,2); } clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |=R_DRW2D_DrawQuads3dUV(HMI_LOC_DRW2D_DEV,cubeCoords1_4,4,&locEdgeFlags , uvcoords2); } clip_index++; next_clip_index ++; }  R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); } } }  /************************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr face 3 */  if (cubeMask & (1<<3) ) { R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); loc_setFrustrumMatrix();  if(rotation_axis == HMI_CUBE_ROTATION_PRESET1) { R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(zTrans) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(0.0f) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(ang + 90.0f) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(ang) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-(cube_w/2.0))); } else if(rotation_axis == HMI_CUBE_ROTATION_USERDEFINE) {  /*translate userdefine point*/ R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(zTrans) ); if(ang !=0) {  pos_to_public1_x = axis[HMI_ROTATION_PUBLIC_AXIS1].x-cube_x; pos_to_public1_y = axis[HMI_ROTATION_PUBLIC_AXIS1].y-cube_y; pos_to_public1_z = axis[HMI_ROTATION_PUBLIC_AXIS1].z-zTrans; R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(pos_to_public1_x), R_DRW2D_2X(pos_to_public1_y), R_DRW2D_2X(pos_to_public1_z) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(normal_x), R_DRW2D_2X(normal_y), R_DRW2D_2X(normal_z), R_DRW2D_2X(ang) );  R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(-pos_to_public1_x), R_DRW2D_2X(-pos_to_public1_y), R_DRW2D_2X(-pos_to_public1_z) ); } if(private_ang != 0) { R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(private_normal_x), R_DRW2D_2X(private_normal_y), R_DRW2D_2X(private_normal_z), R_DRW2D_2X(private_ang) ); } R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(90.0f) ); if(cubeMask != 2)/* cube,not one face.the private axis at center of cube*/ { R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-cube_w/2.0)); }  } else { }  if(pcube_str->bump != TRUE) { if((texture[2].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[2]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xcc00ff00u); clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_DrawRectUV(HMI_LOC_DRW2D_DEV, &cube_rect1_4, uvcoords1); } clip_index++; next_clip_index ++; }   } } else { if((texture[2].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[2]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xcc00ff00u); if((bump_texture[2].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 1u, &bump_texture[2]); effect_stages[0].Args[1].Param.Color.Source.ConstantColor = SetupLightPara(vecLight); R_DRW2D_CtxEffectsSet(HMI_LOC_DRW2D_DEV, effect_stages,2);  } clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |=R_DRW2D_DrawQuads3dUV(HMI_LOC_DRW2D_DEV,cubeCoords1_4,4,&locEdgeFlags , uvcoords1); } clip_index++; next_clip_index ++; }  R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); } } }  /************************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr face 4 */  if (cubeMask & (1<<4) ) { R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); loc_setFrustrumMatrix();  if(rotation_axis == HMI_CUBE_ROTATION_PRESET1) { R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(-180.0f) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(zTrans) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(-cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(0.0f) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(ang + 90.0f) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), -R_DRW2D_2X(ang) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(cube_w/2.0)); } else if(rotation_axis == HMI_CUBE_ROTATION_USERDEFINE) { #if 0 R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(-180.0f) );  #endif /*translate userdefine point*/ R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(cube_x), R_DRW2D_2X(cube_y), R_DRW2D_2X(zTrans) ); if(ang !=0) {  pos_to_public1_x = axis[HMI_ROTATION_PUBLIC_AXIS1].x-cube_x; pos_to_public1_y = axis[HMI_ROTATION_PUBLIC_AXIS1].y-cube_y; pos_to_public1_z = axis[HMI_ROTATION_PUBLIC_AXIS1].z-zTrans; R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(pos_to_public1_x), R_DRW2D_2X(pos_to_public1_y), R_DRW2D_2X(pos_to_public1_z) ); R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(normal_x), R_DRW2D_2X(normal_y), R_DRW2D_2X(normal_z), R_DRW2D_2X(ang) ); R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(-pos_to_public1_x), R_DRW2D_2X(-pos_to_public1_y), R_DRW2D_2X(-pos_to_public1_z) ); } if(private_ang != 0) { R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(private_normal_x), R_DRW2D_2X(private_normal_y), R_DRW2D_2X(private_normal_z), R_DRW2D_2X(private_ang) ); } R_DRW2D_CtxRotate3d(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0.0f), R_DRW2D_2X(1.0f), R_DRW2D_2X(0.0f), R_DRW2D_2X(-90.0f) ); if(cubeMask != 2)/* cube,not one face.the private axis at center of cube*/ { R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, 0, 0, R_DRW2D_2X(-cube_w/2.0)); }  } else { }  if(pcube_str->bump != TRUE) { if((texture[3].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[3]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xcc0000ffu); clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |=R_DRW2D_DrawRectUV(HMI_LOC_DRW2D_DEV, &cube_rect1_4, uvcoords1); } clip_index++; next_clip_index ++; }   } } else { if((texture[3].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0u, &texture[3]); R_DRW2D_CtxFgColor(HMI_LOC_DRW2D_DEV, 0xcc0000ffu); if((bump_texture[3].Buffer.Data) != NULL) { R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 1u, &bump_texture[3]); effect_stages[0].Args[1].Param.Color.Source.ConstantColor = SetupLightPara(vecLight); R_DRW2D_CtxEffectsSet(HMI_LOC_DRW2D_DEV, effect_stages,2); } clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |=R_DRW2D_DrawQuads3dUV(HMI_LOC_DRW2D_DEV,cubeCoords1_4,4,&locEdgeFlags ,uvcoords3); } clip_index++; next_clip_index ++; }  R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); } } } R_DRW2D_CtxViewport(HMI_LOC_DRW2D_DEV,&viewport_rect); if(pcube_str->bump == TRUE) { R_DRW2D_CtxStripingDisable(HMI_LOC_DRW2D_DEV ); } } } #endif  void call_C_hmi_driver_draw_scrollbar(HMI_RECT_STR CONST *pscreen_target,  HMI_IMAGE_ATTR_STR img_compress,  HMI_RANGE_STR cur_range, HMI_RECT_STR *pclip_rect, HMI_RECT_STR *pdirty_rect, HMI_SCROLL_BAR_STR *phmi_scrollbar_prop, UINT8 layer, HMI_OBJECT_ID_STR hmi_object_id #ifdef HMI_GRAPHIC_RGL ,UINT8 father_alpha #endif ) { r_drw2d_Error_t ret = R_DRW2D_ERR_OK;  void hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml setlocSurface; r_drw2d_Rect_t dst_rect={{0,0},{0,0}}; r_drw2d_Rect_t src_rect={{0,0},{0,0}}; r_drw2d_IntRect_t clip_rect={{0,0},{0,0}};  r_drw2d_Texture_t texture;   HMI_RECT_STR scrollbar_copy_rect = {0,0,0,0}; HMI_RECT_STR image_draw_rect = {0,0,0,0}; HMI_RANGE_STR maxFrame = 0; UINT8 loop = 0;  UINT8 numberOFFrame = 0; HMI_WIDTH_STR image_w = 0; rgl_image_type_str bmp_compress = HMI_IMAGE_NO_COMPRESS;  HMI_RECT_STR hmi_disp_target = {0,0,0,0}; UINT8 bmp_alpha_flag = ((img_compress.image_attr)&0xf0); BOOLEAN rotation = FALSE; UINT8 alpha = FALSE; UINT8 clip_index = 0; UINT8 next_clip_index = 0; HMI_RECT_STR hmi_min_dirty_rect = {0,0,0,0}; bmp_compress = get_compress_fmt(img_compress); rotation = bmp_alpha_flag&HMI_ROTATION_IMAGE_FLAG; alpha = bmp_alpha_flag&HMI_ALPHA_IMAGE_FLAG;  if((pscreen_target !=NULL)&&(pclip_rect !=NULL)&& (phmi_scrollbar_prop !=NULL)&&(bmp_compress == HMI_IMAGE_NO_COMPRESS)) { #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret = R_DRW2D_CtxImgQuality(HMI_LOC_DRW2D_DEV, R_DRW2D_IMGQUALITY_MEDIUM); #endif if(R_DRW2D_ERR_OK == ret) { ret |= R_DRW2D_CtxTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TRANSFORM_2D); } if((hmi_layer_info[layer] == HMI_LAYER_BUFFER)|| (hmi_layer_info[layer] == HMI_LAYER_VIDEOIN)) { /*set window*/ setlocSurface = hmi_get_window(layer); locGetRenderTarget(setlocSurface); hmi_disp_target.x = pscreen_target->x; hmi_disp_target.y = pscreen_target->y; hmi_disp_target.w = pscreen_target->w; hmi_disp_target.h = pscreen_target->h; /*convert screen coordinate to layer coordinate*/ hmi_disp_target.x -= locSurface_rect[layer].x; hmi_disp_target.y -= locSurface_rect[layer].y;  /*reset status*/ ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TRANSFORM_2D); ret |= R_DRW2D_CtxTextureTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TEX_TRANSFORM_2D);  /*get texture*/  get_texture_res_manager(hmi_object_id, &texture, (uint8_t *)(phmi_scrollbar_prop->file.pbitmap_data), phmi_scrollbar_prop->file.data_len, phmi_scrollbar_prop->file.w, phmi_scrollbar_prop->file.h, rotation, bmp_compress, alpha, 0); if(texture.Buffer.Data != 0) {  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set Blend */ #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_CUSTOM/*R_DRW2D_BLENDMODE_SRC_OVER*/);  ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV, R_DRW2D_BLEND_SRC_ALPHA, R_DRW2D_BLEND_ONE_MINUS_SRC_ALPHA, R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE  ); #else ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_SRC_OVER);  #endif /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set texture */ ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE); ret |= R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0, &texture);   /*scroll*/ numberOFFrame = (phmi_scrollbar_prop->property & HMI_BEGIN_USED)?(numberOFFrame+1):numberOFFrame; numberOFFrame = (phmi_scrollbar_prop->property & HMI_FULL_USED)?(numberOFFrame+1):numberOFFrame; numberOFFrame = (phmi_scrollbar_prop->property & HMI_CURVALUE_USED)?(numberOFFrame+1):numberOFFrame; numberOFFrame = (phmi_scrollbar_prop->property & HMI_EMPTY_USED)?(numberOFFrame+1):numberOFFrame; numberOFFrame = (phmi_scrollbar_prop->property & HMI_END_USED)?(numberOFFrame+1):numberOFFrame; if(numberOFFrame != 0) { image_w = phmi_scrollbar_prop->file.w/numberOFFrame;/*added by pxguo*/ } if(phmi_scrollbar_prop->max_range >= phmi_scrollbar_prop->min_range) { maxFrame = phmi_scrollbar_prop->max_range+1-phmi_scrollbar_prop->min_range; } if(phmi_scrollbar_prop->property & HMI_BEGIN_USED) { maxFrame += 1; } if(phmi_scrollbar_prop->property & HMI_END_USED) { maxFrame+=1; } scrollbar_copy_rect.x = hmi_disp_target.x; scrollbar_copy_rect.y = hmi_disp_target.y; if(phmi_scrollbar_prop->property & HMI_HORZ_BAR_USED) { if(maxFrame !=0) { scrollbar_copy_rect.w = (hmi_disp_target.w)/maxFrame; } scrollbar_copy_rect.h = hmi_disp_target.h; } else { if(maxFrame !=0) { scrollbar_copy_rect.h = (hmi_disp_target.h)/maxFrame; } scrollbar_copy_rect.w = hmi_disp_target.w; } /*draw begin*/ image_draw_rect.w = image_w; image_draw_rect.h = phmi_scrollbar_prop->file.h; if(phmi_scrollbar_prop->property & HMI_BEGIN_USED) {  image_draw_rect.x = 0; image_draw_rect.y = 0;  convertRect2RectRGL(&image_draw_rect,&src_rect,TRUE/*fix point*/); convertRect2RectRGL(&scrollbar_copy_rect,&dst_rect,TRUE/*fix point*/); clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV, &src_rect,&dst_rect); } clip_index++; next_clip_index ++; }  if(phmi_scrollbar_prop->property & HMI_HORZ_BAR_USED) { scrollbar_copy_rect.x += scrollbar_copy_rect.w; } else { scrollbar_copy_rect.y += scrollbar_copy_rect.h; } image_draw_rect.x += image_draw_rect.w; } /*draw full bar*/ if(phmi_scrollbar_prop->property & HMI_FULL_USED) {  convertRect2RectRGL(&image_draw_rect,&src_rect,TRUE/*fix point*/); for(loop=phmi_scrollbar_prop->min_range;loop < cur_range;loop++) {  convertRect2RectRGL(&scrollbar_copy_rect,&dst_rect,TRUE/*fix point*/); clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV, &src_rect,&dst_rect); } clip_index++; next_clip_index ++; }  if(phmi_scrollbar_prop->property & HMI_HORZ_BAR_USED) { scrollbar_copy_rect.x+=scrollbar_copy_rect.w; } else { scrollbar_copy_rect.y+=scrollbar_copy_rect.h; } } image_draw_rect.x += image_draw_rect.w; } /*draw draw current value*/ if(phmi_scrollbar_prop->property & HMI_CURVALUE_USED) {  convertRect2RectRGL(&image_draw_rect,&src_rect,TRUE/*fix point*/); convertRect2RectRGL(&scrollbar_copy_rect,&dst_rect,TRUE/*fix point*/); clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV, &src_rect,&dst_rect); } clip_index++; next_clip_index ++; }  if(phmi_scrollbar_prop->property & HMI_HORZ_BAR_USED) { scrollbar_copy_rect.x += scrollbar_copy_rect.w; } else { scrollbar_copy_rect.y += scrollbar_copy_rect.h; }  image_draw_rect.x += image_draw_rect.w; } /*draw empty */ if(phmi_scrollbar_prop->property & HMI_EMPTY_USED) { convertRect2RectRGL(&image_draw_rect,&src_rect,TRUE/*fix point*/); cur_range += 1; for(loop=cur_range;loop<=phmi_scrollbar_prop->max_range;loop++) {  convertRect2RectRGL(&scrollbar_copy_rect,&dst_rect,TRUE/*fix point*/); clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV, &src_rect,&dst_rect); } clip_index++; next_clip_index ++; }  if(phmi_scrollbar_prop->property & HMI_HORZ_BAR_USED) { scrollbar_copy_rect.x += scrollbar_copy_rect.w; }  else { scrollbar_copy_rect.y += scrollbar_copy_rect.h; } } image_draw_rect.x += image_draw_rect.w; }  /*draw end */ if(phmi_scrollbar_prop->property & HMI_END_USED) { convertRect2RectRGL(&image_draw_rect,&src_rect,TRUE/*fix point*/); convertRect2RectRGL(&scrollbar_copy_rect,&dst_rect,TRUE/*fix point*/); clip_index = 0; next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV, &src_rect,&dst_rect); } clip_index++; next_clip_index ++; }  if(phmi_scrollbar_prop->property & HMI_HORZ_BAR_USED) { scrollbar_copy_rect.x += scrollbar_copy_rect.w; } else { scrollbar_copy_rect.y+=scrollbar_copy_rect.h; } image_draw_rect.x += image_draw_rect.w; } /*error*/  if (R_DRW2D_ERR_OK != ret) { loc_Error_hmi(ret); } } } loc_IncMsgCount(HMI_LOC_VOVIAL_UNIT); ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); } }  void call_C_hmi_driver_draw_imagelist(HMI_RECT_STR CONST *pscreen_target, HMI_IMAGE_ATTR_STR img_compress, HMI_RECT_ALPHA_STR *palpha_pos_angel,  HMI_IMAGE_LIST_STR CONST *phmi_imagelist_prop, HMI_RANGE_STR index, HMI_RECT_STR *pclip_rect, HMI_RECT_STR *pdirty_rect, UINT8 layer, HMI_OBJECT_ID_STR hmi_object_id #ifdef HMI_GRAPHIC_RGL ,UINT8 father_alpha #endif ) { void hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml setlocSurface = NULL; r_drw2d_Error_t ret = R_DRW2D_ERR_OK;  r_drw2d_Rect_t dst_rect = {{0,0},{0,0}}; r_drw2d_Rect_t src_rect = {{0,0},{0,0}}; r_drw2d_IntRect_t clip_rect = {{0,0},{0,0}};  r_drw2d_Texture_t texture;   UINT16 image_width = 0; HMI_RECT_STR imagelist_copy_rect = {0,0,0,0}; rgl_image_type_str bmp_compress = HMI_IMAGE_NO_COMPRESS; HMI_RECT_STR hmi_disp_target = {0,0,0,0}; UINT8 image_alpha = HMI_OPAQUE; UINT8 bmp_alpha_flag = ((img_compress.image_attr)&0xf0);  BOOLEAN rotation = FALSE; UINT8 alpha = FALSE; HMI_RECT_ALPHA_ANGEL_STR hmi_alpha_pos_angel ={0}; UINT8 clip_index = 0; UINT8 next_clip_index = 0; HMI_RECT_STR hmi_min_dirty_rect = {0,0,0,0};  bmp_compress = get_compress_fmt(img_compress); rotation = bmp_alpha_flag&HMI_ROTATION_IMAGE_FLAG; alpha = bmp_alpha_flag&HMI_ALPHA_IMAGE_FLAG; if((pscreen_target != NULL)&&(palpha_pos_angel != NULL)&& (phmi_imagelist_prop !=NULL)&&(pclip_rect !=NULL)&& (bmp_compress == HMI_IMAGE_NO_COMPRESS)) {  hmi_disp_target.x = pscreen_target->x; hmi_disp_target.y = pscreen_target->y; hmi_disp_target.w = pscreen_target->w; hmi_disp_target.h = pscreen_target->h; /*sub layer x,y offset*/ hmi_disp_target.x -= locSurface_rect[layer].x; hmi_disp_target.y -= locSurface_rect[layer].y; #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret = R_DRW2D_CtxImgQuality(HMI_LOC_DRW2D_DEV, R_DRW2D_IMGQUALITY_MEDIUM); #endif if(R_DRW2D_ERR_OK == ret) { ret |= R_DRW2D_CtxTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TRANSFORM_2D); }  if((hmi_layer_info[layer] == HMI_LAYER_BUFFER)|| (hmi_layer_info[layer] == HMI_LAYER_VIDEOIN)) { /*set window*/ setlocSurface = hmi_get_window(layer); locGetRenderTarget(setlocSurface); /*reset status*/ ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTextureTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TEX_TRANSFORM_2D);  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV,&clip_rect); /*get texture*/  get_texture_res_manager(hmi_object_id, &texture, (uint8_t *)(phmi_imagelist_prop->file.pbitmap_data), phmi_imagelist_prop->file.data_len, phmi_imagelist_prop->file.w, phmi_imagelist_prop->file.h, rotation, bmp_compress, alpha, 0); if(texture.Buffer.Data !=NULL) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set texture HMI_Data/ HMI_Source/ HMI_Tool/  #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_CUSTOM); ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV, R_DRW2D_BLEND_SRC_ALPHA, R_DRW2D_BLEND_ONE_MINUS_SRC_ALPHA, R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE  ); #else ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_SRC_OVER);  #endif ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE); ret |= R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0, &texture);  if(father_alpha > palpha_pos_angel->alpha) { image_alpha = palpha_pos_angel->alpha; } else { image_alpha = father_alpha; } if(image_alpha != HMI_OPAQUE) { set_alpha_effect(image_alpha); }  /*draw imagelist*/ if(index < phmi_imagelist_prop->list_len) { image_width = (phmi_imagelist_prop->file.w)/(phmi_imagelist_prop->list_len); imagelist_copy_rect.x = image_width*index; imagelist_copy_rect.y = 0; imagelist_copy_rect.w = image_width; imagelist_copy_rect.h = phmi_imagelist_prop->file.h; convertRect2RectRGL(&imagelist_copy_rect,&src_rect,TRUE/*fix point*/); convertRect2RectRGL(&hmi_disp_target,&dst_rect,TRUE/*fix point*/); next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_TextureBlit(HMI_LOC_DRW2D_DEV, &src_rect,&dst_rect); } clip_index++; next_clip_index ++; } ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); /*error*/  if (R_DRW2D_ERR_OK != ret) { loc_Error_hmi(ret); } loc_IncMsgCount(HMI_LOC_VOVIAL_UNIT); } } } else if(hmi_layer_info[layer] == HMI_LAYER_SPRITE) {  get_texture_res_manager( hmi_object_id, &texture, (uint8_t *)(phmi_imagelist_prop->file.pbitmap_data), phmi_imagelist_prop->file.data_len, phmi_imagelist_prop->file.w, phmi_imagelist_prop->file.h, rotation, bmp_compress, alpha, 0); if(texture.Buffer.Data !=NULL) { if(index<phmi_imagelist_prop->list_len) { image_width = (phmi_imagelist_prop->file.w)/(phmi_imagelist_prop->list_len); imagelist_copy_rect.x = hmi_disp_target.x; imagelist_copy_rect.y = hmi_disp_target.y; imagelist_copy_rect.w = image_width; imagelist_copy_rect.h = phmi_imagelist_prop->file.h; hmi_disp_target.x = hmi_disp_target.x-index*image_width; hmi_alpha_pos_angel.x = palpha_pos_angel->x; hmi_alpha_pos_angel.y = palpha_pos_angel->y; hmi_alpha_pos_angel.w = palpha_pos_angel->w; hmi_alpha_pos_angel.h = palpha_pos_angel->h; hmi_alpha_pos_angel.alpha= palpha_pos_angel->alpha; hmi_alpha_pos_angel.angel= 0; hmi_alpha_pos_angel.attr= 0; hmi_draw_SpriteSurface((void*)texture.Buffer.Data, hmi_disp_target.x, hmi_disp_target.y, phmi_imagelist_prop->file.w, phmi_imagelist_prop->file.h, layer, hmi_object_id, imagelist_copy_rect, &hmi_alpha_pos_angel, father_alpha ); } } } else { } } }  /* disable sprite */ void off_all_sprite(UINT8 layer_index) { UINT32 index = 0;  if((hmi_layer_info[layer_index] == HMI_LAYER_SPRITE)&& (locSurface[layer_index] != NULL)) { layer_index = layer_index -1; if(layer_index < HMI_MAX_SPRITE_LAYER) { for(index = 0;index < HMI_MAX_SPRITE_NB;index++) { if(hmi_sprite_list[layer_index][index].hmi_sprite.Data != NULL) { hmi_qd_disablesprite(&hmi_sprite_list[layer_index][index].hmi_sprite); } } } }  } #if USE_V2_HMI_SDK  void off_sprite(HMI_RECT_STR *pdirty_zone)  { UINT32 index = 0U; UINT8 layer_index = 0U; UINT8 sprite_layer_nb = 0U; UINT8 sprite_enable_nb = 0U; UINT8 sprite_display_nb = 0U; hmi_qd_Sprite_t *pimage_sprite = NULL; HMI_X_STR x = 0;  HMI_Y_STR y = 0; BOOLEAN need_finish = FALSE;  if(pdirty_zone != NULL) { for(layer_index = 1/*sprite 1--3 layer*/;layer_index < HMI_LAYER_MAX_CNT;layer_index++) { if((hmi_layer_info[layer_index] == HMI_LAYER_SPRITE)&& (locSurface[layer_index] != NULL)) { #if 0 if((pdirty_zone[layer_index].x != HMI_INVALID_COOR)&&/*|| lq modify*/ (pdirty_zone[layer_index].y != HMI_INVALID_COOR))  #endif if((pdirty_zone[layer_index].w != 0U)&&/*|| lq modify*/ (pdirty_zone[layer_index].h != 0U))  { sprite_layer_nb = layer_index - 1; sprite_enable_nb = 0U; /*get enable numble*/ for(index = 0;index < HMI_MAX_SPRITE_NB;index++) { if((hmi_sprite_list[sprite_layer_nb][index].next_status == HMI_QD_SPRITESTATUS_ENABLED)|| (hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Status == HMI_QD_SPRITESTATUS_ENABLED)) { sprite_enable_nb++; }  } /*disable/delete sprite*/ for(index = 0;index < HMI_MAX_SPRITE_NB;index++) { if(hmi_sprite_list[sprite_layer_nb][index].next_status == HMI_QD_SPRITESTATUS_DISABLED) { if(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Data != NULL) { //if(sprite_enable_nb > HMI_ENABLE_SPRITE_NB) { if(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Status != HMI_QD_SPRITESTATUS_DISABLED) { hmi_qd_disablesprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite); } hmi_qd_deletesprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite); need_finish = TRUE;  //R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG); hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Data = NULL; sprite_enable_nb--; } #if 0 else {  if(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Status != HMI_QD_SPRITESTATUS_DISABLED) { hmi_qd_disablesprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite); } } #endif }  } } if(need_finish == TRUE) { #ifdef HMI_R_ASYNCHRONOUS_HW_UPDATE hmi_driver_send_cmdlist_sync(); #else hmi_driver_send_cmdlist();// lq #endif } /*enable sprite*/ sprite_display_nb = 0U; for(index=0;index < HMI_MAX_SPRITE_NB;index++) { if(hmi_sprite_list[sprite_layer_nb][index].next_status == HMI_QD_SPRITESTATUS_ENABLED) { if(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Data != NULL) { if(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Status == HMI_QD_SPRITESTATUS_NOT_INITIALIZED) { if(sprite_display_nb <= HMI_ENABLE_SPRITE_NB) { hmi_qd_createsprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite); //if(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Status == HMI_QD_SPRITESTATUS_DISABLED) { hmi_qd_enablesprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite); } }  } else {  //if(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Status == HMI_QD_SPRITESTATUS_DISABLED) { hmi_qd_enablesprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite);  } } } sprite_display_nb++; } }  } } } } }  #else void off_sprite(HMI_RECT_STR *pdirty_zone)  { UINT32 index = 0; UINT8 layer_index = 0; UINT8 sprite_layer_nb = 0; UINT8 sprite_enable_nb = 0; UINT8 sprite_display_nb = 0; hmi_qd_Sprite_t *pimage_sprite = NULL; HMI_X_STR x = 0;  HMI_Y_STR y = 0; BOOLEAN need_finish = FALSE;  if(pdirty_zone != NULL) { for(layer_index = 1/*sprite 1--3 layer*/;layer_index < HMI_LAYER_MAX_CNT;layer_index++) { if((hmi_layer_info[layer_index] == HMI_LAYER_SPRITE)&& (locSurface[layer_index] != NULL)) { if((pdirty_zone[layer_index].x != HMI_INVALID_COOR)&&/*|| lq modify*/ (pdirty_zone[layer_index].y != HMI_INVALID_COOR))  { /*disable/delete sprite*/ sprite_layer_nb = layer_index-1; /*get enable numble*/ for(index = 0;index < HMI_MAX_SPRITE_NB;index++) { if((hmi_sprite_list[sprite_layer_nb][index].next_status == HMI_QD_SPRITESTATUS_ENABLED)|| (hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Status == HMI_QD_SPRITESTATUS_ENABLED)) { sprite_enable_nb++; }  }  for(index = 0;index < HMI_MAX_SPRITE_NB;index++) { if(hmi_sprite_list[sprite_layer_nb][index].next_status == HMI_QD_SPRITESTATUS_DISABLED) { if(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Data != NULL) { if(sprite_enable_nb > HMI_ENABLE_SPRITE_NB) { hmi_qd_disablesprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite); hmi_qd_deletesprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite); need_finish = TRUE;  //R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG); hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Data = NULL; sprite_enable_nb--; } else { hmi_qd_disablesprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite); } }  } } if(need_finish == TRUE) { hmi_driver_send_cmdlist(); } /*enable sprite*/ sprite_display_nb = 0; for(index=0;index < HMI_MAX_SPRITE_NB;index++) { if(hmi_sprite_list[sprite_layer_nb][index].next_status == HMI_QD_SPRITESTATUS_ENABLED) { if(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Data != NULL) { if(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite.Status == HMI_QD_SPRITESTATUS_NOT_INITIALIZED) { if(sprite_display_nb <= HMI_ENABLE_SPRITE_NB) { hmi_qd_createsprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite); hmi_qd_enablesprite(&hmi_sprite_list[sprite_layer_nb][index].hmi_sprite); //sprite_display_nb++; } } else {  pimage_sprite = (&(hmi_sprite_list[sprite_layer_nb][index].hmi_sprite)); x = pimage_sprite->PosX; y = pimage_sprite->PosY; hmi_MoveSprite(pimage_sprite,x,y,0); hmi_qd_enablesprite(pimage_sprite);  } } sprite_display_nb++; } }  } } } } } #endif void call_C_hmi_driver_refresh_LCD(HMI_RECT_STR *pdirty_zone) { off_sprite(pdirty_zone);/*disable sprite( not used) for dyn container*/  hmi_driver_swap_buffer(pdirty_zone); hmi_driver_send_cmdlist(); }  #if 0 void hmi_driver_get_nextFrame(void)  {  } #endif   void hmi_driver_send_cmdlist(void) {  R_WM_FrameEndMark(HMI_LOC_VOVIAL_UNIT, 0); R_WM_FrameWait(HMI_LOC_VOVIAL_UNIT, 0); }   void hmi_driver_swap_buffer(HMI_RECT_STR *pdirty_zone) {  #if (HMI_BUFFER_NUMBER==HMI_TWO_BUFFER) uint32_t i = 0; #endif if((HMI_GFX_GET_STATUS(HMI_SEND_EVENT))&&  (pdirty_zone != NULL)&& (hmi_driver_woking_status_flag == HMI_FRAMEBUFFER_FREE)) { hmi_driver_woking_status_flag = HMI_FRAMEBUFFER_BUSY;/*frame buffer busy flag*/ //HMI_GFX_CLEAR_STATUS(HMI_SEND_EVENT); R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV, HMI_GPU_FINISH_FLAG); #if (HMI_BUFFER_NUMBER==HMI_TWO_BUFFER) if(pdirty_zone != NULL) {  for(i=0;i < HMI_LAYER_MAX_CNT;i++)  { if(hmi_layer_info[i] == HMI_LAYER_BUFFER) { if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != 0) { hmi_qd_swapframebuffer(locSurface[i], i);  } } } else if(hmi_layer_info[i] == HMI_LAYER_VIDEOIN) { if((layer_video_element[i]) != NULL) { if((*layer_video_element[i])&HMI_VIDEO_ENABLE_STATUS) {  /*Capture video enable,not swap buffer*/ }  else /*only after capture video disable ,can swap buffer*/ { if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != 0) { hmi_qd_swapframebuffer(locSurface[i], i);  } } }  } else /*not capture video container*/ { if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != 0) { hmi_qd_swapframebuffer(locSurface[i], i);  } } } } else { ; } }  }  #endif hmi_driver_woking_status_flag = HMI_FRAMEBUFFER_FREE;/*frame buffer free flag*/ }  }   #if 0 BOOLEAN free_jpg_buffer_res_manager(void) { BOOLEAN success = FALSE; U32 max_ticks = 0; U32 max_ticks_index = 0; U32 i = 0;  BOOLEAN find = FALSE; #if HMI_JPG_BITMAPS_NUMBER>0 for(i=0;i < HMI_JPG_BITMAPS_NUMBER;i++) { if((jpg_buffer_tex_manager[i].ticks > max_ticks)&& (jpg_buffer_tex_manager[i].pBuffer != NULL)&& (jpg_buffer_tex_manager[i].ticks > 0)) { max_ticks = jpg_buffer_tex_manager[i].ticks; max_ticks_index = i; find = TRUE; } }  if(find && (max_ticks != 0))/*the buffer not used at one loop*/ { if(jpg_buffer_tex_manager[max_ticks_index].pBuffer != NULL) { R_CDI_Free((uint32_t)(jpg_buffer_tex_manager[max_ticks_index].pBuffer), HMI_LOC_VRAM_HEAP); jpg_buffer_tex_manager[max_ticks_index].pBuffer = NULL; jpg_buffer_tex_manager[max_ticks_index].hmi_object_id = HMI_NB_ELEMENTS; jpg_buffer_tex_manager[max_ticks_index].ticks = 0; success = TRUE; } } #endif return success; } #endif   /* add new jpg buffer to manager */ #if 0 BOOLEAN add_jpg_buffer_res_manager(uint8_t *pjpg_decode_buffer,uint32_t hmi_object_id) { BOOLEAN success = FALSE; BOOLEAN find = FALSE; UINT16 i = 0; UINT16 index = 0; #if HMI_JPG_BITMAPS_NUMBER>0 if((pjpg_decode_buffer != NULL)&&(hmi_object_id != HMI_NB_ELEMENTS)) { for(i=0;(i < HMI_JPG_BITMAPS_NUMBER)&&((!find));i++) { if((jpg_buffer_tex_manager[i].pBuffer==NULL)&& (jpg_buffer_tex_manager[i].hmi_object_id==HMI_NB_ELEMENTS)) { index = i; find = TRUE; } } if(find) { jpg_buffer_tex_manager[index].pBuffer = pjpg_decode_buffer; jpg_buffer_tex_manager[index].hmi_object_id = hmi_object_id; jpg_buffer_tex_manager[index].ticks = 0; success = TRUE; } } #endif return success; } #endif /* get flash data buffer,if the image need rotation,first read the data from flash to memory, if not need rotation,directly used at flash  */  U08 hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_rgl_get_buffer_address(HMI_OBJECT_ID_STR hmi_object_id, U08 *pdata ) { U08 *pvmem = NULL; if(pdata != NULL) {  #if HMI_DXY_IMAGELIST_NUMBER > 0 if(HMI_IS_DYN_IMAGELIST_DXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_IMAGELIST_DXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_DXY_IMAGELIST_NUMBER) { if(res_tex_dxy_imagelist[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_dxy_imagelist[hmi_object_id].pBuffer; res_tex_dxy_imagelist[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { pvmem = pdata; } }  }  else #endif #if HMI_SXY_IMAGELIST_NUMBER>0 if(HMI_IS_DYN_IMAGELIST_SXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_IMAGELIST_SXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_SXY_IMAGELIST_NUMBER) { if(res_tex_sxy_imagelist[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_sxy_imagelist[hmi_object_id].pBuffer; res_tex_sxy_imagelist[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { pvmem = pdata; } }  } else #endif #if HMI_DXY_SCROLLBAR_NUMBER>0 if(HMI_IS_DYN_SCROLLBAR_DXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_SCROLLBAR_DXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_DXY_SCROLLBAR_NUMBER) { if(res_tex_dxy_scrollbar[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_dxy_scrollbar[hmi_object_id].pBuffer; res_tex_dxy_scrollbar[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { pvmem = pdata; } } } else  #endif #if HMI_SXY_SCROLLBAR_NUMBER>0 if(HMI_IS_DYN_SCROLLBAR_SXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_SCROLLBAR_SXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_SXY_SCROLLBAR_NUMBER) { if(res_tex_sxy_scrollbar[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_sxy_scrollbar[hmi_object_id].pBuffer; res_tex_sxy_scrollbar[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { pvmem = pdata; } } } else #endif #if HMI_DXY_BUTTON_NUMBER > 0  if(HMI_IS_DYN_BUTTON_DXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_BUTTON_DXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_DXY_BUTTON_NUMBER) { if(res_tex_dxy_button[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_dxy_button[hmi_object_id].pBuffer; res_tex_dxy_button[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { pvmem = pdata; } }  }  else #endif #if HMI_SXY_BUTTON_NUMBER>0  if(HMI_IS_DYN_BUTTON_SXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_BUTTON_SXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_SXY_BUTTON_NUMBER) { if(res_tex_sxy_button[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_sxy_button[hmi_object_id].pBuffer; res_tex_sxy_button[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { pvmem = pdata; } }  }  else  #endif  #if HMI_DXY_BITMAPS_NUMBER> 0  if(HMI_IS_DYN_XY_BITMAP(hmi_object_id)) {  hmi_object_id = HMI_GET_DYN_XY_BITMAP_INDEX(hmi_object_id ); if(hmi_object_id < HMI_DXY_BITMAPS_NUMBER) { if(res_tex_dxy_bmp[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_dxy_bmp[hmi_object_id].pBuffer; res_tex_dxy_bmp[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { pvmem = pdata; } } } else #endif #if HMI_SXY_BITMAPS_NUMBER > 0 if(HMI_IS_S_XY_BITMAP(hmi_object_id)) {  hmi_object_id = HMI_GET_SXY_BITMAPS_ID_INDEX(hmi_object_id);  if(hmi_object_id < HMI_SXY_BITMAPS_NUMBER) { #if 0 if(res_tex_sxy_bmp[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_sxy_bmp[hmi_object_id].pBuffer; res_tex_sxy_bmp[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else #endif { pvmem = pdata; } }  } else #endif { pvmem = pdata; } } return pvmem; }   U08 hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml hmi_rgl_load_to_vram(HMI_OBJECT_ID_STR hmi_object_id, U08 *pdata/*flash data address*/,  U32 data_len )  { U08 *pvmem = NULL; U08 *ptex_buffer = NULL; if((data_len != 0)&&(pdata != NULL)) {  #if HMI_DXY_IMAGELIST_NUMBER > 0 if(HMI_IS_DYN_IMAGELIST_DXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_IMAGELIST_DXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_DXY_IMAGELIST_NUMBER) { if(res_tex_dxy_imagelist[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_dxy_imagelist[hmi_object_id].pBuffer; res_tex_dxy_imagelist[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { ptex_buffer = hmi_Init2DImg(pdata,data_len); if(ptex_buffer != NULL)  { res_tex_dxy_imagelist[hmi_object_id].pBuffer = ptex_buffer; res_tex_dxy_imagelist[hmi_object_id].pData = pdata; pvmem = ptex_buffer; } else { pvmem = pdata; } } }  }  else #endif #if HMI_SXY_IMAGELIST_NUMBER>0 if(HMI_IS_DYN_IMAGELIST_SXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_IMAGELIST_SXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_SXY_IMAGELIST_NUMBER) { if(res_tex_sxy_imagelist[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_sxy_imagelist[hmi_object_id].pBuffer; res_tex_sxy_imagelist[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { ptex_buffer = hmi_Init2DImg(pdata,data_len); if(ptex_buffer != NULL)  { res_tex_sxy_imagelist[hmi_object_id].pBuffer = ptex_buffer; res_tex_sxy_imagelist[hmi_object_id].pData = pdata; pvmem = ptex_buffer; } else { pvmem = pdata; }  } }  } else #endif #if HMI_DXY_SCROLLBAR_NUMBER>0 if(HMI_IS_DYN_SCROLLBAR_DXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_SCROLLBAR_DXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_DXY_SCROLLBAR_NUMBER) { if(res_tex_dxy_scrollbar[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_dxy_scrollbar[hmi_object_id].pBuffer; res_tex_dxy_scrollbar[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { ptex_buffer = hmi_Init2DImg(pdata,data_len); if(ptex_buffer !=0)  { res_tex_dxy_scrollbar[hmi_object_id].pBuffer = ptex_buffer; res_tex_dxy_scrollbar[hmi_object_id].pData = pdata; pvmem = ptex_buffer; } else { pvmem = pdata; } } } } else  #endif #if HMI_SXY_SCROLLBAR_NUMBER>0 if(HMI_IS_DYN_SCROLLBAR_SXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_SCROLLBAR_SXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_SXY_SCROLLBAR_NUMBER) { if(res_tex_sxy_scrollbar[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_sxy_scrollbar[hmi_object_id].pBuffer; res_tex_sxy_scrollbar[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { ptex_buffer = hmi_Init2DImg(pdata,data_len); if(ptex_buffer != NULL)  { res_tex_sxy_scrollbar[hmi_object_id].pBuffer = ptex_buffer; res_tex_sxy_scrollbar[hmi_object_id].pData = pdata; pvmem = ptex_buffer; } else { pvmem = pdata; } } } } else #endif #if HMI_DXY_BUTTON_NUMBER > 0  if(HMI_IS_DYN_BUTTON_DXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_BUTTON_DXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_DXY_BUTTON_NUMBER) { if(res_tex_dxy_button[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_dxy_button[hmi_object_id].pBuffer; res_tex_dxy_button[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { ptex_buffer = hmi_Init2DImg(pdata,data_len); if(ptex_buffer != NULL)  { res_tex_dxy_button[hmi_object_id].pBuffer = ptex_buffer; res_tex_dxy_button[hmi_object_id].pData = pdata; pvmem = ptex_buffer; } else { pvmem = pdata; } } }  }  else #endif #if HMI_SXY_BUTTON_NUMBER>0  if(HMI_IS_DYN_BUTTON_SXY(hmi_object_id)) { hmi_object_id = HMI_GET_DYN_BUTTON_SXY_ID_INDEX(hmi_object_id); if(hmi_object_id < HMI_SXY_BUTTON_NUMBER) { if(res_tex_sxy_button[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_sxy_button[hmi_object_id].pBuffer; res_tex_sxy_button[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { ptex_buffer = hmi_Init2DImg(pdata,data_len); if(ptex_buffer != NULL)  { res_tex_sxy_button[hmi_object_id].pBuffer = ptex_buffer; res_tex_sxy_button[hmi_object_id].pData = pdata; pvmem = ptex_buffer; } else { pvmem = pdata; } } }  }  else  #endif  #if HMI_DXY_BITMAPS_NUMBER> 0  if(HMI_IS_DYN_XY_BITMAP(hmi_object_id)) {  hmi_object_id = HMI_GET_DYN_XY_BITMAP_INDEX(hmi_object_id ); if(hmi_object_id < HMI_DXY_BITMAPS_NUMBER) { if(res_tex_dxy_bmp[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_dxy_bmp[hmi_object_id].pBuffer; res_tex_dxy_bmp[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { ptex_buffer = hmi_Init2DImg(pdata,data_len); if(ptex_buffer != NULL)  { res_tex_dxy_bmp[hmi_object_id].pBuffer = ptex_buffer; res_tex_dxy_bmp[hmi_object_id].pData = pdata; pvmem = ptex_buffer; } else { pvmem = pdata; } } } } else #endif #if HMI_SXY_BITMAPS_NUMBER > 0 if(HMI_IS_S_XY_BITMAP(hmi_object_id)) {  hmi_object_id = HMI_GET_SXY_BITMAPS_ID_INDEX(hmi_object_id);  if(hmi_object_id < 1/*HMI_SXY_BITMAPS_NUMBER*/) { if(res_tex_sxy_bmp[hmi_object_id].pBuffer != NULL) { pvmem = res_tex_sxy_bmp[hmi_object_id].pBuffer; res_tex_sxy_bmp[hmi_object_id].ticks = 0;/*clear 0,used the texture*/ } else { ptex_buffer= hmi_Init2DImg(pdata,data_len); if(ptex_buffer != NULL)  { res_tex_sxy_bmp[hmi_object_id].pBuffer = ptex_buffer; res_tex_sxy_bmp[hmi_object_id].pData = pdata; pvmem = ptex_buffer; } else { pvmem = pdata; } } }  } else #endif { pvmem = pdata; } } return pvmem; }    U08 hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml get_buffer_res_manager(HMI_OBJECT_ID_STR hmi_object_id, U08 *pdata/*flash data address*/,  U32 data_len )  { U08 *pvmem = NULL; if((data_len != 0)&&(pdata != NULL)) {  #if (HMI_LOAD_SOURCE_MODE == HMI_LOAD_RES_ALL_AT_USED) pvmem = hmi_rgl_load_to_vram(hmi_object_id,pdata,data_len); #else pvmem = hmi_rgl_get_buffer_address(hmi_object_id,pdata); #endif } return pvmem; }  /* get exist jpg decoded buffer,if not exist, malloc buffer for decoding jpg image */ uint8_t *malloc_jpg_buffer(HMI_OBJECT_ID_STR hmi_object_id, U08 *pdata, U32 data_len,BOOLEAN rotation,  U32 width,U32 height) { #if 0 U08 *pvmem = NULL; U08 *pjpg_decode_buff = NULL;  U32 jpg_decode_buffer_len = 0; BOOLEAN free_success = FALSE; U32 stride = 0; U32 i = 0; BOOLEAN find = FALSE;   r_jcua_FrameBuffer_t jpg_frame_buffer; #if HMI_JPG_BITMAPS_NUMBER>0 if(data_len != 0) { /*search alreay exist decode buffer*/ for(i=0;(i < HMI_JPG_BITMAPS_NUMBER)&&(!find);i++) { if((jpg_buffer_tex_manager[i].hmi_object_id == hmi_object_id)&& (jpg_buffer_tex_manager[i].pBuffer != NULL)) { pjpg_decode_buff = jpg_buffer_tex_manager[i].pBuffer; jpg_buffer_tex_manager[i].ticks = 0;/*clear 0,if used*/ find = TRUE; } } if(!find) { /*read jpg image data to buffer if the image is dxy image and need rotation*/ pvmem = get_buffer_res_manager(hmi_object_id,rotation, pdata,data_len); /*decode jpg image to buffer*/ stride = HMI_VIDEO_STRIDE(width)*LOC_BYTE_PER_PIXEL; jpg_decode_buffer_len = stride*height; pjpg_decode_buff = (void*)R_CDI_Alloc(HMI_LOC_VRAM_HEAP, data_len); if(pjpg_decode_buff == NULL) { do { free_success = free_jpg_buffer_res_manager(); pjpg_decode_buff = (void*)R_CDI_Alloc(HMI_LOC_VRAM_HEAP, jpg_decode_buffer_len); }while(free_success && (pjpg_decode_buff == NULL)); } if(pjpg_decode_buff != NULL) { jpg_frame_buffer.Address= pjpg_decode_buff;  jpg_frame_buffer.Size = jpg_decode_buffer_len; jpg_frame_buffer.Stride = 0;//stride; jpg_frame_buffer.Format = R_JCUA_OUTPUT_FORMAT_ARGB8888; jpg_frame_buffer.Swap = R_JCUA_SWAP_LONG; decode_JPG2Mem(&jpg_frame_buffer,width,height,pvmem); add_jpg_buffer_res_manager(pjpg_decode_buff,hmi_object_id);  } else { HMI_GFX_SET_STATUS(HMI_RGL_IMAGE_NOT_ENOUGH_MEM);  } }  } #endif   return pjpg_decode_buff; #endif return 0; }    void get_texture_res_manager(HMI_OBJECT_ID_STR hmi_object_id, r_drw2d_Texture_t *ptexture, U08 *pdata, U32 data_len,  U32 width, U32 height, BOOLEAN rotation, rgl_image_type_str img_type, U08 alpha, HMI_FONT_CHAR_STR char_code/*only used in text*/ ) { uint8_t hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml p_buffer = NULL;  if(pdata != NULL) {  if(img_type == HMI_IMAGE_JPG) { #if 1 if(ptexture != NULL) { ptexture->Handle = R_NULL; if(rotation) { ptexture->Flags = R_DRW2D_TEX_VT;/*for rotation*/ } else { ptexture->Flags = R_DRW2D_TEX_NONE;  } } p_buffer = pdata;//malloc_jpg_buffer(hmi_object_id,pdata,data_len,rotation,width,height); if(ptexture != NULL) { ptexture->Buffer.Pitch = width;//HMI_TEXTURE_STRIDE(width*LOC_BYTE_PER_PIXEL1); ptexture->Buffer.Size.Width = width; ptexture->Buffer.Size.Height = height; ptexture->Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_ARGB8888; ptexture->Buffer.Data = p_buffer;  } #endif } else if(img_type == HMI_IMAGE_RLE) { if(ptexture != NULL) { ptexture->Handle = R_NULL; ptexture->Flags = R_DRW2D_TEX_RLE; }  if(ptexture != NULL) { if(rotation) { ptexture->Flags |= R_DRW2D_TEX_SWIZZLE|R_DRW2D_TEX_BILINEAR;/*for rotation*/ } else { //ptexture->Flags |= R_DRW2D_TEX_BILINEAR;?? } } if(alpha) { if(ptexture != NULL) { ptexture->Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_ARGB8888; }  } else { if(ptexture != NULL) { ptexture->Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_ARGB8888; }  } p_buffer = get_buffer_res_manager(hmi_object_id, pdata, data_len); if(ptexture != NULL) { ptexture->Buffer.Pitch = width;//(HMI_STRIDE(width*hmi_bpp)+128)>>2/*/4*/;  ptexture->Buffer.Size.Width = width; ptexture->Buffer.Size.Height= height;  ptexture->Buffer.Data = p_buffer;  } } else if(img_type == HMI_IMAGE_NO_COMPRESS) { if(ptexture != NULL) { ptexture->Handle = R_NULL; if(rotation) { ptexture->Flags = R_DRW2D_TEX_SWIZZLE|R_DRW2D_TEX_BILINEAR;//R_DRW2D_TEX_VT /*for rotation*/|R_DRW2D_TEX_BILINEAR/*anti*/; } else { ptexture->Flags = R_DRW2D_TEX_NONE;  } } if(alpha) { if(ptexture != NULL) { ptexture->Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_ARGB8888; }  } else { if(ptexture != NULL) { ptexture->Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_RGB565; }  } p_buffer = get_buffer_res_manager(hmi_object_id,pdata,data_len); if(ptexture != NULL) { ptexture->Buffer.Pitch = width;  ptexture->Buffer.Size.Width = width; ptexture->Buffer.Size.Height = height;  ptexture->Buffer.Data = p_buffer; }  } else if((img_type == HMI_IMAGE_ALPHA8)|| (img_type == HMI_IMAGE_ALPHA4)|| (img_type == HMI_IMAGE_ALPHA2)|| (img_type == HMI_IMAGE_ALPHA1))/*for font */ { #if HMI_ALL_FONT_NUMBER > 0 if(ptexture != NULL) { ptexture->Handle = R_NULL; //ptexture->Flags = R_DRW2D_TEX_BILINEAR; if(rotation) { //ptexture->Flags = R_DRW2D_TEX_VT | R_DRW2D_TEX_BILINEAR;/*for rotation*/ } else { //ptexture->Flags = R_DRW2D_TEX_BILINEAR; } } if(img_type == HMI_IMAGE_ALPHA8) { if(ptexture != NULL) { ptexture->Buffer.PixelFormat =R_DRW2D_PIXELFORMAT_AL8; ptexture->Buffer.Pitch = width; }  } else if(img_type == HMI_IMAGE_ALPHA4) { if(ptexture != NULL) { ptexture->Buffer.PixelFormat =R_DRW2D_PIXELFORMAT_AL4; ptexture->Buffer.Pitch = (((width+1)>>1)<<1); }  } else if(img_type == HMI_IMAGE_ALPHA2) { if(ptexture != NULL) { ptexture->Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_AL2; ptexture->Buffer.Pitch = (((width+3)>>2)<<2); }  } else if(img_type == HMI_IMAGE_ALPHA1) { if(ptexture != NULL) { ptexture->Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_AL1; ptexture->Buffer.Pitch = (((width+7)>>3)<<3); }  } else { if(ptexture != NULL) { ptexture->Buffer.PixelFormat =R_DRW2D_PIXELFORMAT_AL8; ptexture->Buffer.Pitch = width; }  } //hmi_image.Attributes |= HMI_IMG_ATTRIBUTE_USE_FROM_PERSISTENT_MEMORY;/*font resource not load to memory*/  if(ptexture != NULL) { data_len = ptexture->Buffer.Pitch*height; }  #if(HMI_LOAD_FONT==YES) p_buffer =get_font_buffer_res_manager((U08)(hmi_object_id),char_code, pdata,data_len); #else p_buffer = get_buffer_res_manager(hmi_object_id, pdata,data_len); #endif if(ptexture != NULL) { ptexture->Buffer.Size.Width = width; ptexture->Buffer.Size.Height = height;  ptexture->Buffer.Data = p_buffer;  } #endif } else { if(ptexture != NULL) { ptexture->Handle = R_NULL;  ptexture->Flags = R_DRW2D_TEX_NONE;  } p_buffer = 0; if(ptexture != NULL) { ptexture->Buffer.Size.Width = 0; ptexture->Buffer.Size.Height = 0; ptexture->Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_ARGB8888; ptexture->Buffer.Data = 0;  } }  } }  /* depth is NO of node which is page child() */ #if 0 UINT8 get_layer_from_depth(SINT8 depth) { UINT8 gdi_layer=0;  return gdi_layer; } #endif  UINT8 get_popup_window_layer(void) { UINT8 gdi_layer = 0;  gdi_layer = HMI_LAYER_MAX_CNT; return gdi_layer; }   void hmi_enable_video_layer(BOOLEAN en) { //hmi_video_open = en; #if 0 if(en==TRUE) { } else { } #endif }   r_wm_CapMode_t hmi_convert_video_fmt(U08 fmt) { r_wm_CapMode_t rgl_video_fmt = R_WM_CAPMODE_YUV_ITU656;  switch(fmt) { case HMI_VIDEO_CVBS: rgl_video_fmt = R_WM_CAPMODE_YUV_ITU656; break; case HMI_VIDEO_RGB888: rgl_video_fmt = R_WM_CAPMODE_RGB_24BPP; break; case HMI_VIDEO_RGB565: rgl_video_fmt = R_WM_CAPMODE_RGB_16BPP; break; case HMI_VIDEO_RGB555: rgl_video_fmt = R_WM_CAPMODE_YUV_ITU656; break; case HMI_RGB666: rgl_video_fmt = R_WM_CAPMODE_RGB_18BPP; break; case HMI_YUV_ITU656: rgl_video_fmt = R_WM_CAPMODE_YUV_ITU656; break; case HMI_YUV8: rgl_video_fmt = R_WM_CAPMODE_YUV_8BIT ; break; case HMI_YUV16: rgl_video_fmt = R_WM_CAPMODE_YUV_16BIT; break; default: ; } return rgl_video_fmt; }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr get new free buffer for every dirty layer and clear dirty layer first*/ #if 0 void hmi_clear_dirty_layer(HMI_RECT_STR *pdirty_zone) { U08 i = 0; UINT32 index = 0; UINT8 sprite_layer =0; r_drw2d_IntRect_t clip_rect= {0}; UINT8 clip_index = 0; UINT8 next_clip_index = 0;  if(pdirty_zone != NULL) {  for(i=0;i < HMI_LAYER_MAX_CNT;i++) { if(hmi_layer_info[i] == HMI_LAYER_BUFFER)//removed by pxguo allframebuffer { if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != NULL) {  locSetRenderTarget(locSurface[i]); /*******/ //R_DRW2D_CtxBgColor(HMI_LOC_DRW2D_DEV, 0xff000000/*0xff0000ff*//*0xff000000*/); /*******/ R_DRW2D_CtxBgColor(HMI_LOC_DRW2D_DEV, 0x00000000/*0xff0000ff*//*0xff000000*/);  next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*i; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_zone[next_clip_index].w > 0)&&  (pdirty_zone[next_clip_index].h > 0)) { /*Clip position*/ clip_rect.Pos.X = pdirty_zone[next_clip_index].x-locSurface_rect[i].x;  clip_rect.Pos.Y = pdirty_zone[next_clip_index].y-locSurface_rect[i].y; clip_rect.Size.Width = pdirty_zone[next_clip_index].w; clip_rect.Size.Height = pdirty_zone[next_clip_index].h;  R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_FramebufferClear(HMI_LOC_DRW2D_DEV); clip_index++; next_clip_index ++; }  R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG);   hmi_qd_enablesurface(locSurface[i]); } }  }  else if(hmi_layer_info[i] == HMI_LAYER_SPRITE) { if(locSurface[i] != NULL) { if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  sprite_layer = i-1; if(sprite_layer < HMI_MAX_SPRITE_LAYER) { for(index=0;index < HMI_MAX_SPRITE_NB;index++) { hmi_sprite_list[sprite_layer][index].next_status = HMI_QD_SPRITESTATUS_DISABLED; } } } hmi_qd_enablesurface(locSurface[i]); } } else if(hmi_layer_info[i] == HMI_LAYER_RLE) { if(locSurface[i] != NULL) { hmi_qd_enablesurface(locSurface[i]); } } #if 1 else if(hmi_layer_info[i] == HMI_LAYER_VIDEOIN) { if(layer_video_element[i] != NULL)/*Capture video container*/ { if((*layer_video_element[i])&HMI_VIDEO_ENABLE_STATUS) { if(locSurface[i] != NULL) { hmi_qd_enablesurface(locSurface[i]); } } else /*Disable capture video*/ {  if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != NULL)  {  locSetRenderTarget(locSurface[i]); R_DRW2D_CtxBgColor(HMI_LOC_DRW2D_DEV, 0x00000000/*0xff000000*/); /*Clip position*/ next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*i; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_zone[next_clip_index].w > 0)&&  (pdirty_zone[next_clip_index].h > 0)) { /*Clip position*/ clip_rect.Pos.X = pdirty_zone[next_clip_index].x-locSurface_rect[i].x;  clip_rect.Pos.Y = pdirty_zone[next_clip_index].y-locSurface_rect[i].y; clip_rect.Size.Width = pdirty_zone[next_clip_index].w; clip_rect.Size.Height = pdirty_zone[next_clip_index].h;  R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_FramebufferClear(HMI_LOC_DRW2D_DEV); clip_index++; next_clip_index ++; } R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG); hmi_qd_enablesurface(locSurface[i]); } }   }  } else /*not Capture video container*/ { if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != NULL) { locSetRenderTarget(locSurface[i]);  R_DRW2D_CtxBgColor(HMI_LOC_DRW2D_DEV, 0x00000000/*0xff000000*/); /*Clip position*/ next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*i; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_zone[next_clip_index].w > 0)&&  (pdirty_zone[next_clip_index].h > 0)) { /*Clip position*/ clip_rect.Pos.X = pdirty_zone[next_clip_index].x-locSurface_rect[i].x;  clip_rect.Pos.Y = pdirty_zone[next_clip_index].y-locSurface_rect[i].y; clip_rect.Size.Width = pdirty_zone[next_clip_index].w; clip_rect.Size.Height = pdirty_zone[next_clip_index].h;  R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_FramebufferClear(HMI_LOC_DRW2D_DEV); clip_index++; next_clip_index ++; } R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG); hmi_qd_enablesurface(locSurface[i]); } }   } } #endif else { } } }  } #endif void hmi_driver_set_render_buffer(HMI_RECT_STR *pdirty_zone) { U08 i = 0;  if(pdirty_zone != NULL) {  for(i=0;i < HMI_LAYER_MAX_CNT;i++) { if(hmi_layer_info[i] == HMI_LAYER_BUFFER)//removed by pxguo allframebuffer { if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != NULL) { locSetRenderTarget(locSurface[i]);  } }  }  else if(hmi_layer_info[i] == HMI_LAYER_VIDEOIN) { if(layer_video_element[i] != NULL)/*Capture video container*/ { if((*layer_video_element[i])&HMI_VIDEO_ENABLE_STATUS) {  } else /*Disable capture video*/ {  if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != NULL)  { locSetRenderTarget(locSurface[i]); } }   }  } else /*not Capture video container*/ { if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != NULL) { locSetRenderTarget(locSurface[i]);  } }   } }  else { } } }  }  void hmi_clear_dirty_layer(HMI_RECT_STR *pdirty_zone) { U08 i = 0; UINT32 index = 0; UINT8 sprite_layer =0; r_drw2d_IntRect_t clip_rect= {0}; UINT8 clip_index = 0; UINT8 next_clip_index = 0; HMI_RECT_STR hmi_temp_rect = {HMI_INVALID_COOR,HMI_INVALID_COOR,0,0};  if(pdirty_zone != NULL) {  for(i=0;i < HMI_LAYER_MAX_CNT;i++) { if(hmi_layer_info[i] == HMI_LAYER_BUFFER)//removed by pxguo allframebuffer { if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != NULL) {  locGetRenderTarget(locSurface[i]);  R_DRW2D_CtxBgColor(HMI_LOC_DRW2D_DEV, 0x00000000); clip_index = 0; next_clip_index = HMI_LAYER_MAX_CNT + HMI_DIRTY_FIFO_LEN*i; while((clip_index < HMI_DIRTY_FIFO_LEN)&&  (pdirty_zone[next_clip_index].w > 0)&&  (pdirty_zone[next_clip_index].h > 0)) { hmi_get_union_rect(&pdirty_zone[next_clip_index],&locSurface_rect[i],&hmi_temp_rect); clip_rect.Pos.X = hmi_temp_rect.x - locSurface_rect[i].x; clip_rect.Pos.Y = hmi_temp_rect.y - locSurface_rect[i].y; clip_rect.Size.Width = hmi_temp_rect.w; clip_rect.Size.Height = hmi_temp_rect.h; R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_FramebufferClear(HMI_LOC_DRW2D_DEV); clip_index++; next_clip_index ++; }  R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG);  hmi_qd_enablesurface(locSurface[i]); } }  }  else if(hmi_layer_info[i] == HMI_LAYER_SPRITE) { if(locSurface[i] != NULL) { if((pdirty_zone[i].x != HMI_INVALID_COOR)&&/*|| lq modify*/ (pdirty_zone[i].y != HMI_INVALID_COOR)) {  sprite_layer = i-1; if(sprite_layer < HMI_MAX_SPRITE_LAYER) { for(index=0;index < HMI_MAX_SPRITE_NB;index++) { hmi_sprite_list[sprite_layer][index].next_status = HMI_QD_SPRITESTATUS_DISABLED; } } } hmi_qd_enablesurface(locSurface[i]); } } else if(hmi_layer_info[i] == HMI_LAYER_RLE) { if(locSurface[i] != NULL) { hmi_qd_enablesurface(locSurface[i]); } } #if 1 else if(hmi_layer_info[i] == HMI_LAYER_VIDEOIN) { if(layer_video_element[i] != NULL)/*Capture video container*/ { if((*layer_video_element[i])&HMI_VIDEO_ENABLE_STATUS) { if(locSurface[i] != NULL) { hmi_qd_enablesurface(locSurface[i]); } } else /*Disable capture video*/ {  if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != NULL)  {  locGetRenderTarget(locSurface[i]); R_DRW2D_CtxBgColor(HMI_LOC_DRW2D_DEV, 0x00000000/*0xff000000*/); /*Clip position*/ next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*i; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_zone[next_clip_index].w > 0)&&  (pdirty_zone[next_clip_index].h > 0)) { /*Clip position*/ clip_rect.Pos.X = pdirty_zone[next_clip_index].x-locSurface_rect[i].x;  clip_rect.Pos.Y = pdirty_zone[next_clip_index].y-locSurface_rect[i].y; clip_rect.Size.Width = pdirty_zone[next_clip_index].w; clip_rect.Size.Height = pdirty_zone[next_clip_index].h;  R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_FramebufferClear(HMI_LOC_DRW2D_DEV); clip_index++; next_clip_index ++; } R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG); hmi_qd_enablesurface(locSurface[i]); } }   }  } else /*not Capture video container*/ { if((pdirty_zone[i].x != HMI_INVALID_COOR)|| (pdirty_zone[i].y != HMI_INVALID_COOR)) {  if(locSurface[i] != NULL) { locGetRenderTarget(locSurface[i]);  R_DRW2D_CtxBgColor(HMI_LOC_DRW2D_DEV, 0x00000000/*0xff000000*/); /*Clip position*/ next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*i; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_zone[next_clip_index].w > 0)&&  (pdirty_zone[next_clip_index].h > 0)) { /*Clip position*/ clip_rect.Pos.X = pdirty_zone[next_clip_index].x-locSurface_rect[i].x;  clip_rect.Pos.Y = pdirty_zone[next_clip_index].y-locSurface_rect[i].y; clip_rect.Size.Width = pdirty_zone[next_clip_index].w; clip_rect.Size.Height = pdirty_zone[next_clip_index].h;  R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); R_DRW2D_FramebufferClear(HMI_LOC_DRW2D_DEV); clip_index++; next_clip_index ++; } R_DRW2D_GpuFinish(HMI_LOC_DRW2D_DEV,HMI_GPU_FINISH_FLAG); hmi_qd_enablesurface(locSurface[i]); } }   } } #endif else { } } }  }     void hmi_display_video(HMI_VIDEO_INFO_STR CONST *pfmt,HMI_RECT_STR *ppos,BYTE *pvideo_status,BYTE layer) { #if 1 r_wm_CapMode_t video_fmt = R_WM_CAPMODE_NONE; if(layer < HMI_LAYER_MAX_CNT) { if(hmi_layer_info[layer] == HMI_LAYER_VIDEOIN) { if((pvideo_status != NULL)&&(pfmt != NULL)&&(ppos != NULL)) { /*Create video capture*/ if(HMI_VIDEO_CREATE_FLAG&(*pvideo_status)) { *pvideo_status = (*pvideo_status)&((BYTE)(~HMI_VIDEO_CREATE_FLAG)); if((*pvideo_status)&HMI_VIDEO_CREATE_STATUS) { video_fmt = hmi_convert_video_fmt((pfmt->video_fmt_channel)&HMI_VIDEO_FORMAT_BIT); hmi_driver_creat_capture(video_fmt,ppos->w,ppos->h,layer);  }  }  /*wh video capture*/ if(HMI_VIDEO_WH_FLAG&(*pvideo_status)) { *pvideo_status = (*pvideo_status)& (BYTE)(~HMI_VIDEO_WH_FLAG); if((*pvideo_status)&HMI_VIDEO_CREATE_STATUS) { hmi_qd_resizesurface(locSurface[layer], ((HMI_STRIDE(locSurface_rect[layer].w*hmi_bpp))/hmi_bpp)/*pitch*/, ppos->w/*width*/, ppos->h/*heigh*/); /*delete pre format video*/  R_WM_CaptureDelete(HMI_LOC_VOVIAL_UNIT,&loc_CaptureDevice);  video_fmt = hmi_convert_video_fmt((pfmt->video_fmt_channel)&HMI_VIDEO_FORMAT_BIT); hmi_driver_creat_capture(video_fmt,ppos->w,ppos->h,layer); if((*pvideo_status)&HMI_VIDEO_ENABLE_BIT) { R_WM_CaptureEnable(HMI_LOC_VOVIAL_UNIT, &loc_CaptureDevice); } else { R_WM_CaptureDisable(HMI_LOC_VOVIAL_UNIT, &loc_CaptureDevice); } } } /*xy position video capture*/ if(HMI_VIDEO_XY_FLAG&(*pvideo_status)) { *pvideo_status = (*pvideo_status)& ((BYTE)(~HMI_VIDEO_XY_FLAG));  hmi_qd_movesurface(locSurface[layer], ppos->x,ppos->y,0);  } /*Enable/disable video capture*/ if(HMI_VIDEO_ENABLE_FLAG&(*pvideo_status)) { *pvideo_status =(*pvideo_status)&((BYTE)(~HMI_VIDEO_ENABLE_FLAG)); if(!((*pvideo_status)&HMI_VIDEO_CREATE_STATUS)) { video_fmt = hmi_convert_video_fmt((pfmt->video_fmt_channel)&HMI_VIDEO_FORMAT_BIT); hmi_driver_creat_capture(video_fmt,ppos->w,ppos->h,layer); (*pvideo_status)=(*pvideo_status)|HMI_VIDEO_CREATE_STATUS; } if((*pvideo_status)&HMI_VIDEO_CREATE_STATUS)  { if((*pvideo_status)&HMI_VIDEO_ENABLE_BIT)/*enable capture*/ { R_WM_CaptureEnable(HMI_LOC_VOVIAL_UNIT, &loc_CaptureDevice);  } else /*disable capture */ { R_WM_CaptureDisable(HMI_LOC_VOVIAL_UNIT, &loc_CaptureDevice);  } }  } /*Destory video capture*/ if(HMI_VIDEO_CREATE_FLAG&(*pvideo_status)) { *pvideo_status = (*pvideo_status)&((BYTE)(~HMI_VIDEO_CREATE_FLAG)); if(!((*pvideo_status)&HMI_VIDEO_CREATE_STATUS))  { R_WM_CaptureDisable(HMI_LOC_VOVIAL_UNIT, &loc_CaptureDevice); R_WM_CaptureDelete(HMI_LOC_VOVIAL_UNIT,&loc_CaptureDevice);  }  }  } } } #endif }  void hmi_driver_creat_capture(r_wm_CapMode_t fmt,U16 width,U16 heigh,BYTE layer) { r_wm_Error_t wm_err = R_WM_ERR_OK; r_wm_Window_t* pCaptureWindow = NULL;  #if 1 pCaptureWindow = (r_wm_Window_t*)hmi_qd_getnativewindow(locSurface[layer]);  #ifdef R_CVBS_VIDEO_CAPTURE_ENABLE #if LOC_CAPTURE_SYNCHRONIZED == 1 loc_CaptureDevice.Mode = (r_wm_CapMode_t)(R_WM_CAPMODE_YUV_ITU656 | R_WM_CAPMODE_YUV_Y_UV_INVERT ); #else loc_CaptureDevice.Mode = (r_wm_CapMode_t)(R_WM_CAPMODE_YUV_ITU656 | R_WM_CAPMODE_YUV_Y_UV_INVERT | R_WM_CAPMODE_FIXED_VSYNC); #endif #elif defined(R_LVDS_VIDEO_CAPTURE_ENABLE)  loc_CaptureDevice.Mode = (r_wm_CapMode_t)(R_WM_CAPMODE_RGB_24BPP | R_WM_CAPMODE_VSYNC_INVERT | R_WM_CAPMODE_HSYNC_INVERT); #endif loc_CaptureDevice.StartX = LOC_CAPTURE_INPUT_STARTX; loc_CaptureDevice.StrideX = ((HMI_STRIDE(width*hmi_bpp))/hmi_bpp);//;//((HMI_STRIDE(width*hmi_bpp))/hmi_bpp);  loc_CaptureDevice.StartY1 = LOC_CAPTURE_INPUT_STARTY; loc_CaptureDevice.StartY2 = 0; loc_CaptureDevice.Width = LOC_CAPTURE_INPUT_WIDTH;  loc_CaptureDevice.Height = LOC_CAPTURE_INPUT_HEIGHT; loc_CaptureDevice.ScaledWidth = HMI_STRIDE_4(width); loc_CaptureDevice.ScaledHeight = HMI_STRIDE_4(heigh);  loc_CaptureDevice.Window = pCaptureWindow; loc_CaptureDevice.Delay = LOC_CAPTURE_INPUT_DELAY; loc_CaptureDevice.CapUnit = HMI_LOC_CAPTURE_UNIT;  wm_err = R_WM_CaptureCreate(HMI_LOC_VOVIAL_UNIT, &loc_CaptureDevice); wm_err = R_WM_CaptureEnable(HMI_LOC_VOVIAL_UNIT, &loc_CaptureDevice); if(wm_err !=R_WM_ERR_OK) { hmi_qd_error_handler(HMI_RGL_VIDEO_ERROR); } // wm_err = R_WM_FrameEndMark(HMI_LOC_VOVIAL_UNIT, 0); //wm_err = R_WM_FrameWait(HMI_LOC_VOVIAL_UNIT, 0);  #endif }  /*********************************************************** Function: Hmi_Refresh_Image */  void Hmi_Refresh_Image(void){ }  /*********************************************************** Function: Hmi_UpdateImage_Convolution */  void Hmi_UpdateImage_Convolution(void) { }  void clear_layer_video_status(void) { U08 loop = 0;  for(loop = 0;loop < HMI_LAYER_MAX_CNT;loop++) {  layer_video_element[loop] = NULL; //layer_video_element_id[loop]= HMI_NB_ELEMENTS; } } void set_layer_video_status(UINT8 layer,HMI_OBJECT_ID_STR object_id,BYTE *pvideo_status) { if((layer < HMI_LAYER_MAX_CNT)&&(pvideo_status != NULL)) { layer_video_element[layer] = pvideo_status; //layer_video_element_id[layer] = object_id; } }  void off_layer_video(void) { U08 loop = 0; r_wm_Error_t err = R_WM_ERR_OK;  for(loop = 0;loop < HMI_LAYER_MAX_CNT;loop++)  {  if(layer_video_element[loop] != NULL ) { if((*layer_video_element[loop] )&HMI_VIDEO_CREATE_STATUS)  {  err |= R_WM_CaptureDisable(HMI_LOC_VOVIAL_UNIT, &loc_CaptureDevice); err |= R_WM_CaptureDelete(HMI_LOC_VOVIAL_UNIT,&loc_CaptureDevice);  *layer_video_element[loop]=(*layer_video_element[loop])&((U08)(~HMI_VIDEO_ENABLE_CREATE_BIT)); } } } } static uint8_t EdgeFlags[HMI_TRAIL_VERTEX_NUM] = {0}; static r_drw2d_Point_t trail_segment[HMI_TRAIL_VERTEX_NUM]={{R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}, {R_DRW2D_2X(0),R_DRW2D_2X(0)}  };  #if 0 static r_drw2d_UVCoord_t uvcoords_trail[4] = {  { R_DRW2D_2U(0.0f), R_DRW2D_2V(0.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr left/top */ { R_DRW2D_2U(0.0f), R_DRW2D_2V(1.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr right/top */ { R_DRW2D_2U(1.0f), R_DRW2D_2V(1.0f) }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr right/bottom */ { R_DRW2D_2U(1.0f), R_DRW2D_2V(0.0f) } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr left/bottom HMI_Data/ HMI_Source/ HMI_Tool/  };   /* only rotation user define point,can support this function */ void hmi_driver_animated_trail(HMI_ROTATION_TRAIL_STR CONST *ptail, BYTE trail_attr, HMI_RECT_STR *pscreen_target, HMI_IMAGE_ATTR_STR img_compress, HMI_RECT_ALPHA_ANGEL_STR *palpha_pos_angel,  HMI_BITMAP_STR *pimage_prop_info, HMI_RECT_STR *pclip_rect, UINT8 layer,  HMI_ROTATION_STR *protation,/*rotation point,NULL mean center point*/  float_32 pointer_angel, UINT8 father_alpha, HMI_BITMAP_STR CONST *pimage_pointer_prop_info ) {  float_32 trail_angel = 0;  U16 rect_cnt = 0; U16 rect_loop = 0; U16 rect_big_side = 0; U16 rect_small_side = 0; SINT16 init_angel = 0; float_32 init_angel_arc= 0; uint8_t EdgeFlags = 0; float_32 angel = 0; BOOLEAN rotation = FALSE; BOOLEAN alpha = FALSE; r_drw2d_Error_t ret = R_DRW2D_ERR_OK;  UINT8 image_alpha = HMI_OPAQUE; void* setlocSurface = NULL; float_32 scale_h = 1.0f; float_32 little_circle_len = 0; float_32 big_circle_len = 0; float_32 begin_angel = 0; float_32 end_angel = 0; HMI_X_STR rect_x_upper = 0; HMI_X_STR rect_small_x_upper = 0;  HMI_ROTATION_STR roation_origin = {0,0}; HMI_ROTATION_STR pointer_target_center = {0,0}; HMI_RECT_STR pointer_target_layer = {0,0,0,0}; rgl_image_type_str bmp_compress= HMI_IMAGE_NO_COMPRESS; r_drw2d_Point_t rot_center = {R_DRW2D_2X(0),R_DRW2D_2X(0)}; r_drw2d_Point_t rotation_pos= {R_DRW2D_2X(0),R_DRW2D_2X(0)}; HMI_ROTATION_STR rotation_point = {0,0}; HMI_OBJECT_ID_STR hmi_object_id = HMI_NB_ELEMENTS; r_drw2d_IntRect_t clip_rect = {0}; r_drw2d_Texture_t texture = {0}; U16 rect_beg_end_cnt = 0; float_32 uv_begin = 0; float_32 uv_rect_h = 0; U16 init_angel_trail = 0; UINT8 bmp_alpha_rotation_flag = ((img_compress.image_attr)&0xf0);  if((ptail != NULL)&&(pimage_prop_info != NULL)&& (pscreen_target != NULL)&&(palpha_pos_angel != NULL)&& (pclip_rect != NULL)&&(pimage_pointer_prop_info != NULL)&& (protation != NULL)&&(layer < HMI_LAYER_MAX_CNT)) { if(ptail->trail_en == TRUE) {  if(fabs(pointer_angel) > HMI_CIRCLE_ANGEL) { pointer_angel = ((INT32)(pointer_angel)) % HMI_CIRCLE_ANGEL; } if(fabs(ptail->begin_angel) > HMI_CIRCLE_ANGEL) { begin_angel = ((INT32)(ptail->begin_angel)) % HMI_CIRCLE_ANGEL; } else { begin_angel = ptail->begin_angel; } if(fabs(ptail->end_angel) >HMI_CIRCLE_ANGEL) { end_angel = ((INT32)(ptail->end_angel)) % HMI_CIRCLE_ANGEL; } else { end_angel = ptail->end_angel; } if((pointer_angel >= begin_angel)&&(pointer_angel <= end_angel)&& (pscreen_target->w != 0)&&(pscreen_target->h != 0)) {  bmp_compress = get_compress_fmt(img_compress); if(((hmi_layer_info[layer] == HMI_LAYER_BUFFER)|| (hmi_layer_info[layer] == HMI_LAYER_VIDEOIN))&& (bmp_compress != HMI_IMAGE_JPG)) {  /*convert screen rotation point coordinate to layer coordinate*/  rotation_point.x = protation->x - locSurface_rect[layer].x; rotation_point.y = protation->y - locSurface_rect[layer].y; pointer_target_layer.x = pscreen_target->x - locSurface_rect[layer].x; pointer_target_layer.y = pscreen_target->y - locSurface_rect[layer].y; pointer_target_layer.w = pscreen_target->w; pointer_target_layer.h = pscreen_target->h; /*get tail texture ID(image element)*/ hmi_object_id = ptail->texture;  /*set window*/  setlocSurface = hmi_get_window(layer); if(setlocSurface != NULL) { locGetRenderTarget(setlocSurface); } /*identity*/ ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV);  /*blend transform mode*/ ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_CUSTOM); ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV, R_DRW2D_BLEND_SRC_ALPHA, R_DRW2D_BLEND_ONE_MINUS_SRC_ALPHA, R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE  ); /*2d transform*/ ret |= R_DRW2D_CtxTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TRANSFORM_2D); ret |= R_DRW2D_CtxTextureTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TEX_TRANSFORM_2D); /*get texture*/  rotation= bmp_alpha_rotation_flag&HMI_ROTATION_IMAGE_FLAG; alpha = bmp_alpha_rotation_flag&HMI_ALPHA_IMAGE_FLAG; get_texture_res_manager(hmi_object_id, &texture, (uint8_t *)(pimage_prop_info->pbitmap_data), pimage_prop_info->data_len, pimage_prop_info->w, pimage_prop_info->h, rotation, bmp_compress, alpha, 0 );  /*anti*/ texture.Flags |= R_DRW2D_TEX_BILINEAR; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set texture */ ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE); ret |= R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0, &texture);  /*set global alpha*/  if(father_alpha > palpha_pos_angel->alpha) { image_alpha = palpha_pos_angel->alpha; } else { image_alpha = father_alpha; } if(image_alpha != HMI_OPAQUE)  { set_alpha_effect(image_alpha); } /*Clip position*/  clip_rect.Pos.X = pclip_rect->x - locSurface_rect[layer].x;  clip_rect.Pos.Y = pclip_rect->y - locSurface_rect[layer].y; clip_rect.Size.Width = pclip_rect->w; clip_rect.Size.Height = pclip_rect->h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect);   /*get every segment width and height*/ trail_angel = pointer_angel - begin_angel;  rect_cnt = (U16)(trail_angel/HMI_TRAIL_SEGMENT+HMI_TRAIL_TOLERATION); rect_beg_end_cnt = (U16)((end_angel - begin_angel)/ HMI_TRAIL_SEGMENT+HMI_TRAIL_TOLERATION);   little_circle_len = 2*HMI_PI*ptail->distance; big_circle_len = 2*HMI_PI*(ptail->distance+pimage_prop_info->w);  rect_big_side = (U16)(ceil(big_circle_len/(HMI_CIRCLE_ANGEL/((float_32)HMI_TRAIL_SEGMENT))));  rect_small_side = (U16)(little_circle_len/(HMI_CIRCLE_ANGEL/HMI_TRAIL_SEGMENT)+0.5);  if(rect_big_side == 0) { rect_big_side = 1; } if(rect_small_side == 0) { rect_small_side = 1; } /*center point coordinate*/ pointer_target_center.x = pointer_target_layer.x+pointer_target_layer.w/2;  pointer_target_center.y = pointer_target_layer.y+pointer_target_layer.h/2; /*convert coordinate to new coordinate---protation as orgin */ pointer_target_center.x -= rotation_point.x; pointer_target_center.y -= rotation_point.y; /*get angel between pointer_target_center and y axis*/ if(pointer_target_center.x != 0) { init_angel_arc = atan(fabs(pointer_target_center.y/((float_32)pointer_target_center.x))); init_angel = init_angel_arc*180.0/HMI_PI; if(pointer_target_center.x > 0)  { if(pointer_target_center.y > 0) {  init_angel = -(90-init_angel); } else { init_angel = -(90+init_angel); } } else /*x < 0*/ { if(pointer_target_center.y > 0) { init_angel = -(270+init_angel); } else { init_angel = -(270-init_angel); } }  } else { if(pointer_target_center.y > 0) { init_angel = 0; } else if(pointer_target_center.y < 0) { init_angel = -180; } else { init_angel = 0; } }  rect_x_upper = (HMI_X_STR)ceil(rect_big_side/2.0); rect_small_x_upper = (HMI_X_STR)ceil(rect_small_side/2.0);  trail_segment[0].X = R_DRW2D_2X(-rect_x_upper); trail_segment[0].Y = R_DRW2D_2X(0);  trail_segment[1].X = R_DRW2D_2X(rect_x_upper); trail_segment[1].Y = R_DRW2D_2X(0);  trail_segment[2].X = R_DRW2D_2X(rect_x_upper); trail_segment[2].Y = R_DRW2D_2X(pimage_prop_info->w);  trail_segment[3].X = R_DRW2D_2X(-rect_x_upper); trail_segment[3].Y = R_DRW2D_2X(pimage_prop_info->w);   trail_angel = begin_angel; if(rect_beg_end_cnt != 0) { uv_rect_h = 1.0/rect_beg_end_cnt; } else { uv_rect_h = 1.0f; } if(pimage_pointer_prop_info->w != 0) {  scale_h = ((float_32)(pscreen_target->w))/pimage_pointer_prop_info->w; }  for(rect_loop = 0;rect_loop < rect_cnt;rect_loop++) { /*get uv HMI_Data/ HMI_Source/ HMI_Tool/  uv_begin = rect_loop*uv_rect_h;  uvcoords_trail[0].U = R_DRW2D_2U(0.0); uvcoords_trail[0].V = R_DRW2D_2V(1.0f-(uv_begin+uv_rect_h));   uvcoords_trail[1].U = R_DRW2D_2U(0.0f); uvcoords_trail[1].V = R_DRW2D_2V(1.0f-uv_begin);  uvcoords_trail[2].U = R_DRW2D_2U(1.0f) ; uvcoords_trail[2].V = R_DRW2D_2V(1.0f-uv_begin);  uvcoords_trail[3].U = R_DRW2D_2U(1.0); uvcoords_trail[3].V = R_DRW2D_2V(1.0f-(uv_begin+uv_rect_h));   ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV); #if 1 if(scale_h != 1.0f) { ret |= R_DRW2D_CtxScale(HMI_LOC_DRW2D_DEV,R_DRW2D_2X(1.0f), R_DRW2D_2X(scale_h),0); } #endif ret |= R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(rotation_point.x), R_DRW2D_2X(rotation_point.y),  R_DRW2D_2X(0)); ret |= R_DRW2D_CtxRotate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(trail_angel+init_angel));  ret |= R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(0), R_DRW2D_2X(ptail->distance), R_DRW2D_2X(0) ); /*draw*/  ret |= R_DRW2D_DrawQuadsUV(HMI_LOC_DRW2D_DEV, trail_segment,4, &EdgeFlags, uvcoords_trail); trail_angel += HMI_TRAIL_SEGMENT; ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); /*error*/  if (R_DRW2D_ERR_OK != ret) { loc_Error_hmi(ret); } loc_IncMsgCount(HMI_LOC_VOVIAL_UNIT);  } } } } } } #endif  #if HMI_ALL_FONT_NUMBER > 0 void hmi_init_font_buffer(void) { U08 i = 0; U16 j = 0; FONT_BUF_ADDR_STR *pbuf = NULL; #if (HMI_LOAD_FONT_DATA==HMI_YES) for(i=0;i < HMI_ALL_FONT_NUMBER;i++) { pbuf = (FONT_BUF_ADDR_STR *)hmi_all_font_buffer[i]; for(j=0;j < HMI_FONT_BUFFER_LEN;j++) {  pbuf[j].font_code = 0x0; pbuf[j].pdata = NULL; } } for(j=0;j < HMI_ALL_FONT_NOT_HIT_LEN ;j++) { hmi_all_font_not_hit[j].font_id = 0x00; hmi_all_font_not_hit[j].font_buffer.font_code = 0x00; hmi_all_font_not_hit[j].font_buffer.pdata = NULL; } #endif }  void hmi_release_font_buffer(void) { U08 i = 0; U16 j = 0; FONT_BUF_ADDR_STR *pbuf = NULL; #if (HMI_LOAD_FONT_DATA==HMI_YES)  for(i=0;i < HMI_ALL_FONT_NUMBER;i++) { pbuf = (FONT_BUF_ADDR_STR *)hmi_all_font_buffer[i]; for(j=0;j < HMI_FONT_BUFFER_LEN;j++) {  if(pbuf[j].pdata != NULL) { R_CDI_Free((uint32_t)(pbuf[j].pdata),HMI_LOC_VRAM_HEAP); pbuf[j].pdata = NULL; pbuf[j].font_code = 0x00; } } }  for(j=0;j < HMI_ALL_FONT_NOT_HIT_LEN ;j++) { if(hmi_all_font_not_hit[j].font_buffer.pdata != NULL) { R_CDI_Free((uint32_t)(hmi_all_font_not_hit[j].font_buffer.pdata),HMI_LOC_VRAM_HEAP); hmi_all_font_not_hit[j].font_buffer.pdata =NULL; hmi_all_font_not_hit[j].font_id = 0x00; hmi_all_font_not_hit[j].font_buffer.font_code = 0x00; }  } #endif }  U08 hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml get_font_buffer_res_manager(U08 font_id, HMI_FONT_CHAR_STR char_code,  U08 *pdata /*flash data address*/,  U32 data_len )  {  U08 *pvmem = NULL;  void *locOld = NULL; FONT_BUF_ADDR_STR *pbuf= NULL; U16 index = 0; U16 loop = 0; BOOLEAN find = FALSE; #if (HMI_LOAD_FONT_DATA==HMI_YES)  if((data_len != 0)&&(pdata != NULL)) {  if(font_id < HMI_ALL_FONT_NUMBER) { pbuf = (FONT_BUF_ADDR_STR *)hmi_all_font_buffer[font_id];  if(char_code >= HMI_DISPLAY_ASCII_BEGIN) { index = (char_code-HMI_DISPLAY_ASCII_BEGIN)%HMI_FONT_BUFFER_LEN; } else { index = char_code%HMI_FONT_BUFFER_LEN; } if(pbuf[index].pdata == NULL) { locOld = hmi_Init2DImg(pdata,data_len); if(locOld != NULL)  { pbuf[index].pdata = locOld;  pbuf[index].font_code = char_code; pvmem = locOld; }  } else { if(pbuf[index].font_code == char_code) { pvmem = pbuf[index].pdata; } else /*search not hit table*/ { index = HMI_NOT_HIT_INVALIDE_INDEX; for(loop=0; (loop < HMI_ALL_FONT_NOT_HIT_LEN)&&(!find);loop++) { if((hmi_all_font_not_hit[loop].font_buffer.pdata) == NULL)  { if(index == HMI_NOT_HIT_INVALIDE_INDEX) { index = loop; } } else { if((hmi_all_font_not_hit[loop].font_id == font_id)&& (hmi_all_font_not_hit[loop].font_buffer.font_code == char_code)&& ((hmi_all_font_not_hit[loop].font_buffer.pdata) != NULL)) { pvmem = hmi_all_font_not_hit[loop].font_buffer.pdata; find = TRUE; } } } if(!find) { if((index != HMI_NOT_HIT_INVALIDE_INDEX)) { locOld = hmi_Init2DImg(pdata,data_len); if(locOld != NULL)  { hmi_all_font_not_hit[index].font_id = font_id; hmi_all_font_not_hit[index].font_buffer.pdata = locOld;  hmi_all_font_not_hit[index].font_buffer.font_code= char_code; pvmem = locOld; } } else { pvmem = pdata; } } } }  }  } #endif return pvmem; }  #endif     BOOLEAN hmi_is_small_arc(INT32 begin_angel,INT32 end_angel) { BOOLEAN small_arc = FALSE; #if 0 begin_angel = begin_angel % HMI_CIRCLE_ANGEL; end_angel = end_angel % HMI_CIRCLE_ANGEL;  if(begin_angel < 0) { begin_angel = HMI_CIRCLE_ANGEL+begin_angel; }  if(end_angel < 0) { end_angel = HMI_CIRCLE_ANGEL+end_angel; }  #if 0  if(begin_angel <= end_angel) { small_arc = TRUE; } else { small_arc = FALSE; } #endif  if(begin_angel <= end_angel) { if(end_angel-begin_angel >= HMI_HALF_CIRCLE_ANGEL) { small_arc = FALSE; } else { small_arc = TRUE; }  } else { small_arc = FALSE; } #endif  begin_angel = begin_angel % HMI_CIRCLE_ANGEL; end_angel = end_angel % HMI_CIRCLE_ANGEL;  if(((begin_angel <= 0)&&(end_angel <= 0))|| ((begin_angel >= 0)&&(end_angel >= 0))) { begin_angel = end_angel - begin_angel; if(begin_angel <= 90) { small_arc = TRUE; } else { small_arc = FALSE; } } else { if((begin_angel <= 0)&&(end_angel >= 0)) { small_arc = TRUE; } else { small_arc = FALSE; } }  return small_arc;  }   U08 hmi_get_beg_end_vertex(float_32 angel,U16 circle_radius_w,U16 circle_radius_h,r_drw2d_Point_t *pvertex) { U08 no = 0;  if(pvertex != NULL) {  if(((angel >= (-45))&&(angel <= 45))||((angel >= 315)&&(angel <= 360))) { if(fabs(angel) < HMI_FLOAT_TOLERANCE) {  pvertex[0].X = R_DRW2D_2X(0); pvertex[0].Y = R_DRW2D_2X(circle_radius_h);  } else {  pvertex[0].X = R_DRW2D_2X(circle_radius_h/tan(HMI_ANGEL_TO_RADIAN(90+angel))); pvertex[0].Y = R_DRW2D_2X(circle_radius_h);  } no = 0; } else if( ((angel <=(-45))&&(angel >= (-135)))|| ((angel <=(315))&&(angel >= (225)))) {  pvertex[0].X = R_DRW2D_2X(circle_radius_w); pvertex[0].Y = R_DRW2D_2X((circle_radius_w)*tan(HMI_ANGEL_TO_RADIAN(90+angel)));  no = 3; } else if(((angel <= (-135))&&(angel >= (-225)))|| ((angel <= (225))&&(angel >= (135)))) {  if(fabs(angel) < HMI_FLOAT_TOLERANCE) {  pvertex[0].X = R_DRW2D_2X(0); pvertex[0].Y = R_DRW2D_2X(-circle_radius_h);  } else {  pvertex[0].X = R_DRW2D_2X(-circle_radius_h/tan(HMI_ANGEL_TO_RADIAN(90+angel))); pvertex[0].Y = R_DRW2D_2X(-circle_radius_h);  } no = 2; } else if(((angel <= (-225))&&(angel >= (-315)))|| ((angel <= 135)&&(angel >= (45)))) {  pvertex[0].X = R_DRW2D_2X(-circle_radius_w); pvertex[0].Y = R_DRW2D_2X(-circle_radius_w*tan(HMI_ANGEL_TO_RADIAN(90+angel))); no = 1; } else { } } return no; }   U08 hmi_get_draw_vertex(U08 beg_no,U08 end_no,r_drw2d_Point_t *pbeg_vertex, r_drw2d_Point_t *pend_vertex,U16 circle_radius_w,U16 circle_radius_h, BOOLEAN beg_end/*begin angle with x axis >end*/) { U08 vertex_num = 0; r_drw2d_Point_t quard_vertex[4] = {0};  quard_vertex[0].X = R_DRW2D_2X(-circle_radius_w); quard_vertex[0].Y = R_DRW2D_2X(circle_radius_h);  quard_vertex[1].X = R_DRW2D_2X(-circle_radius_w); quard_vertex[1].Y = R_DRW2D_2X(-circle_radius_h);  quard_vertex[2].X = R_DRW2D_2X(circle_radius_w); quard_vertex[2].Y = R_DRW2D_2X(-circle_radius_h);  quard_vertex[3].X = R_DRW2D_2X(circle_radius_w); quard_vertex[3].Y = R_DRW2D_2X(circle_radius_h);  if(beg_no == 1) { if(end_no == 1) { if(beg_end) {  if(HMI_TRAIL_VERTEX_NUM >= 3) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else { if(HMI_TRAIL_VERTEX_NUM >= 15) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;   trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y;  vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;   trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;   trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;   } }  } else if(end_no == 2) {  if(HMI_TRAIL_VERTEX_NUM >= 6) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  }  } else if(end_no == 3) { if(HMI_TRAIL_VERTEX_NUM >= 9) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else if(end_no == 0) { if(HMI_TRAIL_VERTEX_NUM >= 12) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;   } } else { } } else if(beg_no == 2) { if(end_no == 1) {  if(HMI_TRAIL_VERTEX_NUM >= 12) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else if(end_no == 2) {  if(beg_end) { if(HMI_TRAIL_VERTEX_NUM >= 3) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else { if(HMI_TRAIL_VERTEX_NUM >= 8) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++; } }  } else if(end_no == 3) { if(HMI_TRAIL_VERTEX_NUM >= 6) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else if(end_no == 0) { if(HMI_TRAIL_VERTEX_NUM >= 9) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y;  vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y;  vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else { } } else if(beg_no == 3) { if(end_no == 1) {  if(HMI_TRAIL_VERTEX_NUM >= 9) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0);  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0);  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else if(end_no == 2) {  if(HMI_TRAIL_VERTEX_NUM >= 12) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0);  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0);  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0);  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  }  } else if(end_no == 3) { if(beg_end) { if(HMI_TRAIL_VERTEX_NUM >= 3) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else { if(HMI_TRAIL_VERTEX_NUM >= 15) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0);  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0);  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0);  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0);  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } }  } else if(end_no == 0) { if(HMI_TRAIL_VERTEX_NUM >= 6) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y;  vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++; ///  trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else { } } else if(beg_no == 0)  { if(end_no == 1) {  if(HMI_TRAIL_VERTEX_NUM >= 6) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++; //// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else if(end_no == 2) {  if(HMI_TRAIL_VERTEX_NUM >= 9) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  }  } else if(end_no == 3)  { if(HMI_TRAIL_VERTEX_NUM >= 12) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;   trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++; // trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y;  vertex_num++;  } } else if(end_no == 0) { if(beg_end) { if(HMI_TRAIL_VERTEX_NUM >= 3) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y; vertex_num++;  } } else { if(HMI_TRAIL_VERTEX_NUM >= 15) { trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = pbeg_vertex->X; trail_segment[vertex_num].Y = pbeg_vertex->Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[0].X; trail_segment[vertex_num].Y = quard_vertex[0].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++; /// trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;   trail_segment[vertex_num].X = quard_vertex[1].X; trail_segment[vertex_num].Y = quard_vertex[1].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++; // trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[2].X; trail_segment[vertex_num].Y = quard_vertex[2].Y; vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++; //  trail_segment[vertex_num].X = R_DRW2D_2X(0); trail_segment[vertex_num].Y = R_DRW2D_2X(0); vertex_num++;  trail_segment[vertex_num].X = quard_vertex[3].X; trail_segment[vertex_num].Y = quard_vertex[3].Y; vertex_num++;  trail_segment[vertex_num].X = pend_vertex->X; trail_segment[vertex_num].Y = pend_vertex->Y;  vertex_num++;  } }  } else { } } else { } return vertex_num; }   float_32 hmi_init_angel_to_y_axis(HMI_ROTATION_STR *pointer_target_center) { float_32 init_angel = 0; float_32 init_angel_arc = 0;  if(pointer_target_center != NULL) { if(pointer_target_center->x != 0) { init_angel_arc = atan(fabs(pointer_target_center->y/((float_32)pointer_target_center->x))); init_angel = init_angel_arc*180.0/HMI_PI; if(pointer_target_center->x > 0)  { if(pointer_target_center->y > 0) {  init_angel = -(90-init_angel); } else { init_angel = -(90+init_angel); } } else /*x < 0*/ { if(pointer_target_center->y > 0) { init_angel = -(270+init_angel); } else { init_angel = -(270-init_angel); } }  } else { if(pointer_target_center->y > 0) { init_angel = 0; } else if(pointer_target_center->y < 0) { init_angel = -180; } else { init_angel = 0; } }  } return init_angel; }     void hmi_driver_animated_trail(HMI_ROTATION_TRAIL_STR CONST *ptail,  BYTE trail_attr, HMI_RECT_STR *pscreen_target, HMI_IMAGE_ATTR_STR img_compress, HMI_RECT_ALPHA_ANGEL_STR *palpha_pos_angel,  HMI_BITMAP_STR *pimage_prop_info, HMI_RECT_STR *pclip_rect, HMI_RECT_STR *pdirty_rect, UINT8 layer,  HMI_ROTATION_STR *protation,/*rotation point,NULL mean center point*/  float_32 pointer_angel, UINT8 father_alpha, HMI_BITMAP_STR CONST *pimage_pointer_prop_info, HMI_RECT_STR *ptrail_rect ) {  float_32 init_angel = 0; float_32 angel = 0; BOOLEAN rotation = FALSE; BOOLEAN alpha = FALSE; r_drw2d_Error_t ret = R_DRW2D_ERR_OK;  UINT8 image_alpha = HMI_OPAQUE; void* setlocSurface = NULL; float_32 scale_h = 1.0f; float_32 scale_w = 1.0f;  float_32 scale_texture_h = 1.0f; float_32 scale_texture_w = 1.0f;  float_32 begin_angel = 0; U08 beg_no = 0; U08 end_no = 0; float_32 end_angel = 0;  HMI_ROTATION_STR pointer_target_center = {0,0}; HMI_RECT_STR pointer_target_layer = {0,0,0,0}; rgl_image_type_str bmp_compress= HMI_IMAGE_NO_COMPRESS; HMI_ROTATION_STR rotation_point = {0,0}; HMI_OBJECT_ID_STR hmi_object_id = HMI_NB_ELEMENTS; r_drw2d_IntRect_t clip_rect = {0}; r_drw2d_Texture_t texture = {0};  //U16 circle_radius = 0; U16 circle_radius_w = 0; U16 circle_radius_h = 0; INT32 offset_x = 0; INT32 offset_y = 0; BOOLEAN beg_end = FALSE; U08 vertex_num = 0;  r_drw2d_Point_t beg_vertex = {R_DRW2D_2X(0),R_DRW2D_2X(0)}; r_drw2d_Point_t end_vertex = {R_DRW2D_2X(0),R_DRW2D_2X(0)}; UINT8 bmp_alpha_rotation_flag = ((img_compress.image_attr)&0xf0); BYTE trail_cw = (trail_attr & HMI_BMP_TRAIL); UINT8 clip_index = 0; UINT8 next_clip_index = 0; HMI_RECT_STR hmi_min_dirty_rect = {0,0,0,0};  if((ptail != NULL)&&(pimage_prop_info != NULL)&& (pscreen_target != NULL)&&(palpha_pos_angel != NULL)&& (pclip_rect != NULL)&&(pimage_pointer_prop_info != NULL)&& (protation != NULL)&&(layer < HMI_LAYER_MAX_CNT)) { if(ptail->trail_en == TRUE) {  #if 0//changed by pxguo 170418 if((pimage_prop_info->h) > (pimage_prop_info->w)) { circle_radius = (pimage_prop_info->h)>>1; } else { circle_radius = (pimage_prop_info->w)>>1; } #else circle_radius_w = (ptrail_rect->w)>>1; circle_radius_h = (ptrail_rect->h)>>1; #endif  if(fabs(pointer_angel) > HMI_CIRCLE_ANGEL) { angel = pointer_angel-HMI_CIRCLE_ANGEL; } else { angel = (pointer_angel); } if(fabs(ptail->begin_angel) > HMI_CIRCLE_ANGEL) { begin_angel = ptail->begin_angel - HMI_CIRCLE_ANGEL; } else { begin_angel = ptail->begin_angel; } if(fabs(ptail->end_angel) > HMI_CIRCLE_ANGEL) { end_angel = ptail->end_angel - HMI_CIRCLE_ANGEL; } else { end_angel = ptail->end_angel; }  if(((angel >= begin_angel)&&(angel <= end_angel))&& (pscreen_target->w != 0)&&(pscreen_target->h != 0)) {  bmp_compress = get_compress_fmt(img_compress); if(((hmi_layer_info[layer] == HMI_LAYER_BUFFER)|| (hmi_layer_info[layer] == HMI_LAYER_VIDEOIN))&& (bmp_compress != HMI_IMAGE_JPG)) {  /*convert screen rotation point coordinate to layer coordinate*/  rotation_point.x = protation->x - locSurface_rect[layer].x; rotation_point.y = protation->y - locSurface_rect[layer].y; pointer_target_layer.x = pscreen_target->x - locSurface_rect[layer].x; pointer_target_layer.y = pscreen_target->y - locSurface_rect[layer].y; pointer_target_layer.w = pscreen_target->w; pointer_target_layer.h = pscreen_target->h; /*get tail texture ID(image element)*/ hmi_object_id = ptail->texture;  /*set window*/  setlocSurface = hmi_get_window(layer); if(setlocSurface != NULL) { locGetRenderTarget(setlocSurface); } /*identity*/ ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxTextureIdentity(HMI_LOC_DRW2D_DEV); ret |= R_DRW2D_CtxIdentity(HMI_LOC_DRW2D_DEV);  /*blend transform mode*/ //> dst_color = src_color*src_factor_color + dst_color*dst_factor_color //> dst_alpha = src_alpha*src_factor_alpha + dst_alpha*dst_factor_alpha #if ((defined( HMI_MCU_RH850_D1MX ))||(defined( HMI_MCU_RH850_D1HX ))) ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_CUSTOM);  ret |= R_DRW2D_CtxBlendFactors(HMI_LOC_DRW2D_DEV,  R_DRW2D_BLEND_ONE_MINUS_DST_ALPHA , R_DRW2D_BLEND_DST_ALPHA,  R_DRW2D_BLEND_ONE, R_DRW2D_BLEND_ONE ); #else ret |= R_DRW2D_CtxBlendMode(HMI_LOC_DRW2D_DEV, R_DRW2D_BLENDMODE_SRC_OVER); #endif  /******/ /*2d transform*/ ret |= R_DRW2D_CtxTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TRANSFORM_2D); ret |= R_DRW2D_CtxTextureTransformMode(HMI_LOC_DRW2D_DEV, R_DRW2D_TEX_TRANSFORM_2D); /*get texture*/  rotation= bmp_alpha_rotation_flag&HMI_ROTATION_IMAGE_FLAG; alpha = bmp_alpha_rotation_flag&HMI_ALPHA_IMAGE_FLAG; get_texture_res_manager(hmi_object_id, &texture, (uint8_t *)(pimage_prop_info->pbitmap_data), pimage_prop_info->data_len, pimage_prop_info->w, pimage_prop_info->h, rotation, bmp_compress, alpha, 0 );  /*anti*/ texture.Flags |= R_DRW2D_TEX_BILINEAR; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set texture */ ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_TEXTURE/*R_DRW2D_FILLMODE_SOLID*/); //ret |= R_DRW2D_CtxFillMode(HMI_LOC_DRW2D_DEV, R_DRW2D_FILLMODE_SOLID); ret |= R_DRW2D_CtxTextureSet(HMI_LOC_DRW2D_DEV, 0, &texture);  /*set global alpha*/  if(father_alpha > palpha_pos_angel->alpha) { image_alpha = palpha_pos_angel->alpha; } else { image_alpha = father_alpha; } if(image_alpha != HMI_OPAQUE)  { set_alpha_effect(image_alpha); } #if 0 /*Clip position*/  clip_rect.Pos.X = pclip_rect->x - locSurface_rect[layer].x;  clip_rect.Pos.Y = pclip_rect->y - locSurface_rect[layer].y; clip_rect.Size.Width = pclip_rect->w; clip_rect.Size.Height = pclip_rect->h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect);  #endif /*center point coordinate*/ pointer_target_center.x = pointer_target_layer.x + ((pointer_target_layer.w)>>1);  pointer_target_center.y = pointer_target_layer.y + ((pointer_target_layer.h)>>1); /*convert coordinate to new coordinate---protation as orgin */ pointer_target_center.x -= rotation_point.x; pointer_target_center.y -= rotation_point.y;  /*get angel between pointer_target_center and y axis*/ init_angel = hmi_init_angel_to_y_axis(&pointer_target_center); /*Get draw zone*/ #if 0 beg_no = hmi_get_beg_end_vertex(begin_angel,circle_radius_w,circle_radius_h,&beg_vertex); end_no = hmi_get_beg_end_vertex(angel,circle_radius_w,circle_radius_h,&end_vertex); beg_end = hmi_is_small_arc(begin_angel,angel); vertex_num = hmi_get_draw_vertex(beg_no,end_no, &beg_vertex,&end_vertex, circle_radius_w,circle_radius_h,beg_end);  #else if(trail_cw == HMI_ROT_IMAGE_TAIL_CW) { beg_no = hmi_get_beg_end_vertex(begin_angel,circle_radius_w, circle_radius_h,&beg_vertex); end_no = hmi_get_beg_end_vertex(angel,circle_radius_w, circle_radius_h,&end_vertex); beg_end = hmi_is_small_arc(begin_angel,angel); vertex_num = hmi_get_draw_vertex(beg_no,end_no, &beg_vertex, &end_vertex, circle_radius_w, circle_radius_h, beg_end);  } else { beg_no = hmi_get_beg_end_vertex(angel,circle_radius_w, circle_radius_h,&beg_vertex); end_no = hmi_get_beg_end_vertex(end_angel,circle_radius_w, circle_radius_h,&end_vertex); beg_end = hmi_is_small_arc(angel,end_angel); vertex_num = hmi_get_draw_vertex(beg_no,end_no, &beg_vertex, &end_vertex, circle_radius_w, circle_radius_h, beg_end);   } #endif  if(pimage_pointer_prop_info->w != 0)  {  scale_w = ((float_32)(pscreen_target->w))/pimage_pointer_prop_info->w; }  if(pimage_pointer_prop_info->h != 0)  {  scale_h = ((float_32)(pscreen_target->h))/pimage_pointer_prop_info->h; } if(pscreen_target->w != 0)  {  scale_texture_w = pimage_pointer_prop_info->w/((float_32)(pscreen_target->w)); }  if(pscreen_target->h != 0)  {  scale_texture_h = pimage_pointer_prop_info->h/((float_32)(pscreen_target->h)); }   ret |= R_DRW2D_CtxTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(rotation_point.x), R_DRW2D_2X(rotation_point.y),  R_DRW2D_2X(0));  #if 0//changed by pxguo 170418 offset_x = circle_radius_w*scale_w; offset_y = circle_radius_h*scale_h; #else offset_x = (circle_radius_w)*scale_w; offset_y = (circle_radius_h)*scale_h; #endif ret |= R_DRW2D_CtxTextureTranslate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(rotation_point.x-offset_x+ptrail_rect->x), R_DRW2D_2X(rotation_point.y-offset_y+ptrail_rect->y) );  if((scale_h != 1.0f)||(scale_w != 1.0f)) {  ret |= R_DRW2D_CtxScale(HMI_LOC_DRW2D_DEV,R_DRW2D_2X(scale_w), R_DRW2D_2X(scale_h),R_DRW2D_2X(1.0f));  }  offset_x = circle_radius_w; offset_y = circle_radius_h; if((scale_texture_h != 1.0f)||(scale_texture_w != 1.0f)) {  ret |= R_DRW2D_CtxTextureScale(HMI_LOC_DRW2D_DEV,R_DRW2D_2X(scale_texture_w), R_DRW2D_2X(scale_texture_h));  offset_x = circle_radius_w*scale_texture_w; offset_y = circle_radius_h*scale_texture_h;  }  ret |= R_DRW2D_CtxRotate(HMI_LOC_DRW2D_DEV, R_DRW2D_2X(init_angel)); next_clip_index =HMI_LAYER_MAX_CNT+HMI_DIRTY_FIFO_LEN*layer; while((clip_index<HMI_DIRTY_FIFO_LEN)&&  (pdirty_rect[next_clip_index].w > 0)&&  (pdirty_rect[next_clip_index].h > 0)) { /*Clip position*/ hmi_get_union_rect(pclip_rect,(&pdirty_rect[next_clip_index]),&hmi_min_dirty_rect); if((hmi_min_dirty_rect.w > 0)&&((hmi_min_dirty_rect.h > 0))) { clip_rect.Pos.X = hmi_min_dirty_rect.x-locSurface_rect[layer].x;  clip_rect.Pos.Y = hmi_min_dirty_rect.y-locSurface_rect[layer].y; clip_rect.Size.Width = hmi_min_dirty_rect.w; clip_rect.Size.Height = hmi_min_dirty_rect.h;  ret |= R_DRW2D_CtxClipRect(HMI_LOC_DRW2D_DEV, &clip_rect); ret |= R_DRW2D_DrawTriangles(HMI_LOC_DRW2D_DEV, trail_segment, vertex_num, EdgeFlags); } clip_index++; next_clip_index ++; }  ret |= R_DRW2D_CtxEffectsDelete(HMI_LOC_DRW2D_DEV); /*error*/  if (R_DRW2D_ERR_OK != ret) { loc_Error_hmi(ret); } loc_IncMsgCount(HMI_LOC_VOVIAL_UNIT);  } } } } }  void hmi_driver_set_page_alpha(UINT8 page_alpha) { UINT8 layer = 0;  for(layer = 0;layer < HMI_LAYER_MAX_CNT;layer++) {  if(locSurface[layer] != NULL) { hmi_qd_setsurface_alpha(locSurface[layer], page_alpha); } } } #if HMI_ALL_FONT_NUMBER > 0 #if ((HMI_DYN_EDIT_TEXTS_NUMBER > 0U) || (HMI_STATIC_TEXTS_NUMBER > 0U)) HMI_TEXT_LENGTH_STR hmi_driver_get_string_len( HMI_CHAR_STR *phmi_string,UINT8 font_id) { HMI_CHAR_STR *phmi_temp_string =(HMI_CHAR_STR *)phmi_string; CONST HMI_FONT_STR *phmi_font_table = NULL; HMI_FONT_CHAR_PROP CONST hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml phmi_font_config= 0U; UINT8 hmi_string_temp_index = 0U; UINT8 hmi_text_offset = 0U; HMI_FONT_CHAR_STR hmi_char = 0U; HMI_TEXT_LENGTH_STR hmi_text_real_width = 0U;  if(font_id < HMI_ALL_FONT_NUMBER) { phmi_font_table = &hmi_font_table[font_id]; } else { phmi_font_table = &hmi_font_table[0]; }  while(phmi_temp_string[hmi_string_temp_index] != 0U) { hmi_text_offset = 0U; hmi_char = hmi_get_value_char(phmi_temp_string[hmi_string_temp_index], phmi_temp_string[hmi_string_temp_index+1], &hmi_text_offset); phmi_font_config = hmi_driver_get_char_data(hmi_char, phmi_font_table, font_id); if(phmi_font_config != 0U) { #if HMI_SCROLL_TEXT_SUPPORT != 0U /*get text real length*/ hmi_text_real_width += phmi_font_config->owidth+HMI_CHAR_SPACE; #endif } hmi_string_temp_index += 1U; hmi_string_temp_index += hmi_text_offset; } return hmi_text_real_width; } #endif #endif    BOOLEAN is_buffer_layer(UINT8 layer) { BOOLEAN buffer_layer = FALSE;  if(layer < HMI_LAYER_MAX_CNT) { if(hmi_layer_info[layer] == HMI_LAYER_BUFFER) { buffer_layer = TRUE; } } return buffer_layer; }
