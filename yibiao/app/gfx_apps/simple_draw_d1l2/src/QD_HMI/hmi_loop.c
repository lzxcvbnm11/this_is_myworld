/*****************************************************************************  File Name : hmi_loop.c Organization : Zhuli Electronics Co.Ltd in Shanghai (www.shzldz.com) ******************************************************************************/ #if 0 void hmi_Loop(void); #endif #include "hmi_all_struct_include.h"  /*#define MS_PER_SEC 1000*/ void add_tick_res_manager(void); typedef enum { HMI_CUR_DIRTY, HMI_BCK_DIRTY, HMI_2BUFFER_DIRTY, /***COUNT**/ HMI_BUFFER_DIRTY_CNT }HMI_BUFFER_DIRTY_STR; #ifdef HMI_GRAPHIC_RGL HMI_RECT_STR dirty_zone[HMI_BUFFER_DIRTY_CNT][HMI_ALL_DIRTY_FIFO_LEN]={{HMI_INVALID_COOR,HMI_INVALID_COOR,0,0}}; #endif  void hmi_swap_dirty_buffer(HMI_RECT_STR *buffer1 ,HMI_RECT_STR *buffer2) { HMI_RECT_STR hmi_action_engine.c hmi_action_engine.h hmi_all_struct_include.h HMI_Data hmi_driver_cfg.h hmi_engine.c hmi_engine.h hmi_engine_cfg.h hmi_loop.c hmi_loop.h hmi_loop_driver.c hmi_loop_driver.h hmi_reset.c hmi_reset.h hmi_rgl_driver.c hmi_rgl_driver.h HMI_Source hmi_status.c hmi_status.h hmi_system.h hmi_task_touchpanel.c hmi_task_touchpanel.h hmi_task_touchpanel_driver.c hmi_task_touchpanel_driver.h HMI_Tool hmi_user_interface.c hmi_user_interface.h QD_HMI.gpj zs12_main_project.xml zs12_project_page_0816_bginternal.xml zs12_project_page_0820_hmi.xml zs12_project_page_0823_release.xml zs12_project_page_0828.xml zs12_project_page_0830.xml zs12_project_page_0831_release.xml zs12_project_page_0904_release.xml zs12_project_page_0922_RELEASE.xml zs12_project_page_1016_RELEASE_v2.0.xml zs12_project_page_lyy 0808-FUNCBACK-INTERNAL.xml zs12_project_page_lyy 0808-test-rle-internal.xml zs12_project_page_XIAOSA_0808.xml swap_buffer =NULL; swap_buffer = buffer1; buffer1 = buffer2; buffer2 = swap_buffer; }  void hmi_gfx_update(HMI_TIME dt) { #ifdef HMI_TOUCH_PANEL TOUCH_BUTTON_STR hmi_cur_touch[HMI_SOFTKEY_LEN]={{HMI_NO_TOUCH_KEY,HMI_KEY_STATUS_IDLE_OSD}, {HMI_NO_TOUCH_KEY,HMI_KEY_STATUS_IDLE_OSD}};  #endif    #ifdef HMI_GRAPHIC_RGL //add_tick_res_manager();//removed by pxguo 160827 #endif  /*dt=dt/MS_PER_SEC;*/ #ifdef HMI_SOFT_TIMER hmi_tick_manager(dt); #endif  #ifdef HMI_TOUCH_PANEL  hmi_touch_panel(dt,hmi_cur_touch);  #endif  #ifdef HMI_8_DIRECT /*hmi_8direct(dt);*/ #endif  #ifdef HMI_MEMORY_MANAGER  /*continue to load resource*/ #endif  #ifdef HMI_TOUCH_PANEL #ifndef HMI_GRAPHIC_ST7513 hmi_user_process(dt,hmi_cur_touch); #else hmi_user_process(dt,NULL); #endif #else hmi_user_process(dt,NULL); #endif  #if HMI_ALL_EVENT_NUMBER>0 hmi_action_manager(dt); #endif  }    void hmi_clear_all_dirty_zone( HMI_BUFFER_DIRTY_STR index_buffer) { UINT8 i = 0;  for(i=0;i < HMI_LAYER_MAX_CNT;i++) { dirty_zone[index_buffer][i].x = HMI_INVALID_COOR; dirty_zone[index_buffer][i].y = HMI_INVALID_COOR; dirty_zone[index_buffer][i].w = 0; dirty_zone[index_buffer][i].h = 0; dirty_zone[HMI_2BUFFER_DIRTY][i].x = HMI_INVALID_COOR; dirty_zone[HMI_2BUFFER_DIRTY][i].y = HMI_INVALID_COOR; dirty_zone[HMI_2BUFFER_DIRTY][i].w = 0; dirty_zone[HMI_2BUFFER_DIRTY][i].h = 0; } for(i = HMI_LAYER_MAX_CNT;i < HMI_ALL_DIRTY_FIFO_LEN;i += HMI_DIRTY_FIFO_LEN) { dirty_zone[index_buffer][i].x = HMI_INVALID_COOR; dirty_zone[index_buffer][i].y = HMI_INVALID_COOR; dirty_zone[index_buffer][i].w = 0; dirty_zone[index_buffer][i].h = 0; dirty_zone[HMI_2BUFFER_DIRTY][i].x = HMI_INVALID_COOR; dirty_zone[HMI_2BUFFER_DIRTY][i].y = HMI_INVALID_COOR; dirty_zone[HMI_2BUFFER_DIRTY][i].w = 0; dirty_zone[HMI_2BUFFER_DIRTY][i].h = 0; } }  void hmi_gfx_render(void) { #if (defined(HMI_GRAPHIC_AGG)||defined(HMI_GRAPHIC_ST)||defined(HMI_GRAPHIC_ST7513)) HMI_RECT_STR dirty_zone[1]={HMI_INVALID_COOR,HMI_INVALID_COOR,0,0}; #elif defined(HMI_GRAPHIC_RGL) UINT8 i = 0; BOOLEAN dirty = FALSE; static HMI_BUFFER_DIRTY_STR index_free = HMI_CUR_DIRTY; static HMI_BUFFER_DIRTY_STR index_bck = HMI_BCK_DIRTY;  #endif   static U32 tickCnt = 0; static U32 calCnt = 0; static U32 maxTime = 0;  if((HMI_GFX_GET_STATUS(HMI_SEND_EVENT))&& (hmi_driver_woking_status_flag == HMI_FRAMEBUFFER_FREE)) {   #if defined(HMI_GRAPHIC_AGG) #if HMI_PAGES_NUMBER>0  hmi_engine_get_multi_dirty_zone_page(dirty_zone); if((dirty_zone[0].w > 0)&&(dirty_zone[0].h > 0)) {  hmi_engine_draw_page(dirty_zone);  } #endif  #elif defined( HMI_GRAPHIC_RGL )  #if HMI_PAGES_NUMBER>0  hmi_clear_all_dirty_zone(index_free);  hmi_engine_get_multi_dirty_zone_page(dirty_zone[index_free]); for(i=0;i < HMI_LAYER_MAX_CNT;i++) { #if(HMI_BUFFER_NUMBER==HMI_TWO_BUFFER) if((dirty_zone[index_free][i].w > 0)&&(dirty_zone[index_free][i].h > 0)) { dirty = TRUE; hmi_add_2buffer_dirty_zone(dirty_zone[index_free],dirty_zone[index_bck], dirty_zone[HMI_2BUFFER_DIRTY],i); } else { hmi_copy_last_dirty_zone(dirty_zone[index_bck],dirty_zone[index_free],i); } #else if((dirty_zone[index_free][i].w > 0)&&(dirty_zone[index_free][i].h > 0)) { dirty = TRUE; hmi_copy_last_dirty_zone(dirty_zone[index_free],dirty_zone[HMI_2BUFFER_DIRTY],i); } #endif } if(dirty) {   hmi_engine_create_rgl_window( ); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr get new free buffer for every dirty layer and clear dirty layer first*/ hmi_driver_set_render_buffer(dirty_zone[HMI_2BUFFER_DIRTY]); hmi_clear_dirty_layer(dirty_zone[HMI_2BUFFER_DIRTY]); /*draw at new free buffer*/ hmi_engine_draw_page(dirty_zone[HMI_2BUFFER_DIRTY]); HMI_GFX_CLEAR_STATUS(HMI_SEND_EVENT); HMI_GFX_CLEAR_STATUS(HMI_RGL_PROP_EVENT); #if(HMI_BUFFER_NUMBER==HMI_TWO_BUFFER) index_free = (HMI_BUFFER_DIRTY_STR)(HMI_BCK_DIRTY - index_free); index_bck = (HMI_BUFFER_DIRTY_STR)(HMI_BCK_DIRTY - index_bck); #endif } #endif #elif defined( HMI_GRAPHIC_ST7513 )  #if HMI_PAGES_NUMBER>0  hmi_engine_get_dirty_zone_page(dirty_zone); if((dirty_zone[0].w > 0)&&(dirty_zone[0].h > 0)) {  hmi_engine_draw_page(dirty_zone);  }  #endif #elif defined(HMI_GRAPHIC_TWLIB) #if HMI_PAGES_NUMBER>0  #if HMI_RENDER_ALL_EXCEPT_BCK==NO hmi_not_render_mode();/*find not used win*/ hmi_clr_used_flag();/*clr used flag*/ hmi_engine_draw_page();/*find not used win*/ hmi_clear_no_used_win();/*clear not used win*/ hmi_clr_refrence_flag();/*clr refrence flag*/ hmi_render_mode();/*render mode*/ hmi_engine_draw_page(); hmi_off_no_used_win();  #else hmi_engine_draw_page(); #endif #endif #else #endif //hmi_driver_woking_status_flag=HMI_FRAMEBUFFER_FREE;/*frame buffer free flag*/ } else { #ifdef HMI_GRAPHIC_RGL if(HMI_GFX_GET_STATUS(HMI_RGL_PROP_EVENT)) { hmi_engine_draw_page_prop(); HMI_GFX_CLEAR_STATUS(HMI_RGL_PROP_EVENT); } #endif } }   void hmi_gfx_loop(HMI_TIME dt) { //static U32 tickCnt = 0; //static U32 calCnt = 0; //static U32 maxTime = 0; static BOOL isRender = FALSE; isRender =(!isRender); // if(FALSE == isRender) {  hmi_gfx_update(dt);  } //else {  hmi_gfx_render(); }  }  #if 0 void hmi_Loop(void) { hmi_gfx_loop(0.04); } #endif
