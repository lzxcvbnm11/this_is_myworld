/************************************************************************************************ PROJECT : simple_draw FILE : $Id: main.c 1164 2013-07-31 08:29:57Z florian.zimmermann $ ============================================================================ DESCRIPTION ============================================================================ C O P Y R I G H T ============================================================================ Copyright (c) 2013 - 2014 by Renesas Electronics (Europe) GmbH. Arcadiastrasse 10 D-40472 Duesseldorf Germany All rights reserved. ============================================================================ Purpose: only for testing, not for mass production  DISCLAIMER  LICENSEE has read, understood and accepted the terms and conditions defined in the license agreement, especially the usage rights. In any case, it is LICENSEE's responsibility to make sure that any user of the software complies with the terms and conditions of the signed license agreement.  SAMPLE CODE is not part of the licensed software, as such it must not be used in mass-production applications. It can only be used for evaluation and demonstration purposes at customer's premises listed in the signed license agreement. **************************************************************************** */  /******************************************************************************* Section: Includes */  #include "r_typedefs.h" /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Renesas basic types, e.g. uint32_t */ #include "r_bsp_api.h" /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Board support package */ #include "r_ddb_api.h" #include "r_cdi_api.h" #include "r_wm_api.h"  #include "main.h" #include "wm.h" #include "mem_init.h" #include "public.h" #include "config.h" #include "r_drw2d_os.h" #include "r_drw2d_api.h" #include "r_config_drw2d.h" #include "r_drw2d_ctx_cpu.h"  #include "r_config_vdce.h" #include "r_vdce_api.h" #include "r_spea_api.h"  #include "r_tick_api.h" #include "r_bsp_stdio_api.h" #include <string.h> #include "public.h" #include "hmi_manager.h" #include "com_public.h" #include "sys_public.h"  #define HMI_YY_ENABLE_TEXT 0  #if HMI_YY_ENABLE_TEXT #include "font.h" #include "font_data.h" #include "tp_font.h" #include "img.h" #endif  #include "clock_public.h" #include "dio_public.h" #include "wdt_public.h" #include "stbc_public.h" #include "adce_public.h" #include "pwm_public.h" #include "taub_public.h" #include "dspi_public.h" #include "rstc_public.h" #include "ism_public.h" #include "ostm_public.h" #include "rtca_public.h" #include "adm_public.h" #include "iom_public.h" #include "pwmm_public.h" #include "eed_public.h" #include "bpm_public.h" #include "lrm_public.h"  #include "sys_public.h" #include "rtc_public.h" #include "nvm_public.h" #include "illu_public.h" #include "bat_public.h" #include "crus_public.h" #include "stsmg_public.h"  #include "trip_public.h" #include "st_public.h" #include "tip_public.h" #include "odo_public.h" #include "acc_public.h" #include "pwr_public.h" #include "ssb_public.h" #include "ass_public.h" #include "scs_public.h" #include "led_public.h" #include "msg_public.h" #include "idle_public.h"  #include "com_public.h" #include "bat_public.h"   #include "hsd_public.h" #include "rst_public.h"   #include "avgFuelCsump_V2.h" #include "FuelLevelAlgorithm_V2.h" #include "RangeToEmptyAlgorithm_V2.h"  extern void hmi_gfx_loop(float dt); extern void hmi_init(void); /*********************************************************** Section: Global Variables */   /*********************************************************** Section: Local Defines */  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr bitmap width */ #define LOC_BMP_W (30) /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr bitmap height */ #define LOC_BMP_H (30) /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr bitmap size */ #define LOC_BMP_SIZE (LOC_BMP_W back_rle_256.c back_rle_2561.c black_king.c config.h font.h font_data.h fonts hmi_manager.c hmi_manager.h img.c img.h img_data.h img_drw2d.c img_drw2d.h img_format.h main.c main.h mem_init.c mem_init.h QD_HMI sfma.c wm.c wm.h LOC_BMP_H back_rle_256.c back_rle_2561.c black_king.c config.h font.h font_data.h fonts hmi_manager.c hmi_manager.h img.c img.h img_data.h img_drw2d.c img_drw2d.h img_format.h main.c main.h mem_init.c mem_init.h QD_HMI sfma.c wm.c wm.h 4)  #define YD_TEST_BMP_SIZE (24 back_rle_256.c back_rle_2561.c black_king.c config.h font.h font_data.h fonts hmi_manager.c hmi_manager.h img.c img.h img_data.h img_drw2d.c img_drw2d.h img_format.h main.c main.h mem_init.c mem_init.h QD_HMI sfma.c wm.c wm.h 24 back_rle_256.c back_rle_2561.c black_king.c config.h font.h font_data.h fonts hmi_manager.c hmi_manager.h img.c img.h img_data.h img_drw2d.c img_drw2d.h img_format.h main.c main.h mem_init.c mem_init.h QD_HMI sfma.c wm.c wm.h 4)   #define LOC_SF_BMP_W (64) #define LOC_SF_BMP_H (64) #define LOC_SF_ADDRESS_EX (0x10000000)  #define LOC_ON_SPRITE 0 #define LOC_OFF_SPRITE 1 #define LOC_RESUME_SPRITE 2 #define LOC_PAUSE_SPRITE 3 #define LOC_SEL_SPRITE 4  #define LOC_SEL_DIM 8  #define LOC_RLE_IMG_SIZE (240 back_rle_256.c back_rle_2561.c black_king.c config.h font.h font_data.h fonts hmi_manager.c hmi_manager.h img.c img.h img_data.h img_drw2d.c img_drw2d.h img_format.h main.c main.h mem_init.c mem_init.h QD_HMI sfma.c wm.c wm.h 320 back_rle_256.c back_rle_2561.c black_king.c config.h font.h font_data.h fonts hmi_manager.c hmi_manager.h img.c img.h img_data.h img_drw2d.c img_drw2d.h img_format.h main.c main.h mem_init.c mem_init.h QD_HMI sfma.c wm.c wm.h 4) extern const uint8_t loc_BackGrnd[LOC_RLE_IMG_SIZE]; //extern const uint8_t hmi_yd_font_bitmap_33[2*15];   /*********************************************************** Section: Local Variables */  /***********************************************************  Variable: loc_WmWindow  Pointer to the Window handles */ static r_wm_Window_t loc_RleWindow; static r_wm_Window_t loc_WmWindow; static r_wm_Window_t loc_SpriteWindow;   /***********************************************************  Variable: loc_Drw2dDev  Pointer to the Drw2D device handle */ r_drw2d_Device_t loc_Drw2dDev; extern const uint8_t yeed_font[16*16*2*26];  /*********************************************************** Variable: loc_Fb  Framebuffer information for Drw2D */ static r_drw2d_Framebuffer_t loc_Fb; static char locHMIGfxFinish; /*********************************************************** Variable: g_BlackKingBmp  the Bitmap (external) */ extern const uint8_t g_BlackKingBmp[LOC_BMP_SIZE]; extern const uint8_t g_yd_tstimg2[YD_TEST_BMP_SIZE]; extern const uint8_t g_yd_testImg[YD_TEST_BMP_SIZE];  //uint8_t isWarn = FALSE;  //uint8_t isVersion = TRUE; HMI_Page_ENUM mainPage = PAGE_HMI_Version;  extern r_cdi_Heap_t loc_lRAM_heap; extern r_cdi_Heap_t loc_VRAM_heap;  /*********************************************************** Variable: loc_DHDDev  DHD Drawing handle */ static struct r_drw2d_DeviceCPU_s loc_CPUDrwDev;  /*********************************************************** Variable: loc_ExitFlag  flag to test exit pathes */ static int8_t loc_ExitFlag = R_FALSE;   #if HMI_YY_ENABLE_TEXT static void *ydOldFontArial19; #endif   r_drw2d_Device_t* hmi_get_rgl_drw2dDevice(void) { return (&loc_Drw2dDev); }  void back_rle_256.c back_rle_2561.c black_king.c config.h font.h font_data.h fonts hmi_manager.c hmi_manager.h img.c img.h img_data.h img_drw2d.c img_drw2d.h img_format.h main.c main.h mem_init.c mem_init.h QD_HMI sfma.c wm.c wm.h hmi_get_rgl_deviceInternal(void) { return (NULL); } /*local ram ÷∏’Î∫Õvideo ram ÷∏’Î*/ r_cdi_Heap_t back_rle_256.c back_rle_2561.c black_king.c config.h font.h font_data.h fonts hmi_manager.c hmi_manager.h img.c img.h img_data.h img_drw2d.c img_drw2d.h img_format.h main.c main.h mem_init.c mem_init.h QD_HMI sfma.c wm.c wm.h hmi_get_CPU_heap(void) { return (&loc_lRAM_heap); } r_cdi_Heap_t back_rle_256.c back_rle_2561.c black_king.c config.h font.h font_data.h fonts hmi_manager.c hmi_manager.h img.c img.h img_data.h img_drw2d.c img_drw2d.h img_format.h main.c main.h mem_init.c mem_init.h QD_HMI sfma.c wm.c wm.h hmi_get_video_heap(void) { return (&loc_VRAM_heap); }     /*********************************************************** Section: Local Functions */  /***********************************************************  Function: ydSetRenderTarget  */  #if HMI_YY_ENABLE_TEXT static void* ydSetRenderTarget(void* Win) { r_drw2d_Framebuffer_t fb; fw_vovial_FbFormat_t fmt;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Init framebuffer struct */ fb.Flags = (r_drw2d_FramebufferFlags_t) 0; fb.Handle = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr not used currently */ FW_VOVIAL_GetBufferInfo(Win, &fmt, &fb.Buffer.Pitch, &fb.Buffer.Size.Width, &fb.Buffer.Size.Height); fb.Buffer.PixelFormat = LOC_DRW2D_FRAMEBUFFER_FORMAT; fb.Buffer.Data = FW_VOVIAL_GetFrameBuffer(Win); R_DRW2D_FramebufferSet(loc_Drw2dDev, &fb);  return fb.Buffer.Data; } #endif     /******************************************************************************* Function: loc_RenderTexture_intROM  Render function called each frame */ static void yd_TextureTest(r_drw2d_Rect_t *pRect, uint8_t index) { r_drw2d_Error_t ret = R_DRW2D_ERR_OK; r_drw2d_Rect_t rect; r_drw2d_Texture_t tex_argb32;  tex_argb32.Handle = R_NULL; tex_argb32.Flags = (r_drw2d_TextureFlags_t)0; tex_argb32.Buffer.Pitch = pRect->Size.Width; tex_argb32.Buffer.Size.Width = pRect->Size.Width; tex_argb32.Buffer.Size.Height = pRect->Size.Height; tex_argb32.Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_ARGB8888; if(index == 0) tex_argb32.Buffer.Data = (void*)g_yd_testImg; else if(index==1) tex_argb32.Buffer.Data = (void*)g_yd_tstimg2;  else { tex_argb32.Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_ARGB1555; tex_argb32.Buffer.Data = (void*)yeed_font; }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set texture */ ret |= R_DRW2D_CtxIdentity(loc_Drw2dDev); ret |= R_DRW2D_CtxTextureSet(loc_Drw2dDev, 0, &tex_argb32); ret |= R_DRW2D_CtxTransformMode(loc_Drw2dDev, R_DRW2D_TRANSFORM_NONE); // fastest ret |= R_DRW2D_CtxBlendMode(loc_Drw2dDev, R_DRW2D_BLENDMODE_SRC_OVER);  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Draw texture */ rect.Pos.X = R_DRW2D_2X(pRect->Pos.X); rect.Pos.Y = R_DRW2D_2X(pRect->Pos.Y); rect.Size.Width = R_DRW2D_2X(pRect->Size.Width); rect.Size.Height = R_DRW2D_2X(pRect->Size.Height);  ret |= R_DRW2D_TextureBlit(loc_Drw2dDev, 0, &rect);  if (R_DRW2D_ERR_OK != ret) { loc_Error(ret); } }  /*********************************************************** Section: Local Functions */  /***********************************************************   Function: loc_DRW2DErrorHandler  Error handler used for Drw2d errors */ static r_drw2d_Boolean_t loc_DRW2DErrorHandler(r_drw2d_Error_t Error, void *UserData) { loc_Error(1); return R_TRUE; }   /*********************************************************** Section: Local Functions */ /******************************************************************************* Function: loc_RenderClear  Render function called each frame */ static void loc_RenderClear(int32_t Frame) { r_drw2d_Error_t ret = R_DRW2D_ERR_OK;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set clear color and fill framebuffer */ ret |= R_DRW2D_CtxBgColor(loc_Drw2dDev, 0x00000000); ret |= R_DRW2D_FramebufferClear(loc_Drw2dDev);  if (R_DRW2D_ERR_OK != ret) { loc_Error(ret); } }   /******************************************************************************* Function: loc_RenderTexture_intROM  Render function called each frame */ static void loc_RenderTexture_intROM(int32_t Frame) { r_drw2d_Error_t ret = R_DRW2D_ERR_OK; r_drw2d_Rect_t rect; r_drw2d_Texture_t tex_argb32;  tex_argb32.Handle = R_NULL; tex_argb32.Flags = (r_drw2d_TextureFlags_t)0; tex_argb32.Buffer.Pitch = LOC_BMP_W; tex_argb32.Buffer.Size.Width = LOC_BMP_W; tex_argb32.Buffer.Size.Height = LOC_BMP_H; tex_argb32.Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_ARGB8888; tex_argb32.Buffer.Data = (void*)g_BlackKingBmp;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set texture */ ret |= R_DRW2D_CtxIdentity(loc_Drw2dDev); ret |= R_DRW2D_CtxTextureSet(loc_Drw2dDev, 0, &tex_argb32); ret |= R_DRW2D_CtxTransformMode(loc_Drw2dDev, R_DRW2D_TRANSFORM_NONE); // fastest ret |= R_DRW2D_CtxBlendMode(loc_Drw2dDev, R_DRW2D_BLENDMODE_SRC_OVER);  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Draw texture */ rect.Pos.X = R_DRW2D_2X(Frame); rect.Pos.Y = R_DRW2D_2X((LOC_DISPLAY_HEIGHT - 100) / 2); rect.Size.Width = R_DRW2D_2X(LOC_BMP_W); rect.Size.Height = R_DRW2D_2X(LOC_BMP_H);  ret |= R_DRW2D_TextureBlit(loc_Drw2dDev, 0, &rect);  if (R_DRW2D_ERR_OK != ret) { loc_Error(ret); } }  void HMI_Process_1000ms(void) { r_wm_WinBuffer_t buf; uint32_t frame; r_wm_Sprite_t sprite; int32_t ret = R_DRW2D_ERR_OK; r_wm_WinColorFmt_t colorFormat;  HMI_WarnPop_ENUM index = POP_HMI_NONE; static U8 cnt = 0; U8 pwrMode ;   loc_Fb.Buffer.Data = R_WM_WindowNewDrawBufGet(LOC_WM_UNIT, &loc_WmWindow); ret |= R_DRW2D_FramebufferSet(loc_Drw2dDev, &loc_Fb);  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr render onto this backbuffer and wait for GPU to finish*/ loc_RenderClear(frame); HMI_showBottom(); if(PAGE_HMI_Version == mainPage ) { HMI_showVersionPage(); cnt ++; if(cnt >= 10) { cnt = 0; mainPage = PAGE_HMI_ODO; }  } else {  if(ILLU_GetWelComeSts()) { HMI_showWarnPage(HMI_WARN_TYPE_DOOROPEN); } else { MSG_GetPopIndex(&index); if(index != INDEX_WARN_NULL) { warnIndex = index; HMI_showWarnPage(HMI_WARN_TYPE_MSG); } else { HMI_showMainWindowPage(); } } }  R_DRW2D_GpuFinish(loc_Drw2dDev, R_DRW2D_FINISH_WAIT); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr let WM care about the handling of the buffer swap */ R_WM_WindowSwap(LOC_WM_UNIT, &loc_WmWindow); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr animate the sprite window, too */ R_WM_WindowEnable(LOC_WM_UNIT,&loc_SpriteWindow); R_WM_FrameEndMark(LOC_WM_UNIT, 0); R_WM_FrameWait(LOC_WM_UNIT, 0); }   /******************************************************************************* Function: loc_RenderTexture_SFlash  Render function called each frame */ static void loc_RenderTexture_SFlash(int32_t Frame) { r_drw2d_Error_t ret = R_DRW2D_ERR_OK; r_drw2d_Rect_t rect; r_drw2d_Texture_t tex_argb32;  tex_argb32.Handle = R_NULL; tex_argb32.Flags = (r_drw2d_TextureFlags_t)0; tex_argb32.Buffer.Pitch = LOC_SF_BMP_W; tex_argb32.Buffer.Size.Width = LOC_SF_BMP_W; tex_argb32.Buffer.Size.Height = LOC_SF_BMP_H; tex_argb32.Buffer.PixelFormat = R_DRW2D_PIXELFORMAT_ARGB8888; tex_argb32.Buffer.Data = (void*)LOC_SF_ADDRESS_EX;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set texture */ ret |= R_DRW2D_CtxIdentity(loc_Drw2dDev); ret |= R_DRW2D_CtxTextureSet(loc_Drw2dDev, 0, &tex_argb32); ret |= R_DRW2D_CtxTransformMode(loc_Drw2dDev, R_DRW2D_TRANSFORM_NONE); // fastest ret |= R_DRW2D_CtxBlendMode(loc_Drw2dDev, R_DRW2D_BLENDMODE_SRC_OVER);  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Draw texture */ rect.Pos.X = R_DRW2D_2X(Frame); rect.Pos.Y = R_DRW2D_2X(LOC_DISPLAY_HEIGHT - 100); rect.Size.Width = R_DRW2D_2X(LOC_SF_BMP_W); rect.Size.Height = R_DRW2D_2X(LOC_SF_BMP_H);  ret |= R_DRW2D_TextureBlit(loc_Drw2dDev, 0, &rect);  if (R_DRW2D_ERR_OK != ret) { loc_Error(ret); } }  /******************************************************************************* Function: loc_App The render loop *******************************************************************************/ #define R_ISM_CHANNEL_EN0 ( 0x01 ) #define R_ISM_CHANNEL_EN1 ( 0x02 ) #define R_ISM_CHANNEL_EN2 ( 0x04 ) #define R_ISM_CHANNEL_EN3 ( 0x08 ) #define R_ISM_CHANNEL_EN4 ( 0x10 )  #define USEPOINTCOLLECTION (0) #define CORRENTMETER (0)   static void loc_App(void) { r_wm_WinBuffer_t buf;  uint32_t frame; r_wm_Sprite_t sprite; int32_t ret = R_DRW2D_ERR_OK; r_drw2d_Rect_t rect; r_wm_WinColorFmt_t colorFormat; char text[10]={0}; WARN_EVENT_ENUM index = INDEX_WARN_NULL; U8 pwrMode ; U8 i = 0; static U32 tickCnt = 0; static U32 calCnt = 0; U32 maxTime = 0; loc_StartSFMA();  loc_InitWM(&loc_lRAM_heap, &loc_VRAM_heap); R_WM_FrameEndMark(LOC_WM_UNIT, 0); R_WM_FrameWait(LOC_WM_UNIT, 0);    /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr start up gfx engine */ ret |= R_DRW2D_Init(); ret |= R_DRW2D_GlobalErrCallbackSet(&loc_DRW2DErrorHandler, R_NULL); ret |= R_DRW2D_Open(LOC_DRW2D_UNIT, R_DRW2D_UNIT_DHD0, &loc_CPUDrwDev, &loc_Drw2dDev);  mainPage = PAGE_HMI_WARN;  hmi_init();  WDT_Init(); #if USEPOINTCOLLECTION while(ISM_isZPDFinish((R_ISM_CHANNEL_EN0|R_ISM_CHANNEL_EN4),TRUE) ==  FALSE){ R_TICK_WaitMS(0,2); WDT_Feed();  } ISM_SetWorkMode(MOTOR_NORMAL); for(frame=0;frame < 20000;frame++){ unsigned short tmp;   /* if(frame & 0x01){ ISM_Move_Motors(0,0); ISM_Move_Motors(4,0); }else{ ISM_Move_Motors(0,270*12); ISM_Move_Motors(4,270*12); } */ #if CORRENTMETER  tmp = frame % 7; switch(tmp){ case 0: ISM_Move_Motors(4,0*12); break; case 1: ISM_Move_Motors(4,45*12); break; case 2: ISM_Move_Motors(4,90*12); break; case 3: ISM_Move_Motors(4,135*12); break; case 4: ISM_Move_Motors(4,180*12); break; case 5: ISM_Move_Motors(4,225*12); break; case 6: ISM_Move_Motors(4,270*12); break; } #else tmp = frame % 9; switch(tmp){ case 0: ISM_Move_Motors(0,33.75*12); break; case 1: ISM_Move_Motors(0,67.5*12); break; case 2: ISM_Move_Motors(0,101.25*12); break; case 3: ISM_Move_Motors(0,135*12); break; case 4: ISM_Move_Motors(0,168.75*12); break; case 5: ISM_Move_Motors(0,202.5*12); break; case 6: ISM_Move_Motors(0,236.25*12); break; case 7: ISM_Move_Motors(0,270*12); break; case 8: ISM_Move_Motors(0,0*12); break; } #endif while((ISM_GetWorkStatus(0)==FALSE) || (ISM_GetWorkStatus(4)==FALSE)){ R_TICK_WaitMS(0,2); WDT_Feed(); } for(tmp=0;tmp<500;tmp++){ R_TICK_WaitMS(0,2); WDT_Feed(); } } #endif  for (frame = 0; loc_ExitFlag == R_FALSE; frame++) {   SYS_ProcessManage(); }  ret |= R_WM_WindowDisable(LOC_WM_UNIT, &loc_SpriteWindow); ret |= R_WM_WindowDisable(LOC_WM_UNIT, &loc_WmWindow); ret |= R_WM_WindowDisable(LOC_WM_UNIT, &loc_RleWindow);  R_WM_FrameEndMark(LOC_WM_UNIT, 0); R_WM_FrameWait(LOC_WM_UNIT, 0);   ret |= R_DRW2D_Close(loc_Drw2dDev); ret |= R_DRW2D_Exit();  ret |= R_WM_SpriteDisable(LOC_WM_UNIT, &sprite); ret |= R_WM_SpriteDelete(LOC_WM_UNIT, &sprite); ret |= R_WM_WindowDelete(LOC_WM_UNIT, &loc_SpriteWindow); ret |= R_WM_WindowDelete(LOC_WM_UNIT, &loc_WmWindow); ret |= R_WM_WindowDelete(LOC_WM_UNIT, &loc_RleWindow);  R_WM_FrameEndMark(LOC_WM_UNIT, 0); R_WM_FrameWait(LOC_WM_UNIT, 0);  ret |= R_WM_DevDeinit(LOC_WM_UNIT);  loc_StopSFMA(); if (R_DRW2D_ERR_OK != ret) { loc_Error(ret); } } /******************************************************************************* Function: loc_Error This function is called when error occurs The application hangs in there. *********************************************************************************/ void loc_Error(int32_t Err) { while (Err) { } }  /******************************************************************************* Function: main entry after startup ********************************************************************************/ int32_t main(void) { //WDT_Init();  //STBC_WakeupType();  R_BSP_ZS12_init();  loc_SetupMemManager();  loc_App();  return(0); }  char GetHMIGfxFinish(void) { char res =FALSE;  if (locHMIGfxFinish) { locHMIGfxFinish =0; res =TRUE; }  return(res); }
