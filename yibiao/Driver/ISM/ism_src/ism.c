 #include "ism_info.inc" #include "Ostm_public.h"    U8 Ism_Init = RET_FAIL;  static U8 Ism_InitStatus = FALSE; static U8 Ism_WorkStatus = FALSE; static U8 Ism_ZpdStatus = FALSE;  #define ISM_NUM_CHMAX (6) typedef struct{ unsigned int direct; //bit0:1 - ch0 forward 0 - ch0 backward bit1:1 - ch1 forward 0 - ch1 backward unsigned int zpdstatus; unsigned int quadrant[ISM_NUM_CHMAX]; unsigned int mvstep[ISM_NUM_CHMAX]; unsigned int dststep[ISM_NUM_CHMAX]; unsigned int curstep[ISM_NUM_CHMAX]; unsigned short AccelerationCtl[ISM_NUM_CHMAX]; unsigned short DecelerationCtl[ISM_NUM_CHMAX]; unsigned short mvctl[ISM_NUM_CHMAX]; }ST_MOTORCTL;  static ST_MOTORCTL g_MotorCtl;  static unsigned int g_quadrant=0,g_Angle=0;    #define ISM_UNIT_0 0 void ISM_Init(void) { Ism_Init = R_ISM_Init(ISM_UNIT_0);  memset((unsigned char*)&g_MotorCtl,0,sizeof(g_MotorCtl));  // (*(unsigned int *)0xFFF00260) = 0x08; (*(unsigned int *)&(rism_p_zs12->gctl)) = 0; (*(unsigned int *)&(rism_p_zs12->gctl)) = 0x00010000; (*(unsigned int *)&(rism_p_zs12->gstr)) = 0; (*(unsigned int *)&(rism_p_zs12->gcfg)) = 0x00010000; (*(unsigned int *)&(rism_p_zs12->gstc)) = 0xFF; //clear irq statu mark (*(unsigned int *)&(rism_p_zs12->ccmr[0])) = 0x00001000; // (*(unsigned int *)&(rism_p->ccmr[1])) = 0; // (*(unsigned int *)&(rism_p->ccmr[2])) = 0; // (*(unsigned int *)&(rism_p->ccmr[3])) = 0; (*(unsigned int *)&(rism_p_zs12->ccmr[4])) = 0x00001000; // (*(unsigned int *)&(rism_p->ccmr[5])) = 0; (*(unsigned int *)&(rism_p_zs12->cioc[0])) = 0x00C00000; // (*(unsigned int *)&(rism_p->cioc[1])) = 0x03C00000; // (*(unsigned int *)&(rism_p->cioc[2])) = 0x03C00000; // (*(unsigned int *)&(rism_p->cioc[3])) = 0x03C00000; (*(unsigned int *)&(rism_p_zs12->cioc[4])) = 0x00C00000; // (*(unsigned int *)&(rism_p->cioc[5])) = 0x03C00000; //(*(unsigned int *)&(rism_p->ccmp[0])) = (512<<10)|512; // (*(unsigned int *)0xFFF00094) = 0x3F; /* rism_p_zs12->czc[0] = 0; rism_p_zs12->czc[4] = 0; (*(unsigned int *)0xFFF0009C) = 0; (*(unsigned int *)0xFFF000A4) = 0; (*(unsigned int *)0xFFF000A8) = 0x3F; */  }    U8 ISM_GetInitStatus(void) { return Ism_Init; }    #define ACCELERATIONSTEP2 (64*5) #define ACCELERATIONSW (16)  /*************************************************** ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Function: ISM_StartZpd ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Description: start ZPD. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Parameters: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Input: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h ismIndex -specify channel. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Returns: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h FALSE(0): failure ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h TRUE(1): success. * ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h $Create & Verlog:$ ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Author:Qinhui.Shen Date:2016-12-04 Version:V1.0 ****************************************************/ U8 ISM_StartZpd(U8 ismIndex) { U8 retVal = RET_OK; #if 0 switch (ismIndex) { case ISM_CH0: ISM0CCZP0 = 1; break; case ISM_CH1: ISM0CCZP1 = 1; break; case ISM_CH2: ISM0CCZP2 = 1; break; case ISM_CH3: ISM0CCZP3 = 1; break; case ISM_CH4: ISM0CCZP4 = 1; break; case ISM_CH5: ISM0CCZP5 = 1; break; default: retVal = RET_INVALID; break; } if (RET_OK == retVal) { Ism_ZpdStatus = TRUE; Ism_WorkStatus = RET_BUSY; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Do Nothing. */ } #else  Ism_ZpdStatus = FALSE; // g_MotorCtl.mvstep[ismIndex] = 14*340; g_MotorCtl.mvstep[ismIndex] = 64*340; g_MotorCtl.zpdstatus &= ~(1<<ismIndex); g_MotorCtl.direct &= ~(1<<ismIndex); g_MotorCtl.AccelerationCtl[ismIndex] = ACCELERATIONSTEP2; g_MotorCtl.DecelerationCtl[ismIndex] = ACCELERATIONSTEP2;  #endif return( retVal); }   U8 ISM_StopZpd(U8 ismIndex)  { U8 retVal = RET_OK; #if 0  if (ismIndex >= ISM_CH_ALL) { retVal = RET_FAIL; } else { ISM0CCZP0 = 0; SET_BIT(ISM0CCLZP, ismIndex); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr clear the ISMnGIP (Global Interrupt Pending) status GIP.SSRE using the ISMnGSTC, incase this reports the position has already been reached by a previous operation. */ SET_BIT(ISM0GIPCLRE, ismIndex); ISM0GIPCLDO = 1; ISM0GIPCLAD = 1; } if (RET_OK == retVal) { Ism_ZpdStatus = FALSE; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Do Nothing. */ } #else #endif return( retVal ); }      /*************************************************** ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Function: ISM_MoveBackward ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Description: ISM move to the angle degree decrease' direction. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Parameters: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Input: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h ismIndex -specify channel. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Step - the step that want to move. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Returns: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h FALSE(0): failure ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h TRUE(1): success. * ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h $Create & Verlog:$ ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Author:Qinhui.Shen Date:2016-12-04 Version:V1.0 ****************************************************/ U8 ISM_MoveBackward(U8 ismIndex,U16 Step) { U32 pos = 0; U8 retval = RET_OK;  //printf("Backward = %d\r\n",Step); #if 0 retval = ism_GetCMTargetPos(ismIndex, &pos); if (RET_OK == retval) { pos -= Step; retval = ism_SetCMTargetPos(ismIndex, pos); } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Do Nothing */ } #else  if(ismIndex < 6){ // g_MotorCtl.direct &= ~(1<<ismIndex); // g_MotorCtl.mvstep[ismIndex] = Step/3;   #if 0 if(g_MotorCtl.mvstep[ismIndex]){ if(g_MotorCtl.direct & pos){ if(g_MotorCtl.mvstep[ismIndex] >= Step){ g_MotorCtl.mvstep[ismIndex] -= Step; }else{ g_MotorCtl.direct &= ~pos; g_MotorCtl.mvstep[ismIndex] = Step-g_MotorCtl.mvstep[ismIndex]; } }else{ g_MotorCtl.mvstep[ismIndex] += Step; } }else{ g_MotorCtl.direct &= ~pos; g_MotorCtl.mvstep[ismIndex] = Step; } #else pos = (1<<ismIndex);  if(g_MotorCtl.mvstep[ismIndex]){ g_MotorCtl.dststep[ismIndex] = Step; }else{ // Step = Step*7/6; Step = Step*16/3; if(g_MotorCtl.curstep[ismIndex] >= Step){ g_MotorCtl.mvstep[ismIndex] = g_MotorCtl.curstep[ismIndex]-Step; g_MotorCtl.direct &= ~pos; }else{ g_MotorCtl.direct |= pos; g_MotorCtl.mvstep[ismIndex] = Step-g_MotorCtl.curstep[ismIndex]; } g_MotorCtl.curstep[ismIndex] = Step; g_MotorCtl.dststep[ismIndex] = 0;  if(g_MotorCtl.mvstep[ismIndex] >= (ACCELERATIONSTEP2*2)){ g_MotorCtl.AccelerationCtl[ismIndex] = ACCELERATIONSTEP2; g_MotorCtl.DecelerationCtl[ismIndex] = ACCELERATIONSTEP2; }else{ g_MotorCtl.AccelerationCtl[ismIndex] = (g_MotorCtl.mvstep[ismIndex]/2); g_MotorCtl.DecelerationCtl[ismIndex] = g_MotorCtl.mvstep[ismIndex] - g_MotorCtl.AccelerationCtl[ismIndex]; }  } #endif }  #endif return retval; }  /*************************************************** ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Function: ISM_MoveForward ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Description: ISM move to the angle degree increase' direction. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Parameters: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Input: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h ismIndex -specify channel. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Step - the step that want to move. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Returns: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h FALSE(0): failure ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h TRUE(1): success. * ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h $Create & Verlog:$ ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Author:Qinhui.Shen Date:2016-12-04 Version:V1.0 ****************************************************/ U8 ISM_MoveForward(U8 ismIndex,U16 Step) { U32 pos = 0; U8 retval = RET_OK; #if 0 retval = ism_GetCMTargetPos(ismIndex, &pos); if (RET_OK == retval) { pos += Step; retval = ism_SetCMTargetPos(ismIndex, pos); } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Do Nothing */ } #else  //printf("Forward = %d\r\n",Step); if(ismIndex < 6){  #if 0 if(g_MotorCtl.mvstep[ismIndex]){ if(g_MotorCtl.direct & pos){ g_MotorCtl.mvstep[ismIndex] += Step; }else{ if(g_MotorCtl.mvstep[ismIndex] >= Step){ g_MotorCtl.mvstep[ismIndex] -= Step; }else{ g_MotorCtl.direct |= pos; g_MotorCtl.mvstep[ismIndex] = Step-g_MotorCtl.mvstep[ismIndex]; } } }else{ g_MotorCtl.direct |= pos; g_MotorCtl.mvstep[ismIndex] = Step; } #else pos = (1<<ismIndex);  if(g_MotorCtl.mvstep[ismIndex]) { g_MotorCtl.dststep[ismIndex] = Step; } else { // Step = Step*7/6; Step = Step*16/3; if(g_MotorCtl.curstep[ismIndex] >= Step) { g_MotorCtl.mvstep[ismIndex] = g_MotorCtl.curstep[ismIndex]-Step; g_MotorCtl.direct &= ~pos; } else { g_MotorCtl.direct |= pos; g_MotorCtl.mvstep[ismIndex] = Step-g_MotorCtl.curstep[ismIndex]; } g_MotorCtl.curstep[ismIndex] = Step; g_MotorCtl.dststep[ismIndex] = 0; if(g_MotorCtl.mvstep[ismIndex] >= (ACCELERATIONSTEP2*2)){ g_MotorCtl.AccelerationCtl[ismIndex] = ACCELERATIONSTEP2; g_MotorCtl.DecelerationCtl[ismIndex] = ACCELERATIONSTEP2; }else{ g_MotorCtl.AccelerationCtl[ismIndex] = (g_MotorCtl.mvstep[ismIndex]/2); g_MotorCtl.DecelerationCtl[ismIndex] = g_MotorCtl.mvstep[ismIndex] - g_MotorCtl.AccelerationCtl[ismIndex]; } } #endif } #endif return retval; }  /*************************************************** ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Function: ISM_GetZPDStatus ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Description: ISM Zero Position Detection. (Machine Zero Position) ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Parameters: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Input: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h ismIndex -specify channel. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Returns: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h FALSE(0): not ZPD work mode. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h TRUE(1): ZPD work mode. * ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h $Create & Verlog:$ ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Author:Qinhui.Shen Date:2016-12-04 Version:V1.0 ****************************************************/ U8 ISM_GetZPDStatus(U8 ismIndex) { if(ismIndex < 6) { if(g_MotorCtl.mvstep[ismIndex]) { Ism_ZpdStatus = TRUE ; } else { Ism_ZpdStatus = FALSE; }  return Ism_ZpdStatus; }  return TRUE; // return Ism_ZpdStatus; }  /*************************************************** ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Function: ISM_GetWorkStatus ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Description: get ISM work status. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Parameters: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h input: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h ismIndex - specify the ISM channel. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Returns: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h FALSE:idle status. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h TRUE: busy status. * ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h $Create & Verlog:$ ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Author:Qinhui.Shen Date:2016-12-04 Version:V1.0 ****************************************************/ U8 ISM_GetWorkStatus(U8 ismIndex) { if(ismIndex < 6) { if(g_MotorCtl.mvstep[ismIndex]) { //Ism_WorkStatus = TRUE ; return TRUE; } else { return FALSE; // Ism_WorkStatus = FALSE; } //return Ism_WorkStatus; } return TRUE; // return Ism_ZpdStatus; }    /*************************************************** ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Function: ISM_ChnlReset ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Description: reset the specific ISM channel. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Parameters: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Input: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Ch - specify channel. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Returns: ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h FALSE(0): reset fail. ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h TRUE(1): reset success. * ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h $Create & Verlog:$ ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Author:Qinhui.Shen Date:2016-12-04 Version:V1.0 ****************************************************/ U8 ISM_ChnlReset(U8 Ch) { U8 retVal = RET_OK; U32 k = 0;  #if 1 #else /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Force the soft reset, this causes a recirculation via VDD */ ISM0GGEN = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Clear registers that shall be cleared after a soft reset */ ISM0GGCE = 0; ISM0CCEN = 0x00; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr all off */ ISM0GIPCLRE = 0x3F; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr all en */ ISM0GIPCLDO = 1; ISM0GIPCLAD = 1; ISM0CZMT = 0x00; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr all off */ ISM0CCLZP = 0x00; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr all off */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr All channel */ switch (Ch) { case ISM_CH0: ISM0CCZP0 = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ch0 */ ISM0CCQI0 = R_ISM_QUADRANT_1; ISM0CCHP0 = R_ISM_PWMDUTY_0; ISM0CCVP0 = R_ISM_PWMDUTY_0; ISM0CIOC0 &= ~R_ISM_DIRECT_EN; break; case ISM_CH1: ISM0CCZP1 = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ch1 */ ISM0CCQI1 = R_ISM_QUADRANT_1; ISM0CCHP1 = R_ISM_PWMDUTY_0; ISM0CCVP1 = R_ISM_PWMDUTY_0; ISM0CIOC1 &= ~R_ISM_DIRECT_EN; break; case ISM_CH2: ISM0CCZP2 = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ch2 */ ISM0CCQI2 = R_ISM_QUADRANT_1; ISM0CCHP2 = R_ISM_PWMDUTY_0; ISM0CCVP2 = R_ISM_PWMDUTY_0; ISM0CIOC2 &= ~R_ISM_DIRECT_EN; break; case ISM_CH3: ISM0CCZP3 = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ch3 */ ISM0CCQI3 = R_ISM_QUADRANT_1; ISM0CCHP3 = R_ISM_PWMDUTY_0; ISM0CCVP3 = R_ISM_PWMDUTY_0; ISM0CIOC3 &= ~R_ISM_DIRECT_EN; break; case ISM_CH4: ISM0CCZP4 = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ch4 */ ISM0CCQI4 = R_ISM_QUADRANT_1; ISM0CCHP4 = R_ISM_PWMDUTY_0; ISM0CCVP4 = R_ISM_PWMDUTY_0; ISM0CIOC4 &= ~R_ISM_DIRECT_EN; break; case ISM_CH5: ISM0CCZP5 = 0; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ch5 */ ISM0CCQI5 = R_ISM_QUADRANT_1; ISM0CCHP5 = R_ISM_PWMDUTY_0; ISM0CCVP5 = R_ISM_PWMDUTY_0; ISM0CIOC5 &= ~R_ISM_DIRECT_EN; break; default: retVal = RET_INVALID; break; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SW Delay to allow the recirculation calm down */ for( k = 0; k < R_ISM_RECOVERYDELAY; k++ ) { ; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr nop */ } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Disable all outputs, after inductive load is discharged */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Requirement for this depends on implementation of drivers */  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Re-Enable ISM */ ISM0GGEN = 1;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SW Delay to feed the cleared PWM settings */ for( k = 0; k < R_ISM_RECOVERYDELAY; k++ ) { ; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr nop */ } #endif return retVal; }     #if 1   typedef struct { volatile uint32_t cvp : 10; volatile uint32_t chp : 10; volatile uint32_t cqi : 2; volatile uint32_t UNUSED : 10; }rism_pwmset_t;    #define NEWSTEP (32*4) static const rism_pwmset_t PWMSETTBL[NEWSTEP] = {{ 0x000L, 0x3FFL, 0x3L,0L }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr 4th quadrant dir. 0, speed 0 */ { 0x032L, 0x3FDL, 0x3L ,0L }, { 0x064L, 0x3FAL, 0x3L, 0L }, { 0x096L, 0x3F3L, 0x3L, 0L }, { 0x0C7L, 0x3EBL, 0x3L, 0L }, { 0x0F8L, 0x3E0L, 0x3L, 0L }, { 0x128L, 0x3D2L, 0x3L, 0L }, { 0x158L, 0x3C3L, 0x3L, 0L }, { 0x187L, 0x3B1L, 0x3L, 0L }, { 0x1B5L, 0x39CL, 0x3L, 0L }, { 0x1E2L, 0x386L, 0x3L, 0L }, { 0x20DL, 0x36DL, 0x3L, 0L }, { 0x238L, 0x352L, 0x3L, 0L }, { 0x261L, 0x335L, 0x3L, 0L }, { 0x288L, 0x316L, 0x3L, 0L }, { 0x2AFL, 0x2F5L, 0x3L, 0L }, { 0x2D3L, 0x2D3L, 0x3L, 0L }, { 0x2F5L, 0x2AFL, 0x3L, 0L }, { 0x316L, 0x288L, 0x3L, 0L }, { 0x335L, 0x261L, 0x3L, 0L }, { 0x352L, 0x238L, 0x3L, 0L }, { 0x36DL, 0x20DL, 0x3L,0L }, { 0x386L, 0x1E2L, 0x3L, 0L }, { 0x39CL, 0x1B5L, 0x3L, 0L }, { 0x3B1L, 0x187L, 0x3L, 0L }, { 0x3C3L, 0x158L, 0x3L, 0L }, { 0x3D2L, 0x128L, 0x3L, 0L }, { 0x3E0L, 0x0F8L, 0x3L, 0L }, { 0x3EBL, 0x0C7L, 0x3L, 0L }, { 0x3F3L, 0x096L, 0x3L, 0L }, { 0x3FAL, 0x064L, 0x3L, 0L }, { 0x3FDL, 0x032L, 0x3L, 0L },  { 0x3FFL, 0x000L, 0x2L, 0L }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr 3rd quadrant dir. 0, speed 0 */ { 0x3FDL, 0x032L, 0x2L, 0L }, { 0x3FAL, 0x064L, 0x2L, 0L }, { 0x3F3L, 0x096L, 0x2L, 0L }, { 0x3EBL, 0x0C7L, 0x2L, 0L }, { 0x3E0L, 0x0F8L, 0x2L, 0L }, { 0x3D2L, 0x128L, 0x2L, 0L }, { 0x3C3L, 0x158L, 0x2L, 0L }, { 0x3B1L, 0x187L, 0x2L, 0L }, { 0x39CL, 0x1B5L, 0x2L, 0L }, { 0x386L, 0x1E2L, 0x2L, 0L }, { 0x36DL, 0x20DL, 0x2L, 0L }, { 0x352L, 0x238L, 0x2L, 0L }, { 0x335L, 0x261L, 0x2L, 0L }, { 0x316L, 0x288L, 0x2L, 0L }, { 0x2F5L, 0x2AFL, 0x2L, 0L }, { 0x2D3L, 0x2D3L, 0x2L, 0L }, { 0x2AFL, 0x2F5L, 0x2L, 0L }, { 0x288L, 0x316L, 0x2L, 0L }, { 0x261L, 0x335L, 0x2L, 0L }, { 0x238L, 0x352L, 0x2L, 0L }, { 0x20DL, 0x36DL, 0x2L, 0L }, { 0x1E2L, 0x386L, 0x2L, 0L }, { 0x1B5L, 0x39CL, 0x2L, 0L }, { 0x187L, 0x3B1L, 0x2L, 0L }, { 0x158L, 0x3C3L, 0x2L, 0L }, { 0x128L, 0x3D2L, 0x2L, 0L }, { 0x0F8L, 0x3E0L, 0x2L, 0L }, { 0x0C7L, 0x3EBL, 0x2L, 0L }, { 0x096L, 0x3F3L, 0x2L, 0L }, { 0x064L, 0x3FAL, 0x2L, 0L }, { 0x032L, 0x3FDL, 0x2L, 0L },  { 0x000L, 0x3FFL, 0x1L, 0L }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr 2nd quadrant dir. 0, speed 0 */ { 0x032L, 0x3FDL, 0x1L, 0L }, { 0x064L, 0x3FAL, 0x1L, 0L }, { 0x096L, 0x3F3L, 0x1L, 0L }, { 0x0C7L, 0x3EBL, 0x1L, 0L }, { 0x0F8L, 0x3E0L, 0x1L, 0L }, { 0x128L, 0x3D2L, 0x1L, 0L }, { 0x158L, 0x3C3L, 0x1L, 0L }, { 0x187L, 0x3B1L, 0x1L, 0L }, { 0x1B5L, 0x39CL, 0x1L, 0L }, { 0x1E2L, 0x386L, 0x1L, 0L }, { 0x20DL, 0x36DL, 0x1L, 0L }, { 0x238L, 0x352L, 0x1L, 0L }, { 0x261L, 0x335L, 0x1L, 0L }, { 0x288L, 0x316L, 0x1L, 0L }, { 0x2AFL, 0x2F5L, 0x1L, 0L }, { 0x2D3L, 0x2D3L, 0x1L, 0L }, { 0x2F5L, 0x2AFL, 0x1L, 0L }, { 0x316L, 0x288L, 0x1L, 0L }, { 0x335L, 0x261L, 0x1L, 0L }, { 0x352L, 0x238L, 0x1L, 0L }, { 0x36DL, 0x20DL, 0x1L, 0L }, { 0x386L, 0x1E2L, 0x1L, 0L }, { 0x39CL, 0x1B5L, 0x1L, 0L }, { 0x3B1L, 0x187L, 0x1L, 0L }, { 0x3C3L, 0x158L, 0x1L, 0L }, { 0x3D2L, 0x128L, 0x1L, 0L }, { 0x3E0L, 0x0F8L, 0x1L, 0L }, { 0x3EBL, 0x0C7L, 0x1L, 0L }, { 0x3F3L, 0x096L, 0x1L, 0L }, { 0x3FAL, 0x064L, 0x1L, 0L }, { 0x3FDL, 0x032L, 0x1L, 0L },  { 0x3FFL, 0x000L, 0x0L, 0L }, /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr 1st quadrant dir. 0, speed 0 */ { 0x3FDL, 0x032L, 0x0L, 0L }, { 0x3FAL, 0x064L, 0x0L, 0L }, { 0x3F3L, 0x096L, 0x0L, 0L }, { 0x3EBL, 0x0C7L, 0x0L, 0L }, { 0x3E0L, 0x0F8L, 0x0L, 0L }, { 0x3D2L, 0x128L, 0x0L, 0L }, { 0x3C3L, 0x158L, 0x0L, 0L }, { 0x3B1L, 0x187L, 0x0L, 0L }, { 0x39CL, 0x1B5L, 0x0L, 0L }, { 0x386L, 0x1E2L, 0x0L, 0L }, { 0x36DL, 0x20DL, 0x0L, 0L }, { 0x352L, 0x238L, 0x0L, 0L }, { 0x335L, 0x261L, 0x0L, 0L }, { 0x316L, 0x288L, 0x0L, 0L }, { 0x2F5L, 0x2AFL, 0x0L, 0L }, { 0x2D3L, 0x2D3L, 0x0L, 0L }, { 0x2AFL, 0x2F5L, 0x0L, 0L }, { 0x288L, 0x316L, 0x0L, 0L }, { 0x261L, 0x335L, 0x0L, 0L }, { 0x238L, 0x352L, 0x0L, 0L }, { 0x20DL, 0x36DL, 0x0L, 0L }, { 0x1E2L, 0x386L, 0x0L, 0L }, { 0x1B5L, 0x39CL, 0x0L, 0L }, { 0x187L, 0x3B1L, 0x0L, 0L }, { 0x158L, 0x3C3L, 0x0L, 0L }, { 0x128L, 0x3D2L, 0x0L, 0L }, { 0x0F8L, 0x3E0L, 0x0L, 0L }, { 0x0C7L, 0x3EBL, 0x0L, 0L }, { 0x096L, 0x3F3L, 0x0L, 0L }, { 0x064L, 0x3FAL, 0x0L, 0L }, { 0x032L, 0x3FDL, 0x0L, 0L } };  unsigned int *g_pwmsettbl = (unsigned int*)PWMSETTBL;  void ISM_manager(void){  unsigned int i,dir;  for(i=0;i<ISM_NUM_CHMAX;i++) { if(g_MotorCtl.mvstep[i]) {   if(g_MotorCtl.AccelerationCtl[i]){  if(g_MotorCtl.DecelerationCtl[i] >= ACCELERATIONSTEP2){  dir = g_MotorCtl.AccelerationCtl[i]/ACCELERATIONSW;  }else{ dir = (ACCELERATIONSTEP2-g_MotorCtl.DecelerationCtl[i]+g_MotorCtl.AccelerationCtl[i])/ACCELERATIONSW; } if(g_MotorCtl.mvctl[i] < dir){ g_MotorCtl.mvctl[i]++; continue; }  g_MotorCtl.AccelerationCtl[i]--; g_MotorCtl.mvctl[i]=0;  }else if(g_MotorCtl.mvstep[i] < g_MotorCtl.DecelerationCtl[i]){ if(g_MotorCtl.DecelerationCtl[i] >= ACCELERATIONSTEP2){  dir = (g_MotorCtl.DecelerationCtl[i]-g_MotorCtl.mvstep[i])/ACCELERATIONSW;  }else{ dir = (ACCELERATIONSTEP2 - g_MotorCtl.mvstep[i])/ACCELERATIONSW; } if(g_MotorCtl.mvctl[i] < dir){ g_MotorCtl.mvctl[i]++; continue; } g_MotorCtl.mvctl[i]=0; }  dir = 1<<i;  g_MotorCtl.mvstep[i]--; #endif if(g_MotorCtl.direct & dir) {  if(g_MotorCtl.quadrant[i]) { g_MotorCtl.quadrant[i]--; } else { g_MotorCtl.quadrant[i] = NEWSTEP-1; } } else { g_MotorCtl.quadrant[i]++; if(g_MotorCtl.quadrant[i] >= NEWSTEP) { g_MotorCtl.quadrant[i] = 0; } } (*(unsigned int *)&(rism_p_zs12->ccmp[i])) = g_pwmsettbl[g_MotorCtl.quadrant[i]]; } else { if(g_MotorCtl.dststep[i]) { ISM_MoveForward(i,g_MotorCtl.dststep[i]); } } } }   unsigned int getgip(void){ unsigned int res; res = (*(unsigned int *)&(rism_p_zs12->gip)); (*(unsigned int *)&(rism_p_zs12->gstc)) = 0xFF; return res; }   void ManualZeroMotor(void){ while(TRUE == ISM_GetZPDStatus(0)); while(TRUE == ISM_GetZPDStatus(4)); ISM_StartZpd(0); ISM_StartZpd(4);  while(TRUE == ISM_GetZPDStatus(0)); while(TRUE == ISM_GetZPDStatus(4)); }
