/***************************************************************************** ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h ism_src qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Copyright (C) 2016 ShenZhen Yeedon Media co.,LTD. All rights reserved. * ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h ism_src qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h File Name : ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h ism_src qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Description : ledm_private.h ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h ism_src qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Author: Qinhui.Shen ism.c ism.mk ism_cfg.h ism_info.inc ism_private.h ism_public.h ism_src qlapbismv1.h qlapbismv1_a.c qlapbismv1_p.c qlapbismv1_p.h qlapbismv1_s.c r_ism_api.h r_ism_sys.h standardports_p.c standardports_p.h Date: 2016-10-14 ******************************************************************************/  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr check of multiple include */ #ifndef _ISM_PRIVATE_H_ #define _ISM_PRIVATE_H_ #include "qlapbismv1.h"   #define USE_RECORRECTION_METHOD 1 #define ISM_UNIT_0 0 #define CLOSE_MOTOR 0  #define UNUSEZPDMESURE #ifdef UNUSEZPDMESURE #define ZEROTIMEINTERVAL 1000 //ms #define ZEROLITTLETIMEINTERVAL 150 //ms   #define ZEROTIMESTEP1 100 #define ZEROTIMESTEP2 200  #endif  typedef struct ISM_t {  struct rism_gctl_t gctl; struct rism_gstr_t gstr; struct rism_gcfg_t gcfg; volatile unsigned int gcnt; struct rism_gzpdctl_t gzpdctl; struct rism_gip_t gip; struct rism_gstc_t gstc; struct rism_ccmr_t ccmr[ 6 ]; volatile unsigned int czc[ 6 ]; struct rism_ccmp_t ccmp[ 6 ]; volatile unsigned int czd[ 6 ]; volatile unsigned int cioc[ 6 ]; volatile unsigned int irs; struct rism_zpdctl_t zpdctl; volatile unsigned int zrs; volatile unsigned int zdr; volatile unsigned int zip; volatile unsigned int clzp; struct rism_zpdcmp_t zpdcmp[ 6 ]; volatile unsigned int zaf; struct rism_cfg_t set; struct rism_var_t var[ 6 ]; volatile unsigned int emu;  #ifdef ISM_PADDING_REGS volatile U8 padding[ ISM_PADDING_REGS ]; #endif  } ISM_t;  #if USE_RECORRECTION_METHOD const uint32_t ANGLECOLLECTPOINT_4[6] = { 540, 1080, 1620, 2160, 2700, 3240, };  const uint32_t ANGLECOLLECTMOVE_4[6] = { 0xb4000, 0x168000, 0x21c000, 0x2d0000, 0x384000, 0x438000, };   const uint32_t ANGLECOLLECTPOINT_0[8] = { 405, 810, 1215, 1620, 2025, 2430, 2835, 3240, };  const uint32_t ANGLECOLLECTMOVE_0[8] = { 0x87000, 0x10E000, 0x195000, 0x21C000, 0x2A3000, 0x32A000, 0x3B1000, 0x438000, };  const uint32_t ANGLECOLLECTTBL_4[6][6] = { { ///1 0xb4000+0x1000, 0x168000-0x3000, 0x21c000-0x9000, 0x2d0000-0x10000, 0x384000-0x9000, 0x438000-0x8000,  }, { ///2 0xb4000+0x4000, 0x168000+0x3000, 0x21c000+0x2000, 0x2d0000+0x2000, 0x384000, 0x438000-0x4000,  }, { ///3 0xb4000+0x6000, 0x168000+0x3000, 0x21c000-0x1000, 0x2d0000-0x1000, 0x384000-0x2000, 0x438000,  }, { ///4 0xb4000+0x7000, 0x168000+0x6000, 0x21c000+0x9000, 0x2d0000+0x10000, 0x384000+0x9000, 0x438000+0x8000,  }, { ///5 0xb4000+0x8000, 0x168000+0x6000, 0x21c000+0x1000, 0x2d0000, 0x384000, 0x438000,  }, { ///6 0xb4000+0x8000, 0x168000+0x6000, 0x21c000+0x1000, 0x2d0000, 0x384000, 0x438000,  }, }; const uint32_t ANGLECOLLECTTBL_0[6][8] = { { ///1 0x87000, 0x10E000, 0x195000, 0x21C000, 0x2A3000, 0x32A000-0x1000, 0x3B1000-0x2000, 0x438000-0x1000, }, { ///2 0x87000+0x3000, 0x10E000+0x4000, 0x195000+0x4000, 0x21C000+0x4000, 0x2A3000+0x4000, 0x32A000+0x4000, 0x3B1000, 0x438000, }, { ///3 0x87000+0x4000, 0x10E000+0x3000, 0x195000+0x1000, 0x21C000, 0x2A3000-0x5000, 0x32A000-0x5000, 0x3B1000-0x8000, 0x438000-0x8000,  }, { ///4 0x87000+0x7000, 0x10E000+0x6000, 0x195000+0x6000, 0x21C000+0x6000, 0x2A3000+0x5000, 0x32A000+0x3000, 0x3B1000+0x2000, 0x438000+0x1000,  }, { ///5 0x87000, 0x10E000, 0x195000, 0x21C000, 0x2A3000, 0x32A000, 0x3B1000, 0x438000,  }, { ///6 0x87000, 0x10E000, 0x195000, 0x21C000, 0x2A3000, 0x32A000, 0x3B1000, 0x438000,  }, };  #endif  extern void switchIOPort(unsigned char type); extern uint8_t M_ISM_ZPDCMChannel1( uint8_t UnitNumber,uint8_t ChannelEnableMask );   #if USE_RECORRECTION_METHOD  static uint32_t ism_angleCorrection(unsigned char channel,uint32_t angle); static uint32_t ism_getCorrentionAngle(unsigned char ch); #endif      #endif
