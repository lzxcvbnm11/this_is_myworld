/***************************************************************************** com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Copyright (C) 2016 ShenZhen Yeedon Media co.,LTD. All rights reserved. * com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp File Name : com.c com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Description :the private datas of the com module. com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Author: Yingying.Liu com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Date: 2016-12-12 ******************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Files for including */ #include "r_typedefs.h"  #include "com_info.inc" #include "dio_public.h" #include "r_tick_api.h"  #include "r_dev_pin_types.h" #include "clock_public.h"    extern const v_nwm_instance_handle nwm_instances[1]; extern v_nwm_instance nwm_slave_instance; static COMWakeUpSource_ENUM com_NetWake = SOURCE_COM_NONE; static BOOL com_InitSts = FALSE; static U8 com_GCounter = 0; static U8 isNetWorkStoped = FALSE; static BOOL com_SSBPress = FALSE; static SSBData_ST com_ssbKey; static v_nwm_state current_nwm_state; static U8 netWakeUp = FALSE; static U8 L_PDCSysSts = 0; static U8 L_RLObsRng = 0; static U8 L_RRObsRng = 0; static U8 L_RrMidLObsRng = 0; static U8 L_RrMidRObsRng = 0; static U8 L_PDCConfigSts = 0; static U32 com_DisPlayspeed = 0; static U8 com_TrShftLvrPos = 0; static U8 com_TrShftLvrPosV = 0;; static U8 com_MstrSysPwrMd = 0; static U8 com_NetWorkModeSleepFlg = FALSE;  #define PIPC0 *((volatile v_uint16 *)0xffc20008ul) #define PFC0 *((volatile v_uint16 *)0xff618018ul) #define PFCE0 *((volatile v_uint16 *)0xff61801cul) #define PM0 *((volatile v_uint16 *)0xff618010ul) #define PMC0 *((volatile v_uint16 *)0xff618014ul) #define P0 *((volatile v_uint16 *)0xff618000ul)  #define PM1 *((volatile v_uint16 *)0xff610050ul) #define PMC1 *((volatile v_uint16 *)0xff610054ul) #define P1 *((volatile v_uint16 *)0xff610040ul)   /*************************************************** com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Function: COM_Init com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Description: the initialized of the COM module com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Parameters: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Returns: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp $Create & Verlog:$ com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Author:Yingying.Liu Date:2016-12-12 Version:V1.0 ****************************************************/   void COM_Init(void) { U8 res = INVALID;  com_ssbKey.status = INACTIVE; com_ssbKey.valid = VALID; com_NetWorkModeSleepFlg = FALSE;   SYS.PROTCMDD1.UINT32 =0XA5; SYS.CKSC_IPCRSCANS_CTL.UINT32 =0x00000001; SYS.CKSC_IPCRSCANS_CTL.UINT32 =~(0x00000001); SYS.CKSC_IPCRSCANS_CTL.UINT32 =0x00000001; while (( SYS.CKSC_IPCRSCANS_ACT.UINT32 & 0x00000001) != 0x1);   SYS.PROTCMDD1.UINT32 =0XA5; SYS.CKSC_IRLINS_CTL.UINT32 = 0x00000001; SYS.CKSC_IRLINS_CTL.UINT32 = ~(0x00000001); SYS.CKSC_IRLINS_CTL.UINT32 = 0x00000001; while ((SYS.CKSC_IRLINS_ACT.UINT32 & 0x00000002) != 0x2);  PMC1 = 0; PM1 = (v_uint16)0; P1 |= (v_uint16)(1<<0); PFCE0 |= (0x030); PFC0 |= (0x030); PIPC0 &= 0xFE0F; PMC0 |= (0x1B0);  PM0 = ((PM0&(~0x1B0))|0x0A0);  R_TICK_WaitMS(0,50);  res =v_nwm_init(v_config_handle, nwm_instances, 1 ); if(FALSE != res) { while(1) { } } else { }  /*--------------------------------------------------------------- author:liuyingying date:2017-02-24 to reslove the following problem: bug: ipk need 15000ms to sleep,ssb key can not trigger req frame event ---------------------------------------------------------------*/ v_nwm_stop(&nwm_slave_instance); v_output(IPK_CAN_HS_handle);  com_nwm_process(); com_nwm_process(); if(INDEX_STBC_INTP5 == STBC_GetWakeUpType()) { v_nwm_net_com_req(&nwm_slave_instance); } else { }  /*LIN INITIALIZE=====START*/ res = v_ctl_init(IPK_LIN3_handle); /*initialize failed*/ if(FALSE != res) { while(1) { } } else { }  /*v_ctl_con connect the LIN controller to the network*/ v_ctl_con(IPK_LIN3_handle); /*qlz SUPPORT*/ v_l_sch_set(IPK_LIN3_handle,FM_Normal_L3_handle,1);  com_InitSts = TRUE; }  /*************************************************** com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Function: COM_GetInitSts com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Description: get the IOM module initialized status com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Parameters: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Returns: TRUE or FALSE com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp $Create & Verlog:$ com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Author:liuyingying 2017-06-29 ****************************************************/ BOOL COM_GetInitSts(void) { return com_InitSts; }  /*************************************************** com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Function: COM_Process_5ms com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Description: the process of the COM module com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Parameters: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Returns: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp $Create & Verlog:$ com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Author:Yingying.Liu Date:2016-12-12 Version:V1.0 ****************************************************/ void COM_Process_5ms(void) { com_nwm_process();  L_PDCSysSts = v_rd_8(PDCSysSts_L_handle); L_RLObsRng = v_rd_8(RLObsRng_L_handle); L_RRObsRng = v_rd_8(RRObsRng_L_handle); L_RrMidLObsRng = v_rd_8(RrMidLObsRng_L_handle); L_RrMidRObsRng = v_rd_8(RrMidRObsRng_L_handle); L_PDCConfigSts = v_rd_8(PDCCofignSts_L_handle);  com_TrShftLvrPos =v_rd_8(TrShftLvrPos_handle); com_TrShftLvrPosV =v_rd_8(TrShftLvrPosV_handle); com_MstrSysPwrMd = v_rd_8(BCMPwrMdHwdSta_handle);  ST_GetDisplaySpeed(&com_DisPlayspeed);  }  /*************************************************** com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Function: COM_GetNetStatus com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Description: the process of the COM module com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Parameters: status output: the current Network status com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Returns: RET_FAIL :module initial fail RET_INVALID: input parameter error RET_OK: Get Data success com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp $Create & Verlog:$ com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Author:Yingying.Liu Date:2016-12-12 Version:V1.0 ****************************************************/ U8 COM_GetNetStatus(COMNetStatus_ENUM *status) { U8 res = RET_FAIL; if(FALSE == com_InitSts) { res = RET_FAIL; } else if(NULL_PTR == status) { res = RET_INVALID; } else { if(SOURCE_COM_NONE != com_NetWake) { *status = STATUS_COM_NETWAKE; } else { *status = STATUS_COM_NETSLEEP; } res = RET_OK; } return res; } /****************************************************** com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Function: COM_GetNetWorkSleepSts com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Description: Get network sleep status com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Parameters: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Returns: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp $Create & Verlog:$ com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Author:Yingying.Liu Date:2017-10-26 Version:V2.0 *******************************************************/ U8 COM_GetNetWorkSleepSts(void) {  return(com_NetWorkModeSleepFlg); }   /****************************************************** com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Function: com_SSB_WakeUpNetworkCheck com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Description: Get network sleep status com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Parameters: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Returns: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp $Create & Verlog:$ com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Author:Yingying.Liu Date:2017-10-26 Version:V2.0 *******************************************************/ static void com_SSB_WakeUpNetworkCheck(void) { U8 res = RET_FAIL; SSBData_ST ssbKey; static BOOL flag = FALSE;  res = SSB_GetSSBValue(&ssbKey); if ((ACTIVE == ssbKey.status &&INACTIVE == com_ssbKey.status) &&(VALID == ssbKey.valid &&VALID == com_ssbKey.valid) ||((INDEX_STBC_INTP5 == STBC_GetWakeUpType())&&(FALSE == flag))) { v_nwm_resume(&nwm_slave_instance); com_SSBPress = TRUE; flag =TRUE; } else { }  if (TRUE == com_SSBPress) {  v_nwm_net_com_req(&nwm_slave_instance); } else { /*do nothing*/ }  com_ssbKey = ssbKey; }  /*=================================== @liuyingying update @20170207 @add v_test_flag to get 41f frame is received or not ===================================*/  static void com_nwm_process( void) {  static U32 ssbReqCnt = 0; static U32 reqCnt = 0; static U16 DelayCnt = 0;  v_nwm_slave_processing( &nwm_slave_instance ); current_nwm_state = v_nwm_get_state( &nwm_slave_instance );  isNetWorkStoped = com_WakeUpFrameStoped();  com_SSB_WakeUpNetworkCheck();  if(V_NWM_NETWORK_SLEEP == current_nwm_state) { if(FALSE == com_NetWorkModeSleepFlg) {  if(DelayCnt >= (1000)) { com_NetWorkModeSleepFlg = TRUE; DelayCnt = 0; } else { DelayCnt ++;  } } else { DelayCnt = 0; } } else { com_NetWorkModeSleepFlg= FALSE; DelayCnt = 0; } switch(current_nwm_state) {  case V_NWM_STARTUP: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The node is starting up */ break;  case V_NWM_OPERATION: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We are up and communicating on the network. */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr It's possible to run all functions that require */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr communication over the network. */  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr In this example we need the network (receive or transmit */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr signals) as long as sleep_requested is set to 0. */ // if (!sleep_requested)  if(TRUE == com_SSBPress) { ssbReqCnt ++; if((SSB_NET_REQ_MAXCNT - 5) >= ssbReqCnt) {  } else { ssbReqCnt =0; com_SSBPress = FALSE;  if(TRUE == isNetWorkStoped) { v_nwm_stop(&nwm_slave_instance); } else {  } } } else {  }   /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Read the busoff counter and write it to the signal BusOffCounter */ // busoff_cntr = v_nwm_get_busoff_counter( &nwm_slave_instance ); //v_wr_8( busoff_counter_handle, busoff_cntr ); break;  case V_NWM_WAIT_FOR_NETWORK_SLEEP: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We are on the way to Network Sleep. Signals should */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr not be written any more. We shall continue to read signals. */ break;  case V_NWM_NETWORK_SLEEP: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The node is silent and the CAN-controllers are in */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr sleep mode. */ // sleep_requested = 0; break;  case V_NWM_WAKEUP_NETWORK: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We are waking up the network */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if master failed and its fixed frame is not received within time, */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr request wakeup again, so that slave transitions to limphome state */ if((&nwm_slave_instance)->slave->remote_frame_supported) { if((&nwm_slave_instance)->ram_variables->nwm_timer > (v_rd_8(wakeup_network_time_slave_handle) + 2)) { v_nwm_net_com_req(&nwm_slave_instance); } else {  } } else {  }  if(TRUE == com_SSBPress) { v_nwm_net_com_req(&nwm_slave_instance);  reqCnt ++; if(reqCnt >5) { reqCnt = 0; v_fmd_set(IPK_CAN_HS_handle,FM_Normal_HS_handle); } else {  }  } else {  } break;  case V_NWM_WAKEUP_PENDING: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We have been woken up by traffic on the network */ break;  case V_NWM_EXPULSION: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Incorrect signal configuration id received. */ break;  case V_NWM_STOPPED: v_nwm_resume(&nwm_slave_instance); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We are disconnected from the network. */ break;  case V_NWM_BUSOFF: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr One or more busoff errors detected. */ break;  case V_NWM_BUSOFF_WAIT: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The number of busoff errors has reached BUSOFF_MAX. */ break;  case V_NWM_ISOLATED: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Not possible to get here. The transition to state Isolated is */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr made in function v_nwm_init() if there is a initialisation error */ break; case V_NWM_LIMPHOME: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr In this example we need the network (receive or transmit */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr signals) as long as sleep_requested is set to 0. */   /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Read the busoff counter and write it to the signal BusOffCounter */ // busoff_cntr = v_nwm_get_busoff_counter( &nwm_slave_instance ); // v_wr_8( busoff_counter_handle, busoff_cntr ); break; default: break; }   }   /*************************************************** com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Function: COM_CAN2Lin com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Description: the signals of Lin to can com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Parameters: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Returns: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp $Create & Verlog:$  TrShftLvrPos TrShftLvrPosV BCMPwrMdHwdSta - ignore Displayed Speed  com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Author:Yingying.Liu Date:2016-12-12 Version:V1.0 ****************************************************/ void COM_CAN2Lin(void) {   v_wr_8(TrShftLvrPos_l5_handle,com_TrShftLvrPos); v_wr_8(TrShftLvrPosV_l5_handle,com_TrShftLvrPosV); v_wr_8(MstrSysPwrMd_handle,com_MstrSysPwrMd); v_wr_8(LowAcurcVehSpdAvg_handle,(U8)(com_DisPlayspeed/2));  }       /*************************************************** com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Function: COM_Lin2CAN com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Description: the signals of Lin to can com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Parameters: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Returns: none com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp $Create & Verlog:$  PDCSysSts_L  RLObsRng_L  RRObsRng_L  RrMidLObsRng_L  RrMidRObsRng_L  FLObsRng_L - ignore  FRObsRng_L - ignore  FrtMidLObsRng_L - ignore  FrtMidRObsRng_L - ignore  FrtPDCAudWrnng_L - ignore  PDCCofignSts_L    com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Author:Yingying.Liu Date:2016-12-12 Version:V1.0 ****************************************************/   void COM_Lin2CAN(void) { v_wr_8(PDCSysSts_handle,L_PDCSysSts); v_wr_8(RLObsRng_handle,L_RLObsRng); v_wr_8(RRObsRng_handle,L_RRObsRng); v_wr_8(RrMidLObsRng_handle,L_RrMidLObsRng); v_wr_8(RrMidRObsRng_handle,L_RrMidRObsRng); v_wr_8(PDCCofignSts_handle,L_PDCConfigSts);  }     /*---------------------------------------------------- author: liuyingying  date:2017-0214 version:v1.0 create  log1:2017-02-14 v1.1 add three signals DrvrShftCtrlTrgtGear TrShftPtrnASts TrShftLvrPosV ------------------------------------------------------*/ void COM_GetSignalValue_8(U16 Index, PU8 pRes) { U8 Value8; S8 sValue;  if(NULL != pRes) { switch(Index) { case INDEX_COM_RS_BCMPwrMdHwdSt:/*BCMPwrMdHwdSta*/ *pRes = v_rd_8(BCMPwrMdHwdSta_handle); break; case INDEX_COM_RS_BCMPWRMDHWDSTAV: /*BCMPwrMdHwdStaVP*/ *pRes = v_rd_8(BCMPwrMdHwdStaV_handle); break; case INDEX_COM_RS_PWRMDMSTRACCRYA : /*PwrMdMstrAccryA*/ *pRes = v_rd_8(PwrMdMstrAccryA_handle); break; case INDEX_COM_RS_PWRMDMSTRRUNCRKA: /*PwrMdMstrRunCrkA*/ *pRes = v_rd_8(PwrMdMstrRunCrkA_handle); break;  case INDEX_COM_RS_BCMSSBA: /*BCMSSBA*/ *pRes = v_rd_8(BCMSSBA_handle); break; case INDEX_COM_RS_BCMSSBAV: /*BCMSSBAV*/ *pRes = v_rd_8(BCMSSBAV_handle); break; case INDEX_COM_RS_BCMSSBFLTSTS: /*BCMSSBFltSts*/ *pRes = v_rd_8(BCMSSBFltSts_handle); break;  case INDEX_COM_RS_WHLGNDVELLDRVNV:/*WhlGndVelLDrvnV*/ *pRes = v_rd_8(WhlGndVelLDrvnV_handle); break; case INDEX_COM_RS_WHLGNDVELLNONDRVNV:/*WhlGndVelLNonDrvnV*/ *pRes = v_rd_8(WhlGndVelLNonDrvnV_handle); break; case INDEX_COM_RS_WHLGNDVELRDRVNV:/*WhlGndVelRDrvnV*/ *pRes = v_rd_8(WhlGndVelRDrvnV_handle); break; case INDEX_COM_RS_WHLGNDVELRNONDRVNV:/*WhlGndVelRNonDrvnV*/ *pRes = v_rd_8(WhlGndVelRNonDrvnV_handle); break; case INDEX_COM_RS_AVGFUELCSUMP:/*AvgFuelCsump*/ *pRes = v_rd_8(AvgFuelCsump_handle); break; case INDEX_COM_RS_AVGFUELCSUMPV:/*AvgFuelCsumpV*/ *pRes = v_rd_8(AvgFuelCsumpV_handle); break; case INDEX_COM_RS_CALENDARDAY:/*CalendarDay*/ *pRes = v_rd_8(CalendarDay_handle); break; case INDEX_COM_RS_CALENDARMONTH:/*CalendarMonth_handle*/ *pRes = v_rd_8(CalendarMonth_handle); break; case INDEX_COM_RS_CALENDARYEAR:/*CalendarYear*/ *pRes = v_rd_8(CalendarYear_handle); break;  case INDEX_COM_RS_PRFTRTAPUPDWNSECYSWSTA:/*PfTrTapUpDwnSecySwSta*/ *pRes = v_rd_8(PfTrTapUpDwnSecySwSta_handle); break; case INDEX_COM_RS_RROBSDIST:/*RrObsDist*/ *pRes = v_rd_8(RrObsDist_handle); break;  case INDEX_COM_RS_CHMCMDSNDCNDCPRD:/*ChmCmdSndCndcPrd*/ *pRes = v_rd_8(ChmCmdSndCndcPrd_handle); break; case INDEX_COM_RS_CHMCMDSNDDUTYCYC:/*ChmCmdSndDutyCyc*/ *pRes = v_rd_8(ChmCmdSndDutyCyc_handle); break; case INDEX_COM_RS_CHMCMDSNDTONE:/*ChmCmdSndTone*/ *pRes = v_rd_8(ChmCmdSndTone_handle); break; case INDEX_COM_RS_DSPMEASSYS:/*DspMeasSys*/ *pRes = v_rd_8(DspMeasSys_handle); break; case INDEX_COM_RS_FLOBSRNG:/*FLObsRng*/ *pRes = v_rd_8(FLObsRng_handle); break; case INDEX_COM_RS_FROBSRNG:/*FRObsRng*/ *pRes = v_rd_8(FRObsRng_handle); break; case INDEX_COM_RS_FRTMIDLOBSRNG:/*FrtMidLObsRng*/ *pRes = v_rd_8(FrtMidLObsRng_handle); break; case INDEX_COM_RS_FRTMIDROBSRNG:/*FrtMidRObsRng*/ *pRes = v_rd_8(FrtMidRObsRng_handle); break; case INDEX_COM_RS_FRTOBSDIST:/*FrtObsDist*/ *pRes = v_rd_8(FrtObsDist_handle); break; case INDEX_COM_RS_IPCSSBFLTSTS:/*IPCSSBFltSts*/ *pRes = v_rd_8(IPCSSBFltSts_handle); break; case INDEX_COM_RS_LANGGSETNG:/*LanggSetng*/ *pRes = v_rd_8(LanggSetng_handle); break;  case INDEX_COM_RS_TRSHFTLVRPOS:/*TrShftLvrPos*/ *pRes = v_rd_8(TrShftLvrPos_handle); break; case INDEX_COM_RS_DRVRSHFTCTRLTRGTGEAR:/*DrvrShftCtrlTrgtGear*/ *pRes = v_rd_8(DrvrShftCtrlTrgtGear_handle); break; case INDEX_COM_RS_ECMPRESSCLBRKRMNDR:/*ECMPressClBrkRmndr*/ *pRes = v_rd_8(ECMPressClBrkRmndr_handle); break;  case INDEX_COM_RS_ECODRVNGDSPSTSGEARSIS:/*EcoDrvngDspStsGearSIS*/ *pRes = v_rd_8(EcoDrvngDspStsGearSIS_handle); break; case INDEX_COM_RS_ECODRVNGDSPSTSRCMNDFG:/*EcoDrvngDspStsRcmndFG*/ *pRes = v_rd_8(EcoDrvngDspStsRcmndFG_handle); break; case INDEX_COM_RS_EMGCCALLFLRSTS:/*EmgcCallFlrSts*/ *pRes = v_rd_8(EmgcCallFlrSts_handle); break; case INDEX_COM_RS_ENASSSTA:/*EnASSSta*/ *pRes = v_rd_8(EnASSSta_handle); break;  case INDEX_COM_RS_TRSHFTPTRNASTS:/*TrShftLvrPosV*/ *pRes = v_rd_8(TrShftPtrnASts_handle); break; case INDEX_COM_RS_TRTAPUPTAPDWNMDSTS:/*TrShftLvrPosV*/ *pRes = v_rd_8(TrTapUpTapDwnMdSts_handle); break; case INDEX_COM_RS_VEHLCKNGSTA:/*VehLckngSta*/ *pRes = v_rd_8(VehLckngSta_handle); break;  case INDEX_COM_RS_TRSHFTLVRPOSV:/*TrShftLvrPosV*/ *pRes = v_rd_8(TrShftLvrPosV_handle); break; case INDEX_COM_RS_DRVRDOOROPENSTS:/*DrvrDoorOpenSts*/ *pRes = v_rd_8(DrvrDoorOpenSts_handle); break; case INDEX_COM_RS_ENSPDSTS:/*EnSpdSts*/ *pRes = v_rd_8(EnSpdSts_handle); break; case INDEX_COM_RS_EPBSYSAUDWRNNGREQ:/*EPBSysAudWrnngReq*/ *pRes = v_rd_8(EPBSysAudWrnngReq_handle); break; case INDEX_COM_RS_EPBSYSDSPMSGREQ:/*EPBSysDspMsgReq*/ *pRes = v_rd_8(EPBSysDspMsgReq_handle); break; case INDEX_COM_RS_EPBSYSSTSINDREQ:/*EPBSysStsIndReq*/ *pRes = v_rd_8(EPBSysStsIndReq_handle); break; case INDEX_COM_RS_EPBSYSWRNNGINDREQ:/*EPBSysWrnngIndReq*/ *pRes = v_rd_8(EPBSysWrnngIndReq_handle); break;  case INDEX_COM_RS_VEHSPDAVGDRVNV:/*VehSpdAvgDrvnV*/ *pRes = v_rd_8(VehSpdAvgDrvnV_handle); break; case INDEX_COM_RS_ENCLNTTEMV:/*EnClntTemV*/ *pRes = v_rd_8(EnClntTemV_handle); break; case INDEX_COM_RS_ENEMSNRLTDMALFINDREQ:/*EnEmsnRltdMalfIndReq*/ *pRes = v_rd_8(EnEmsnRltdMalfIndReq_handle); break; case INDEX_COM_RS_ENGPFLAMPONSTS:/*EnGPFLampOnSts*/ *pRes = v_rd_8(EnGPFLampOnSts_handle); break;  case INDEX_COM_RS_GENRSTA:/*GenrSta*/ *pRes = v_rd_8(GenrSta_handle); break; case INDEX_COM_RS_HDCSYSSTS:/*HDCSysSts*/ *pRes = v_rd_8(HDCSysSts_handle); break;  case INDEX_COM_RS_VEHLDSHEDLVL:/*VehLdShedLvl*/ *pRes = v_rd_8(VehLdShedLvl_handle); break; case INDEX_COM_RS_VEHODOV:/*VehOdoV*/ *pRes = v_rd_8(VehOdoV_handle); break;  case INDEX_COM_RS_EPSFLRSTS:/*EPSFlrSts*/ *pRes = v_rd_8(EPSFlrSts_handle); break; case INDEX_COM_RS_STRGWHLANGSNSRCALSTS:/*StrgWhlAngSnsrCalSts*/ *pRes = v_rd_8(StrgWhlAngSnsrCalSts_handle); break; case INDEX_COM_RS_SYSOPNLMD:/*SysOpnlMd*/ *pRes = v_rd_8(SysOpnlMd_handle); break; case INDEX_COM_RS_SYSPWRMD:/*SysPwrMd*/ *pRes = v_rd_8(SysPwrMd_handle); break; case INDEX_COM_RS_SYSPWRMDV:/*SysPwrMdV_handle*/ *pRes = v_rd_8(SysPwrMdV_handle); break; case INDEX_COM_RS_SYSVOL:/*SysVol*/ *pRes = v_rd_8(SysVol_handle); break; case INDEX_COM_RS_SYSVOLMD:/*SysVolMd*/ *pRes = v_rd_8(SysVolMd_handle); break; case INDEX_COM_RS_SYSVOLMDV:/*SysVolMdV*/ *pRes = v_rd_8(SysVolMdV_handle); break; case INDEX_COM_RS_SYSVOLV:/*SysVolV*/ *pRes = v_rd_8(SysVolV_handle); break;  case INDEX_COM_RS_ESCLFLRINDCMD:/*ESCLFlrIndCmd*/ *pRes = v_rd_8(ESCLFlrIndCmd_handle); break; case INDEX_COM_RS_FLTIREPRSV:/*FLTirePrsV*/ *pRes = v_rd_8(FLTirePrsV_handle); break; case INDEX_COM_RS_FLTIRESTS:/*FLTireSts*/ *pRes = v_rd_8(FLTireSts_handle); break;  case INDEX_COM_RS_FLTIRETEMV:/*FLTireTemV*/ *pRes = v_rd_8(FLTireTemV_handle); break;   case INDEX_COM_RS_FRTIREPRSV:/*FRTirePrsV*/ *pRes = v_rd_8(FRTirePrsV_handle); break; case INDEX_COM_RS_FRTIRESTS:/*FRTireSts*/ *pRes = v_rd_8(FRTireSts_handle); break; case INDEX_COM_RS_FRTIRETEMV:/*FRTireTemV*/ *pRes = v_rd_8(FRTireTemV_handle); break;  case INDEX_COM_RS_RLTIREPRSV:/*RLTirePrsV*/ *pRes = v_rd_8(RLTirePrsV_handle); break; case INDEX_COM_RS_RLTIRESTS:/*RLTireSts*/ *pRes = v_rd_8(RLTireSts_handle); break; case INDEX_COM_RS_RLTIRETEMV:/*RLTireTemV*/ *pRes = v_rd_8(RLTireTemV_handle); break; case INDEX_COM_RS_RRDOOROPENSTS:/*RRDoorOpenSts*/ *pRes = v_rd_8(RRDoorOpenSts_handle); break;  case INDEX_COM_RS_RRTIREPRSV:/*RRTirePrsV*/ *pRes = v_rd_8(RRTirePrsV_handle); break; case INDEX_COM_RS_RRTIRESTS:/*RRTireSts*/ *pRes = v_rd_8(RRTireSts_handle); break; case INDEX_COM_RS_RRTIRETEMV:/*RRTireTemV*/ *pRes = v_rd_8(RRTireTemV_handle); break; case INDEX_COM_RS_SCURTALRMSTS:/*ScurtAlrmSts*/ *pRes = v_rd_8(ScurtAlrmSts_handle); break;  case INDEX_COM_RS_VSESTS:/*VSESts*/ *pRes = v_rd_8(VSESts_handle); break; case INDEX_COM_RS_TCSOPNGSTS:/*TCSOpngSts*/ *pRes = v_rd_8(TCSOpngSts_handle); break; case INDEX_COM_RS_VSEMD:/*VSEMd*/ *pRes = v_rd_8(VSEMd_handle); break; case INDEX_COM_RS_TCSOPNGMD:/*TCSOpngMd*/ *pRes = v_rd_8(TCSOpngMd_handle); break; case INDEX_COM_RS_BRKFLUDLVLLOWV:/*BrkFludLvlLowV*/ *pRes = v_rd_8(BrkFludLvlLowV_handle); break;  case INDEX_COM_RS_FASNDRVRSBLTINDCMD:/*FasnDrvrSbltIndCmd*/ *pRes = v_rd_8(FasnDrvrSbltIndCmd_handle); break; case INDEX_COM_RS_FASNFRTPSNGSBLTINDCMD:/*FasnFrtPsngSbltIndCmd*/ *pRes = v_rd_8(FasnFrtPsngSbltIndCmd_handle); break; case INDEX_COM_RS_FASNSECROWLSBINDCMD:/*FasnSecRowLSbltIndCmd*/ *pRes = v_rd_8(FasnSecRowLSbltIndCmd_handle); break; case INDEX_COM_RS_FASNSECROWMIDSBLTINDC:/*FasnSecRowMidSbltIndC*/ *pRes = v_rd_8(FasnSecRowMidSbltIndC_handle); break; case INDEX_COM_RS_FASNSECROWRSBLTINDCMD:/*FasnSecRowRSbltIndCmd*/ *pRes = v_rd_8(FasnSecRowRSbltIndCmd_handle); break; case INDEX_COM_RS_FICMDISTUNITADJ:/*FICMDistUntAdj*/ *pRes = v_rd_8(FICMDistUntAdj_handle); break;  case INDEX_COM_RS_FICMFUELCSUMPUNTADJ:/*FICMFuelCsumpUntAdj*/ *pRes = v_rd_8(FICMFuelCsumpUntAdj_handle); break; case INDEX_COM_RS_FICMOVERSPDFNCRNTSTS:/*FICMOverSpdFnCrntSts*/ *pRes = v_rd_8(FICMOverSpdFnCrntSts_handle); break;  case INDEX_COM_RS_FICMTEMUNTADJ:/*FICMTemUntAdj*/ *pRes = v_rd_8(FICMTemUntAdj_handle); break;  case INDEX_COM_RS_FICMTYREPRESSUREUNTADJ:/*FICMTyrePressureUntAdj*/ *pRes = v_rd_8(FICMTyrePressureUntAdj_handle); break;  case INDEX_COM_RS_FICMVEHMNTNCESTS:/*FICMVehMntnceSts*/ *pRes = v_rd_8(FICMVehMntnceSts_handle); break;   case INDEX_COM_RS_AIRBAGSYSFLTINDCMD: /*AirbagSysFltIndCmd*/ *pRes = v_rd_8(AirbagSysFltIndCmd_handle); break; case INDEX_COM_RS_AMBTLGHTLVL: /*AmbtLghtLvl*/ *pRes = v_rd_8(AmbtLghtLvl_handle); break; case INDEX_COM_RS_AUTOHOLDMSG: /*AutoHoldMsg*/ *pRes = v_rd_8(AutoHoldMsg_handle); break; case INDEX_COM_RS_AUTOHOLDSYSSTS: /*AutoHoldSysSts*/ *pRes = v_rd_8(AutoHoldSysSts_handle); break; case INDEX_COM_RS_BATAGNGSTA: /*BatAgngSta*/ *pRes = v_rd_8(BatAgngSta_handle); break; case INDEX_COM_RS_BATSOC: /*BatSOC*/ *pRes = v_rd_8(BatSOC_handle); break;   case INDEX_COM_RS_VEHSIDELGHTSTS:/*VehSideLghtSts*/ *pRes = v_rd_8(VehSideLghtSts_handle); break; case INDEX_COM_RS_DISTRCAVGDRVNV:/*DistRCAvgDrvnV*/ *pRes = v_rd_8(DistRCAvgDrvnV_handle); break; case INDEX_COM_RS_FRTPSNGDOOROPENSTS:/*FrtPsngDoorOpenSts*/ *pRes = v_rd_8(FrtPsngDoorOpenSts_handle); break; case INDEX_COM_RS_LDSPCOPENSTS:/*LdspcOpenSts*/ *pRes = v_rd_8(LdspcOpenSts_handle); break; case INDEX_COM_RS_LGHTSWPOSSTS:/*LghtSwPosSts*/ *pRes = v_rd_8(LghtSwPosSts_handle); break; case INDEX_COM_RS_BNTOPENSTS:/*BntOpenSts*/ *pRes = v_rd_8(BntOpenSts_handle); break; case INDEX_COM_RS_PDCSYSSTS_L:/*PDCSysSts_L*/ *pRes = v_rd_8(PDCSysSts_L_handle); break; case INDEX_COM_RS_RRPDCAUDWRNNG_L:/*RrPDCAudWrnng_L*/ *pRes = v_rd_8(RrPDCAudWrnng_L_handle); break; case INDEX_COM_RS_RLOBSRNG_L:/*RLObsRng_L*/ *pRes = v_rd_8(RLObsRng_L_handle); break; case INDEX_COM_RS_RROBSRNG_L:/*RRObsRng_L*/ *pRes = v_rd_8(RRObsRng_L_handle); break; case INDEX_COM_RS_RRMIDLOBSRNG_L:/*RrMidLObsRng_L*/ *pRes = v_rd_8(RrMidLObsRng_L_handle); break; case INDEX_COM_RS_RRMIDROBSRNG_L:/*RrMidRObsRng_L*/ *pRes = v_rd_8(RrMidRObsRng_L_handle); break; case INDEX_COM_RS_RROBSDIST_L:/*RrObsDist_L*/ *pRes = v_rd_8(RrObsDist_L_handle); break; case INDEX_COM_RS_PDCCOFIGNSTS_L:/*PDCCofignSts_L*/ *pRes = v_rd_8(PDCCofignSts_L_handle); break; case INDEX_COM_RS_TIMEDSPFMTADJ:/*TimeDspFmtAdj*/ *pRes = v_rd_8(TimeDspFmtAdj_handle); break; case INDEX_COM_RS_HOUROFDAYADJ:/*HourOfDayAdj*/ *pRes = v_rd_8(HourOfDayAdj_handle); break;  case INDEX_COM_RS_MINUTEOFHOURADJ:/*MinuteOfHourAdj*/ *pRes = v_rd_8(MinuteOfHourAdj_handle); break;  case INDEX_COM_RS_MUSSRCMD:/*MusSrcMd*/ *pRes = v_rd_8(MusSrcMd_handle); break; case INDEX_COM_RS_NAVDIRCN:/*NavDircn*/ *pRes = v_rd_8(NavDircn_handle); break; case INDEX_COM_RS_NAVDISTUNIT:/*NavDistUnit*/ *pRes = v_rd_8(NavDistUnit_handle); break;  case INDEX_COM_RS_SECSOFMINUTEADJ:/*SecsOfMinuteAdj*/ *pRes = v_rd_8(SecsOfMinuteAdj_handle); break;  case INDEX_COM_RS_SPDASTSYSTSECM:/*SpdAstSysStsECM*/ *pRes = v_rd_8(SpdAstSysStsECM_handle); break; case INDEX_COM_RS_SSBENOFFRMNDR:/*SSBEnOffRmndr*/ *pRes = v_rd_8(SSBEnOffRmndr_handle); break;  case INDEX_COM_RS_CALENDARYEARADJ:/*CalendarYearAdj*/ *pRes = v_rd_8(CalendarYearAdj_handle); break; case INDEX_COM_RS_CALENDARMONTHADJ:/*CalendarMonthAdj*/ *pRes = v_rd_8(CalendarMonthAdj_handle); break; case INDEX_COM_RS_CALENDARDAYADJ:/*CalendarDayAdj*/ *pRes = v_rd_8(CalendarDayAdj_handle); break; default: break; } } else { } }   void COM_GetSignalValue_BOOL(U16 Index, PU8 pRes) {  if(NULL != pRes) { switch(Index) { case INDEX_COM_RS_PWRMDMSTRIGNA: /*PwrMdMstrIgnA*/ *pRes = v_rd_bool(PwrMdMstrIgnA_handle); break; case INDEX_COM_RS_RBRKLGHTF: /*RBrkLghtF*/ *pRes = v_rd_bool(RBrkLghtF_handle); break; case INDEX_COM_RS_RDIPDBEAMLGHTF: /*RDipdBeamLghtF*/ *pRes = v_rd_bool(RDipdBeamLghtF_handle); break; case INDEX_COM_RS_RDIRCNINDLGHTF: /*RDircnIndLghtF*/ *pRes = v_rd_bool(RDircnIndLghtF_handle); break;  case INDEX_COM_RS_BCMEMGCSP:/*BCMEmgcSp*/ *pRes = v_rd_bool(BCMEmgcSp_handle); break; case INDEX_COM_RS_BCMGEARSHFTPARKNTRLESR:/*BCMGearShftParkNtrlESR*/ *pRes = v_rd_bool(BCMGearShftParkNtrlESR_handle); break;  case INDEX_COM_RS_ENRUNA:/*EnRunA*/ *pRes = v_rd_bool(EnRunA_handle); break; case INDEX_COM_RS_FASNSBLTAUDRMNDR:/*FasnSbltAudRmndr*/ *pRes = v_rd_bool(FasnSbltAudRmndr_handle); break; case INDEX_COM_RS_FICMDISTUNITADJTREQA:/*FICMDistUnitAdjtReqA*/ *pRes = v_rd_bool(FICMDistUnitAdjtReqA_handle); break; case INDEX_COM_RS_FICMFUELCSUMPUNTADJRA:/*FICMFuelCsumpUntAdjARA*/ *pRes = v_rd_bool(FICMFuelCsumpUntAdjARA_handle); break; case INDEX_COM_RS_FICMOVERSPDTHRSHLDADJTRA:/*FICMOvrSpdThrshldAdjtRA*/ *pRes = v_rd_bool(FICMOvrSpdThrshldAdjtRA_handle); break; case INDEX_COM_RS_FICMTEMUNTADJTREQA:/*FICMTemUntAdjtReqA*/ *pRes = v_rd_bool(FICMTemUntAdjtReqA_handle); break; case INDEX_COM_RS_FICMTYREPRESSUREUNTADJTREQA:/*FICMTyrePressureUntAdjtReqA*/ *pRes = v_rd_bool(FICMTyrePressureUntAdjtReqA_handle); break;  case INDEX_COM_RS_CCA:/*CCA*/ *pRes = v_rd_bool(CCA_handle); break; case INDEX_COM_RS_CCENBD:/*CCEnbd*/ *pRes = v_rd_bool(CCEnbd_handle); break; case INDEX_COM_RS_CCFLTPRST:/*CCFltPrst*/ *pRes = v_rd_bool(CCFltPrst_handle); break; case INDEX_COM_RS_CHMA:/*ChmA*/ *pRes = v_rd_bool(ChmA_handle); break; case INDEX_COM_RS_DAYTIMERUNNINGLGHTF:/*DayTimeRunningLghtF*/ *pRes = v_rd_bool(DayTimeRunningLghtF_handle); break; case INDEX_COM_RS_DIPDBEAMLGHTON:/*DipdBeamLghtOn*/ *pRes = v_rd_bool(DipdBeamLghtOn_handle); break; case INDEX_COM_RS_DRVRPWLINITNRMNDR:/*DrvrPWLInitnRmndr*/ *pRes = v_rd_bool(DrvrPWLInitnRmndr_handle); break; case INDEX_COM_RS_DRVRWNDOPENRMNDR:/*DrvrWndOpenRmndr*/ *pRes = v_rd_bool(DrvrWndOpenRmndr_handle); break; case INDEX_COM_RS_ECMCLSDOORTOAUTOSTR:/*ECMClsDoorToAutoStR*/ *pRes = v_rd_bool(ECMClsDoorToAutoStR_handle); break; case INDEX_COM_RS_ECMFASNSBLTTOAUTOSTR:/*ECMFasnSbltToAutoStR*/ *pRes = v_rd_bool(ECMFasnSbltToAutoStR_handle); break; case INDEX_COM_RS_ECMSHFTNTRLTOAUTOSTR:/*ECMShftNtrlToAutoStR*/ *pRes = v_rd_bool(ECMShftNtrlToAutoStR_handle); break;  case INDEX_COM_RS_ENEMSNRLTDMALFA:/*EnEmsnRltdMalfA*/ *pRes = v_rd_bool(EnEmsnRltdMalfA_handle); break; case INDEX_COM_RS_ENNONEMSNRLTDMALFA:/*EnNonEmsnRltdMalfA*/ *pRes = v_rd_bool(EnNonEmsnRltdMalfA_handle); break; case INDEX_COM_RS_ASSSTSLAMPON:/*ASSStsLampOn*/ *pRes = v_rd_bool(ASSStsLampOn_handle); break; case INDEX_COM_RS_ENOILPRSLOWIO:/*EnOilPrsLowIO*/ *pRes = v_rd_bool(EnOilPrsLowIO_handle); break; case INDEX_COM_RS_ASSINHIO:/*ASSInhIO*/ *pRes = v_rd_bool(ASSInhIO_handle); break; case INDEX_COM_RS_ASSWRNNGLAMPON:/*ASSWrnngLampOn*/ *pRes = v_rd_bool(ASSWrnngLampOn_handle); break; case INDEX_COM_RS_STRGWHLANGSNSRFLT:/*StrgWhlAngSnsrFlt*/ *pRes = v_rd_bool(StrgWhlAngSnsrFlt_handle); break; case INDEX_COM_RS_TPMSTIREPRSLOWIO:/*TPMSTirePrsLowIO*/ *pRes = v_rd_bool(TPMSTirePrsLowIO_handle); break;  case INDEX_COM_RS_TPMSF:/*TPMSF*/ *pRes = v_rd_bool(TPMSF_handle); break;  case INDEX_COM_RS_TPMSWNTRMDA:/*TPMSWntrMdA*/ *pRes = v_rd_bool(TPMSWntrMdA_handle); break;  case INDEX_COM_RS_TPMSIDFICNLRNCM:/*TPMSIdficnLrnCm*/ *pRes = v_rd_bool(TPMSIdficnLrnCm_handle); break;  case INDEX_COM_RS_TRNONEMSNRLTDMALFA: *pRes = v_rd_bool(TrNonEmsnRltdMalfA_handle); break;   case INDEX_COM_RS_TPMSAUTOLOCTNCM: *pRes = v_rd_bool(TPMSAutoLoctnCm_handle); break; case INDEX_COM_RS_ABSIO:/*ABSIO*/ *pRes = v_rd_bool(ABSIO_handle); break; case INDEX_COM_RS_BRKSYSREDBRKTLLTREQ:/*BrkSysRedBrkTlltReq*/ *pRes = v_rd_bool(BrkSysRedBrkTlltReq_handle); break; case INDEX_COM_RS_BRKFLUDLVLLOW:/*BrkFludLvlLow*/ *pRes = v_rd_bool(BrkFludLvlLow_handle); break; case INDEX_COM_RS_MAINBEAMLGHTON:/*MainBeamLghtOn*/ *pRes = v_rd_bool(MainBeamLghtOn_handle); break; case INDEX_COM_RS_PEPSANTFLT:/*PEPSAntFlt*/ *pRes = v_rd_bool(PEPSAntFlt_handle); break; case INDEX_COM_RS_PWRMDMSTRACCRYWKUPA:/*PwrMdMstrAccryWkupA*/ *pRes = v_rd_bool(PwrMdMstrAccryWkupA_handle); break;  case INDEX_COM_RS_FRTFOGLGHTON:/*FrtFogLghtOn*/ *pRes = v_rd_bool(FrtFogLghtOn_handle); break; case INDEX_COM_RS_FRTSIDELGHTF:/*FrtSideLghtF*/ *pRes = v_rd_bool(FrtSideLghtF_handle); break; case INDEX_COM_RS_KEEP_NETWORK_AC:/*keep_network_AC*/ *pRes = v_rd_bool(keep_network_AC_handle); break;  case INDEX_COM_RS_LBRKLGHTF:/*LBrkLghtF*/ *pRes = v_rd_bool(LBrkLghtF_handle); break; case INDEX_COM_RS_LDIPDBEAMLGHTF:/*LDipdBeamLghtF*/ *pRes = v_rd_bool(LDipdBeamLghtF_handle); break; case INDEX_COM_RS_LDIRCNINDLGHTF:/*LDircnIndLghtF*/ *pRes = v_rd_bool(LDircnIndLghtF_handle); break;  case INDEX_COM_RS_RRFOGLGHTON:/*RrFogLghtOn*/ *pRes = v_rd_bool(RrFogLghtOn_handle); break; case INDEX_COM_RS_RRSIDELGHTF:/*RrSideLghtF*/ *pRes = v_rd_bool(RrSideLghtF_handle); break;  case INDEX_COM_RS_RDIRCNIO:/*RDircnIO*/ *pRes = v_rd_bool(RDircnIO_handle); break; case INDEX_COM_RS_REVSLGHTF:/*RevsLghtF*/ *pRes = v_rd_bool(RevsLghtF_handle); break; case INDEX_COM_RS_RRFOGLGHTF:/*RrFogLghtF*/ *pRes = v_rd_bool(RrFogLghtF_handle); break;  case INDEX_COM_RS_LDIRCNIO:/*LDircnIO*/ *pRes = v_rd_bool(LDircnIO_handle); break; case INDEX_COM_RS_SCURTKEYINVD:/*ScurtKeyInvd*/ *pRes = v_rd_bool(ScurtKeyInvd_handle); break; case INDEX_COM_RS_SHIFTERLCKRLSEBRKREQA:/*ShifterLckRlseBrkReqA*/ *pRes = v_rd_bool(ShifterLckRlseBrkReqA_handle); break; case INDEX_COM_RS_SRFINITNRMNDR:/*SrfInitnRmndr*/ *pRes = v_rd_bool(SrfInitnRmndr_handle); break; case INDEX_COM_RS_SRFOPENRMNDR:/*SrfOpenRmndr*/ *pRes = v_rd_bool(SrfOpenRmndr_handle); break;  case INDEX_COM_RS_SCURTKEYBATLOW:/*scurtKeyBatLow*/ *pRes = v_rd_bool(ScurtKeyBatLow_handle); break; case INDEX_COM_RS_BCMNOSMTKEYLNVEHRMNDR:/*BCMNoSmtKeyInVehRmndr*/ *pRes = v_rd_bool(BCMNoSmtKeyInVehRmndr_handle); break; case INDEX_COM_RS_BCMNoSmtKeyPRESSBRKTRR:/*BCMNoSmtKeyPressBrkTRR*/ *pRes = v_rd_bool(BCMNoSmtKeyPressBrkTRR_handle); break; case INDEX_COM_RS_BCMNoSmtKeyPRESSCLTORR:/*BCMNoSmtKeyPressClToRR*/ *pRes = v_rd_bool(BCMNoSmtKeyPressClToRR_handle); break; case INDEX_COM_RS_BCMPRESSBRKRMNDR:/*BCMPressBrkRmndr*/ *pRes = v_rd_bool(BCMPressBrkRmndr_handle); break; case INDEX_COM_RS_BCMPRESSCLRMNDR:/*BCMPressClRmndr*/ *pRes = v_rd_bool(BCMPressClRmndr_handle); break; case INDEX_COM_RS_BCMPUTSMTKEYTOBKUPPOSR:/*BCMPutSmtKeyToBkupPosR*/ *pRes = v_rd_bool(BCMPutSmtKeyToBkupPosR_handle); break; case INDEX_COM_RS_BCMRUNCRKF:/*BCMRunCrkF*/ *pRes = v_rd_bool(BCMRunCrkF_handle); break; case INDEX_COM_RS_BCMSHFTPARKRMNDR:/*BCMShftParkRmndr*/ *pRes = v_rd_bool(BCMShftParkRmndr_handle); break; case INDEX_COM_RS_BCMSYNCSMTKEYRMNDR:/*BCMSyncSmtKeyRmndr*/ *pRes = v_rd_bool(BCMSyncSmtKeyRmndr_handle); break; case INDEX_COM_RS_BCMTAKESMTKEYOUTOFSR:/*BCMTakeSmtKeyOutOfSR_handle*/ *pRes = v_rd_bool(BCMTakeSmtKeyOutOfSR_handle); break;  case INDEX_COM_RS_ECODRVNGAIO:/*EcoDrvngAIO*/ *pRes = v_rd_bool(EcoDrvngAIO_handle); break; case INDEX_COM_RS_ECODRVNGSPDRUTA:/*ECODrvngSpdRutA*/ *pRes = v_rd_bool(ECODrvngSpdRutA_handle); break; case INDEX_COM_RS_EN12VOLTSTRMOTCMDDON:/*En12VoltStrMotCmddOn*/ *pRes = v_rd_bool(En12VoltStrMotCmddOn_handle); break;  case INDEX_COM_RS_PDCRLSNSRFLT_L:/*PDCRLSnsrFlt_L*/ *pRes = v_rd_bool(PDCRLSnsrFlt_L_handle); break; case INDEX_COM_RS_PDCRRMIDLSNSRFLT_L:/*PDCRrMidLSnsrFlt_L*/ *pRes = v_rd_bool(PDCRrMidLSnsrFlt_L_handle); break; case INDEX_COM_RS_PDCRRMIDRSNSRFLT_L:/*PDCRrMidRSnsrFlt_L*/ *pRes = v_rd_bool(PDCRrMidRSnsrFlt_L_handle); break; case INDEX_COM_RS_PDCRRSNSRFLT_L:/*PDCRRSnsrFlt_L*/ *pRes = v_rd_bool(PDCRRSnsrFlt_L_handle); break;  case INDEX_COM_RS_TAKEKEYOUTRMNDR:/*TakeKeyOutRmndr*/ *pRes = v_rd_bool(TakeKeyOutRmndr_handle); break; case INDEX_COM_RS_ASSINHBTNLAMPON:/*ASSInhBtnLampOn*/ *pRes = v_rd_bool(ASSInhBtnLampOn_handle); break; case INDEX_COM_RS_TIMEADJREQA:/*TimeAdjReqA*/ *pRes = v_rd_bool(TimeAdjReqA_handle); break; case INDEX_COM_RS_CALENDARADJREQA:/*CalendarAdjReqA*/ *pRes = v_rd_bool(CalendarAdjReqA_handle); break; default: *pRes = FALSE; break; } } else { } }  void COM_GetSignalValue_16(U16 Index, PU16 pRes) { U16 Value16; S16 sValue; float fValue = 0; if(NULL != pRes) { switch(Index) { case INDEX_COM_RS_WHLGNDVELLDRVN:/*WhlGndVelLDrvn*/ Value16 = v_rd_16(WhlGndVelLDrvn_handle); *pRes = Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 0.03125; break; case INDEX_COM_RS_WHLGNDVELLNONDRVN:/*WhlGndVelLNonDrvn*/ Value16 = v_rd_16(WhlGndVelLNonDrvn_handle); *pRes = Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 0.03125; break; case INDEX_COM_RS_WhlGndVelRDrvn:/*WhlGndVelRDrvn*/ Value16 = v_rd_16(WhlGndVelRDrvn_handle); *pRes = Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 0.03125; break; case INDEX_COM_RS_WHLGNDVELRNONDRVN:/*WhlGndVelRNonDrvn*/ Value16 = v_rd_16(WhlGndVelRNonDrvn_handle); *pRes = Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 0.03125; break; case INDEX_COM_RS_ENSPD:/*EnSpd*/ Value16 =v_rd_16(EnSpd_handle); *pRes = Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 0.25; break; case INDEX_COM_RS_VEHSPDAVGDRVN:/*VehSpdAvgDrvn*/ Value16 = v_rd_16(VehSpdAvgDrvn_handle); *pRes = (Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 0.015625 ); break; case INDEX_COM_RS_CRUSANDSPDLMTRDRVRSS:/*CrusAndSpdLmtrDrvrSS*/ Value16 =v_rd_16(CrusAndSpdLmtrDrvrSS_handle);  *pRes = (Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 0.0625 + 0.5); break;  case INDEX_COM_RS_DISTRCAVGDRVN:/*DistRCAvgDRVN*/ Value16 = v_rd_16(DistRCAvgDrvn_handle); *pRes = Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 0.125; break; case INDEX_COM_RS_FUELCSUMP:/*FuelCsump*/ Value16 = v_rd_16 (FuelCsump_handle); *pRes = Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 16; break; case INDEX_COM_RS_NAVDIST:/*NavDist*/ Value16 = v_rd_16 (NavDist_handle); *pRes = Value16; break; case INDEX_COM_RS_RDOFRQCVAL:/*RdoFrqcVal*/ Value16 = v_rd_16 (RdoFrqcVal_handle); *pRes = Value16; break; case INDEX_COM_RS_SPDASTSYSTRGTSPD:/*SpdAstSysTrgtSpd*/ Value16 = v_rd_16 (SpdAstSysTrgtSpd_handle); *pRes = Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 16; break; case INDEX_COM_RS_RMNDRVNGDIST:/*RmnDrvngDist*/ Value16 = v_rd_16 (RmnDrvngDist_handle); *pRes = Value16 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp 16; break;  case INDEX_COM_RS_BATVOL:/*BatVol*/ Value16 = v_rd_16 (BatVol_handle);  *pRes = Value16; break; case INDEX_COM_RS_ENCLNTTEM:/*EnClntTem*/ Value16 = v_rd_8(EnClntTem_handle); sValue = Value16 - 40; *pRes = sValue; break; #if 1 //return U16 case INDEX_COM_RS_FLTIREPRS:/*FLTirePrs*/ Value16 = v_rd_8(FLTirePrs_handle); *pRes =Value16* 4; break; case INDEX_COM_RS_FLTIRETEM:/*FLTireTem*/ Value16 = v_rd_8(FLTireTem_handle); sValue = Value16*2-60; *pRes = sValue; break;  case INDEX_COM_RS_FRTIREPRS:/*FRTirePrs*/  Value16 = v_rd_8(FRTirePrs_handle); *pRes =Value16* 4; break; case INDEX_COM_RS_FRTIRETEM:/*FLTireTem*/ Value16 = v_rd_8(FRTireTem_handle); sValue = Value16*2-60; *pRes = sValue; break; case INDEX_COM_RS_RLTIREPRS:/*RLTirePrs*/  Value16 = v_rd_8(RLTirePrs_handle); *pRes =Value16* 4; break; case INDEX_COM_RS_RLTIRETEM:/*FLTireTem*/ Value16 = v_rd_8(RLTireTem_handle); sValue = Value16*2-60; *pRes = sValue; break; case INDEX_COM_RS_RRTIREPRS:/*RRTirePrs*/  Value16 = v_rd_8(RRTirePrs_handle); *pRes =Value16* 4; break; case INDEX_COM_RS_RRTIRETEM:/*FLTireTem*/ Value16 = v_rd_8(RRTireTem_handle); sValue = Value16*2-60; *pRes = sValue; break; #endif case INDEX_COM_RS_FICMOVERSPDTHRSHLDADJ:/*FICMOvrSpdThrshldAdj*/ Value16 = v_rd_8(FICMOvrSpdThrshldAdj_handle); *pRes = Value16*5;  break;  default: break; } } else { } }  BOOL com_WakeUpFrameStoped(void) { static BOOL isStoped = FALSE; static U8 FrmLostCnt = 0;  if(FALSE == v_test_flag(yytest_handle)) { if(FALSE == isStoped) { FrmLostCnt ++; if(COM_100MS_CNT < FrmLostCnt) { isStoped = TRUE; } else {  } } else { FrmLostCnt = 0; } } else {  v_clear_flag(yytest_handle); isStoped = FALSE; FrmLostCnt = 0; } return isStoped; }  /******************************************************************************************/ void v_ctl_ints_restore(v_imask previous) { __DI(); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr disable interrupts */ IMASK_TO_IMR(previous); __EI(); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr enable interrupts */ } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr v_ctl_ints_restore */ v_imask v_ctl_ints_disable(void) { v_imask il_tmp; __DI(); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr disable interrupts */ IMR_TO_IMASK(il_tmp); SET_IMASK_ONE(); __EI(); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr enable interrupts */ return il_tmp; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr v_ctl_ints_disable */   v_uint8 v_co_tx_frame_checksum(v_uint8 checksum_id, V_ARAM v_uint8 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp V_ARAM_PM buff, v_uint8 len, v_uint32 frame_id) { return 0; } v_uint8 v_co_rx_frame_checksum(v_uint8 checksum_id, V_ARAM v_uint8 com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp V_ARAM_PM buff, v_uint8 len, v_uint32 frame_id, v_uint8 checksum) { return 0;  } v_uint16 v_nmco_ioctl(v_c_handle c, v_uint16 op) { return v_ctl_ioctl(c, (v_ioctl_op) op, (void *) 0); }  /*=========================================================================== com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp File Revision History(bottom to top:first revision to last revision) *============================================================================ com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp $Log:$ * com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp Rev: Userid: Date: Description *-------- ---------- --------- ------------------------------ * com.c com_cfg.h com_info.inc com_private.h com_public.h NCF target.c target.h vtp V1.0 Yingying.Liu 2016-12-12 Initial * *===========================================================================*/
