/************************************************************************** | Copyright |------------------------------------------------------------------------ |Copyright(c) by YEEDON MultiMedia Co.LTD. All rights reserved. | | this software if furnished under a license and may be used and copied | only in accordance with the terms of such license and with the inclusion | of he above copyright notic.This software or any other copies thereof | may not be provided of otherwise made available to any other persion. | No title to and ownership of the software is hereby transferred. | | the information in this software is subject to change without notice | and should not be construed as a commitment by | YEEDON MultiMedia Co.LTD. | | YEEDON MultiMedia Co.LTD. assumes no responsibility for the use or reliability | of its Software on equipment which is not supported by YEEDON MultiMedia Co.LTD. |-------------------------------------------------------------- **************************************************************************/    /*-----------------------------------------------------------------------*/ /*----Description of file-----------------------------------------------------*/ /*-----------------------------------------------------------------------*/    /************************************************************************* CHM *************************************************************************/   /*------------------------------------------------------------------------*/ /*-----Head of file----------------------------------------------------------*/ /*------------------------------------------------------------------------*/ #include "chm_info.inc"  /*==========variables=================*/ static BOOL Chm_InitStatus = FALSE; static BOOL Chm_RptGongRefresh = FALSE;  static ChmInfo_ST ChmInfo; static ChmPrm_ST ChmPrmInfo; static ChmToneSendInfo_ST ChmSendToneInfo;  static BOOL ChmJudgeFinishFlag[INDEX_GJ_ALL]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr 当前发生的最高优先级事件 */ static EVT_GETJUDGE_ENUM ChmJudgeIndex; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr 当前发生的最高优先级事件 */ static WARN_EVENT_ENUM ChmJudgeWarn; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr 当前发生的最高优先级事件 */  static Chm_PdcActive_ST isPdcActive; static U8 ChmSendToneStep;   /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: CHM_Init chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: WARN initialization. chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ void CHM_Init(void) { EVT_GETJUDGE_ENUM index;  Chm_InitStatus = FALSE;  ChmInfo.OutCircle = 0; ChmPrmInfo.Duration = 200; ChmSendToneStep = CHM_SENDTONE_ALL;  ChmSendToneInfo.NetCmdTone =OUT_RESERVE_TONE; ChmSendToneInfo.NetCmdDuty =ChmPrmInfo.Duty; ChmSendToneInfo.NetCmdPeriod=ChmPrmInfo.Frequency;  ChmSendToneInfo.NetCmdLoctnFL =FALSE; ChmSendToneInfo.NetCmdLoctnFR =FALSE; ChmSendToneInfo.NetCmdLoctnRL =FALSE; ChmSendToneInfo.NetCmdLoctnRR =FALSE;  ChmJudgeWarn =INDEX_WARN_NULL; ChmJudgeIndex = INDEX_GJ_NULL; for (index = INDEX_GJ_NULL; index < INDEX_GJ_ALL; index++) { ChmJudgeFinishFlag[index] = 0; }  Chm_InitStatus = TRUE; }  /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: CHM_Process_5ms chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: WARN initialization. chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ void CHM_Process_5ms(void) {  if (TRUE == Chm_InitStatus) { chm_PdcAvtive_manage(); chm_ProcessEvent(); } else { /*do nothing*/ } }    /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: chm_ProcessEvent chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: chm evt reaction chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ void chm_ProcessEvent(void) { U8 selfChk, res =RET_INVALID;  static BOOL lev =FALSE;  StsmgEvent_ST evt;  res = PWR_GetChkStatus(&selfChk); switch(selfChk)  { case STATUS_SLFCHK_ING: ChmInfo.OutCircle = 0; ChmSendToneStep =CHM_SENDTONE_ALL;  ChmSendToneInfo.NetCmdTone = OUT_RESERVE_TONE; ChmSendToneInfo.NetCmdDuty = 0; ChmSendToneInfo.NetCmdPeriod= 0;  ChmSendToneInfo.NetCmdLoctnFL = FALSE; ChmSendToneInfo.NetCmdLoctnFR = FALSE; ChmSendToneInfo.NetCmdLoctnRL = FALSE; ChmSendToneInfo.NetCmdLoctnRR = FALSE;  break;  case STATUS_SLFCHK_NOT_READY:  case STATUS_SLFCHK_FINISH: if (ILLU_GetWelComeSts()) { break; } else { }  if (CHM_SENDTONE_NULL == ChmSendToneStep)  { chm_Event_Process(); } else { }  if (OUT_GONG_TONE ==ChmPrmInfo.Tone)  {  switch (ChmJudgeWarn)  { case INDEX_WARN_BRAKE_HANDON_REPEATGONG:  if (lev !=LED_Get_Brake_Level())  { lev =LED_Get_Brake_Level();  if (TRUE == lev) { ChmSendToneStep = CHM_SENDTONE_FADEIN;  } else { ChmSendToneStep = CHM_SENDTONE_FREQ1; }  ChmPrmInfo.Duration =1; } else { }  break;  case INDEX_WARN_SEATBELT_DRV_REPEATGONG: if (lev !=LED_GetLevel())  { lev =LED_GetLevel(); if (TRUE == lev) { ChmSendToneStep = CHM_SENDTONE_FADEIN; } else { ChmSendToneStep = CHM_SENDTONE_FREQ1; }  ChmPrmInfo.Duration =1; } else { }  break;  } }  else { } break; } }   /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: chm_Event_Process chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: chm evt reaction chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ static void chm_Event_Process(void) {  U8 BrkEn = 0;  JudgeEvtData_ST Evt;  StsmgEvent_ST settable_evt;  chm_NewEventProcess(&Evt,&BrkEn); chm_CircleEnd_Process(&Evt,FALSE); chm_CalChmEvt_OutCircle(Evt.event.warn,TRUE);  }   /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: chm_Event_Process chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: chm evt reaction chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: pEvt: ouput pointer,the new chm event information pBrkEn: tell whether new chm event can interupt current chm output signal chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ static void chm_NewEventProcess(JudgeEvtData_ST *pEvt,PU8 pBrkEn) { U8 res =RET_INVALID; U8 chmbrk = 0;  JudgeEvtData_ST judgeevt; JudgeEvtData_ST msgjudgeevt;  if((NULL_PTR == pEvt) || (NULL_PTR == pBrkEn) || (FALSE == Chm_InitStatus)) { return; }   res = EVT_GetWarnPriorEvent(&judgeevt); switch (judgeevt.event.warn)  {  case INDEX_WARN_PDCSTS_INITFAIL_GONG: if (!isPdcActive.Fail )  { isPdcActive.Fail =1;  res = MSG_GetJudgCurEvt(&msgjudgeevt);  if(INDEX_WARN_PDCSTS_INITFAIL_GONG == msgjudgeevt.event.warn) { judgeevt = msgjudgeevt; } else { } } else { judgeevt.event.warn =INDEX_WARN_NULL; } break;  case INDEX_WARN_PDCSTS_INITOK_GONG: if (!isPdcActive.Init )  { isPdcActive.Init =1;  res = MSG_GetJudgCurEvt(&msgjudgeevt);  if(INDEX_WARN_PDCSTS_INITFAIL_GONG == msgjudgeevt.event.warn) { judgeevt = msgjudgeevt; } else { } } else { judgeevt.event.warn =INDEX_WARN_NULL; } break;  case INDEX_WARN_PDCAUDWRN_RANG1_GONG: case INDEX_WARN_PDCAUDWRN_RANG2_GONG:  case INDEX_WARN_PDCAUDWRN_RANG3_GONG:  case INDEX_WARN_PDCAUDWRN_RANG4_GONG:  case INDEX_WARN_PDCAUDWRN_RANG5_GONG:  case INDEX_WARN_PDCAUDWRN_RANG6_GONG:  case INDEX_WARN_PDCAUDWRN_RANG7_GONG:  case INDEX_WARN_PDCAUDWRN_RANG8_GONG:  case INDEX_WARN_PDCAUDWRN_RANG9_GONG:  case INDEX_WARN_PDCAUDWRN_RANG10_GONG:  case INDEX_WARN_PDCAUDWRN_RANG11_GONG:  case INDEX_WARN_PDCAUDWRN_RANG12_GONG: case INDEX_WARN_PDCAUDWRN_RANG13_GONG:  case INDEX_WARN_PDCAUDWRN_RANG14_GONG:  case INDEX_WARN_PDCAUDWRN_RANG15_GONG: break;  default: res = MSG_GetJudgCurEvt(&msgjudgeevt);  if (INDEX_WARN_NULL != msgjudgeevt.event.warn)  { judgeevt = msgjudgeevt; } else { } break; }  *pEvt = judgeevt; *pBrkEn = chmbrk; }   /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: chm_InteruptCircle_Process chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: chm evt reaction chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: pEvt: the new chm event information pBrkEn: tell whether new chm event can interupt current chm output signal chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ static void chm_InteruptCircle_Process(JudgeEvtData_ST *pEvt, U8 BrkEn) {   U8 res =RET_INVALID; U8 chmbrk = 0; U8 state = 0;  if (pEvt->index != ChmJudgeIndex)  { chmbrk = 1; } else { if (pEvt->event.warn != ChmJudgeWarn)  { chmbrk = 1; } else {  /*if CHM EVT exist and MSG do not have chm output IPK should can be interupt*/ res = EVT_GetJudgeEvtVarFlagMap(ChmJudgeIndex, &state);  if ((RET_OK == res) && (0 == state))  { chmbrk = 1; }  else { } }  }  if (TRUE == chmbrk)  { ChmInfo.OutCircle = 0; ChmSendToneStep = CHM_SENDTONE_ALL; ChmJudgeIndex = INDEX_GJ_NULL; ChmJudgeWarn = INDEX_WARN_NULL;  } else { ChmSendToneStep = CHM_SENDTONE_FADEIN; } }  /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: chm_CircleEnd_Process chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: chm evt reaction chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: pEvt: the new chm event information pBrkEn: tell whether new chm event can interupt current chm output signal chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ static void chm_CircleEnd_Process(JudgeEvtData_ST *pEvt, U8 BrkEn) {  U8 res =RET_INVALID; U8 chmbrk = 0; U8 state = 0;  JudgeEvtData_ST judgeevt;  chmbrk = BrkEn;  switch (pEvt->event.warn)  {  case INDEX_WARN_PDCSTS_INITOK_GONG: case INDEX_WARN_PDCSTS_INITFAIL_GONG:  case INDEX_WARN_PDCAUDWRN_RANG1_GONG: case INDEX_WARN_PDCAUDWRN_RANG2_GONG:  case INDEX_WARN_PDCAUDWRN_RANG3_GONG:  case INDEX_WARN_PDCAUDWRN_RANG4_GONG:  case INDEX_WARN_PDCAUDWRN_RANG5_GONG:  case INDEX_WARN_PDCAUDWRN_RANG6_GONG:  case INDEX_WARN_PDCAUDWRN_RANG7_GONG:  case INDEX_WARN_PDCAUDWRN_RANG8_GONG:  case INDEX_WARN_PDCAUDWRN_RANG9_GONG:  case INDEX_WARN_PDCAUDWRN_RANG10_GONG:  case INDEX_WARN_PDCAUDWRN_RANG11_GONG:  case INDEX_WARN_PDCAUDWRN_RANG12_GONG: case INDEX_WARN_PDCAUDWRN_RANG13_GONG:  case INDEX_WARN_PDCAUDWRN_RANG14_GONG:  case INDEX_WARN_PDCAUDWRN_RANG15_GONG:  Chm_RptGongRefresh =1; ChmJudgeFinishFlag[pEvt->index] = 1; break;  default: if (pEvt->index != ChmJudgeIndex)  { chmbrk = 1; } else { if (pEvt->event.warn != ChmJudgeWarn)  { chmbrk = 1; } else {  }  }  if (TRUE == chmbrk)  { switch (ChmPrmInfo.Tone)  { case OUT_PDC_TONE:  case OUT_TICK_TONE: case OUT_TOCK_TONE:  break;  case OUT_GONG_TONE:  case OUT_RESERVE_TONE: default: if (INDEX_WARN_NULL ==pEvt->event.warn)  { ChmInfo.OutCircle =0; } else { } break; }  Chm_RptGongRefresh =1; ChmJudgeFinishFlag[pEvt->index] = 1; ChmJudgeIndex = pEvt->index; ChmJudgeWarn = pEvt->event.warn; } else {  switch (ChmPrmInfo.Tone)  { case OUT_PDC_TONE:  ChmInfo.OutCircle =0;  ChmJudgeFinishFlag[INDEX_GJ_PDC_FAULT] =0; res = MSG_GetJudgeIndex(INDEX_GJ_PDC_FAULT, &state); if ((RET_OK == res) && (0 == state))  { EVT_SetJudgeIndexFlagMap(INDEX_GJ_PDC_FAULT);  } else { }  break;  case OUT_TICK_TONE: case OUT_TOCK_TONE: if (0 <ChmInfo.OutCircle)  {  ChmSendToneStep = CHM_SENDTONE_FADEIN; break; } else { } case OUT_GONG_TONE:  case OUT_RESERVE_TONE: default: if (0 ==ChmInfo.OutCircle)  {  ChmJudgeFinishFlag[ChmJudgeIndex] = 0;  if ( INDEX_MSG_NULL == pEvt->event.msg) { EVT_SetJudgeIndexFlagMap(ChmJudgeIndex); } else { res = MSG_GetJudgeIndex(ChmJudgeIndex, &state); if ((RET_OK == res) && (0 == state))  { EVT_SetJudgeIndexFlagMap(ChmJudgeIndex);  } else { } }  pEvt->event.warn = INDEX_WARN_NULL; } else { } break; }  switch (ChmJudgeWarn)  { case INDEX_WARN_BRAKE_HANDON_REPEATGONG: case INDEX_WARN_DOORANDLID_DOOR_REPEATGONG_HALFHZ:/*EVENT_DOORANDLID_DOOR_WARN_GONG*/  case INDEX_WARN_DOORANDLID_LDSP_REPEATGONG_HALFHZ: case INDEX_WARN_DOORANDLID_BONNET_REPEATGONG_HALFHZ: case INDEX_WARN_IGNKEY_REPEATGONG:/*EVENT_IGNKEY_WARN_REPEATGONG*/  case INDEX_WARN_LIGHT_REPEATGONG:/*EVENT_LIGHT_WARN_GONG*/ case INDEX_WARN_SEATBELT_DRV_REPEATGONG:/*EVENT_SEATBELT_DRV_WARN_REPEATGONG*/  //case INDEX_WARN_SEATBELT_PNSG_REPEATGONG:/*EVENT_SEATBELT_PNSG_WARN_REPEATGONG*/  case INDEX_WARN_SEATBELT_LAMPON_REPEATGONG:/*EVENT_SEATBELT_LAMPON_WARN_REPEATGONG*/  case INDEX_WARN_EPBSTS_REPEAT_GONG_HALFHZ:  if (0 < ChmJudgeFinishFlag[ChmJudgeIndex])  { break; } else { }  ChmJudgeFinishFlag[ChmJudgeIndex] =0;  default:  res = EVT_GetWarnPriorEvent(&judgeevt); switch (judgeevt.event.warn)  { case INDEX_WARN_LEFTDIR_TICK: case INDEX_WARN_LEFTDIR_TOCK: case INDEX_WARN_RIGHTDIR_TICK: case INDEX_WARN_RIGHTDIR_TOCK: *pEvt = judgeevt; ChmJudgeFinishFlag[pEvt->index] = 1; break;  default: pEvt->event.warn = INDEX_WARN_NULL; break; }   break; } }  break; }  }   /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: chm_CalChmEvt_OutCircle chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: chm evt reaction chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ static void chm_CalChmEvt_OutCircle(WARN_EVENT_ENUM chmIndex,U8 isEnd) {  U8 state = 0;  U8 gongCfgTime = 0;   StsmgEvent_ST evt;  if (INDEX_WARN_NULL != chmIndex)  {  switch (chmIndex)  { case INDEX_WARN_BRAKE_HANDON_REPEATGONG:  if (Chm_RptGongRefresh)  { Chm_RptGongRefresh =0;  memcpy(&ChmInfo,&Chm_ToneMatrix[chmIndex], sizeof(ChmInfo_ST));   gongCfgTime = DIAG_GetIgnOffSpelWarnPeriod(); ChmInfo.OutCircle = (gongCfgTime+(gongCfgTime%2? 1:0))/2; } else { }  if(FALSE == LED_Get_Brake_Level())  { } else { ChmSendToneStep = CHM_SENDTONE_FADEIN;  }  break;  case INDEX_WARN_IGNKEY_REPEATGONG: case INDEX_WARN_LIGHT_REPEATGONG: if (Chm_RptGongRefresh)  { Chm_RptGongRefresh =0;  memcpy(&ChmInfo,&Chm_ToneMatrix[chmIndex], sizeof(ChmInfo_ST));   gongCfgTime = DIAG_GetIgnOffSpelWarnPeriod(); ChmInfo.OutCircle = (gongCfgTime+(gongCfgTime%2? 1:0))/2; } else { }  ChmSendToneStep = CHM_SENDTONE_FADEIN; break;  case INDEX_WARN_SEATBELT_DRV_REPEATGONG: if (Chm_RptGongRefresh)  { Chm_RptGongRefresh =0;  memcpy(&ChmInfo,&Chm_ToneMatrix[chmIndex], sizeof(ChmInfo_ST));   gongCfgTime = DIAG_GetSBeltRemPeriod(); ChmInfo.OutCircle = (gongCfgTime+(gongCfgTime%2? 1:0))/2;  } else { }  if(FALSE == LED_GetLevel())  { } else {  ChmSendToneStep = CHM_SENDTONE_FADEIN; } break;  case INDEX_WARN_EPBSTS_REPEAT_GONG_HALFHZ: if (Chm_RptGongRefresh)  { Chm_RptGongRefresh =0;  memcpy(&ChmInfo,&Chm_ToneMatrix[chmIndex], sizeof(ChmInfo_ST));   gongCfgTime = DIAG_GetEPBConstantGongPeriod(); ChmInfo.OutCircle = (gongCfgTime+(gongCfgTime%2? 1:0))/2; } else { }  ChmSendToneStep = CHM_SENDTONE_FADEIN; break; case INDEX_WARN_DOORANDLID_DOOR_REPEATGONG_HALFHZ:/*EVENT_DOORANDLID_DOOR_WARN_GONG*/  case INDEX_WARN_DOORANDLID_LDSP_REPEATGONG_HALFHZ: case INDEX_WARN_DOORANDLID_BONNET_REPEATGONG_HALFHZ: case INDEX_WARN_SEATBELT_LAMPON_REPEATGONG:/*EVENT_SEATBELT_LAMPON_WARN_REPEATGONG*/  if (Chm_RptGongRefresh)  { Chm_RptGongRefresh =0; memcpy(&ChmInfo,&Chm_ToneMatrix[chmIndex], sizeof(ChmInfo_ST));  } else { }  ChmSendToneStep = CHM_SENDTONE_FADEIN; break;  default: memcpy(&ChmInfo,&Chm_ToneMatrix[chmIndex], sizeof(ChmInfo_ST));  ChmSendToneStep = CHM_SENDTONE_FADEIN; break;  } } }  /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: CHM_SendNetSignal_5ms chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: chm net signal sendout chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ void CHM_SendNetSignal_5ms(void) { v_wr_8(ChmCmdSndTone_handle, ChmSendToneInfo.NetCmdTone); v_wr_8(ChmCmdSndCndcPrd_handle, ChmSendToneInfo.NetCmdPeriod); v_wr_8(ChmCmdSndDutyCyc_handle, ChmSendToneInfo.NetCmdDuty);  v_wr_8(ChmCmdSndLoctnFL_handle, ChmSendToneInfo.NetCmdLoctnFL); v_wr_8(ChmCmdSndLoctnFR_handle, ChmSendToneInfo.NetCmdLoctnFR); v_wr_8(ChmCmdSndLoctnRL_handle, ChmSendToneInfo.NetCmdLoctnRL); v_wr_8(ChmCmdSndLoctnRR_handle, ChmSendToneInfo.NetCmdLoctnRR); }   /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: CHM_GetChmEvtFinishStatus chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: chm Get event is finished or not chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: index: event index chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns: RET_FAIL :chm init fail RET_INVALID: parameter is outof rang RET_OK: SUCCESS * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ U8 CHM_GetChmEvtFinishStatus(U8 index, PU8 psts) { if (FALSE == Chm_InitStatus) {  return RET_FAIL; } else if (INDEX_GJ_ALL <= index) {  return RET_INVALID; } else { *psts = ChmJudgeFinishFlag[index]; return RET_OK; }   }   /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: CHM_SetJudgeIndex chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: chm Get event is finished or not chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: index: event index chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns: RET_FAIL :chm init fail RET_INVALID: parameter is outof rang RET_OK: SUCCESS * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ U8 CHM_SetJudgeIndex(U8 index) { if (FALSE == Chm_InitStatus) {  return RET_FAIL; } else if (INDEX_GJ_ALL <= index) {  return RET_INVALID; } else { ChmJudgeIndex = index;  return RET_OK;  }   }  /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: CHM_ChmSignalOutPut_5ms chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: chm Get event is finished or not chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ void CHM_SignalOutPutProcess_5ms(void) { U8 res = 0;  if (1 < ChmPrmInfo.Duration)  { ChmPrmInfo.Duration--;  } else { switch (ChmSendToneStep)  { case CHM_SENDTONE_FADEIN: case CHM_SENDTONE_FREQ1: case CHM_SENDTONE_FREQ2: case CHM_SENDTONE_FADEOUT: memcpy(&ChmPrmInfo, &ChmInfo.pPrmList[ChmSendToneStep-1], sizeof(ChmPrm_ST));   ChmSendToneStep ++; if (0 <= ChmPrmInfo.Duration)  { ChmSendToneInfo.NetCmdTone = ChmPrmInfo.Tone; ChmSendToneInfo.NetCmdDuty = ChmPrmInfo.Duty; ChmSendToneInfo.NetCmdPeriod = ChmPrmInfo.Frequency;  ChmSendToneInfo.NetCmdLoctnRL = FALSE; ChmSendToneInfo.NetCmdLoctnRR = FALSE;  switch (ChmPrmInfo.Tone)  { case OUT_PDC_TONE: if (DIAG_GetPDCEnable()) { ChmSendToneInfo.NetCmdLoctnFL = TRUE; ChmSendToneInfo.NetCmdLoctnFR = TRUE; } else { ChmSendToneInfo.NetCmdLoctnFL = FALSE; ChmSendToneInfo.NetCmdLoctnFR = FALSE; }  break;  case OUT_TICK_TONE: case OUT_TOCK_TONE: case OUT_GONG_TONE:  case OUT_RESERVE_TONE: default: if (DIAG_GetHandofDrive()) { ChmSendToneInfo.NetCmdLoctnFL = FALSE; ChmSendToneInfo.NetCmdLoctnFR = TRUE; } else { ChmSendToneInfo.NetCmdLoctnFL = TRUE; ChmSendToneInfo.NetCmdLoctnFR = FALSE; } break; }  } else { }  if (CHM_SENDTONE_FADEOUT >= ChmSendToneStep) { if (0 == ChmInfo.pPrmList[ChmSendToneStep-1].Duration) { ChmSendToneStep = CHM_SENDTONE_ALL; } else { } } else { }  break;  case CHM_SENDTONE_ALL: if (0 < ChmInfo.OutCircle)  { if (0xEEEE != ChmInfo.OutCircle) { -- ChmInfo.OutCircle; } else { /*DO NOTHING*/ }  } ChmSendToneStep = CHM_SENDTONE_NULL;  case CHM_SENDTONE_NULL:  if (0 == ChmInfo.OutCircle)  { ChmSendToneInfo.NetCmdTone = OUT_RESERVE_TONE; ChmSendToneInfo.NetCmdDuty = 0; ChmSendToneInfo.NetCmdPeriod = 0;  ChmSendToneInfo.NetCmdLoctnFL = FALSE; ChmSendToneInfo.NetCmdLoctnFR = FALSE; ChmSendToneInfo.NetCmdLoctnRL = FALSE; ChmSendToneInfo.NetCmdLoctnRR = FALSE;  } else { /*DO NOTHING*/ }  break; }  }  }   /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: chm_PdcAvtive_manage chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: set pdc active state chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none * chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ static void chm_PdcAvtive_manage(void) { U8 pwr_mode = PWR_OFF;  PWR_GetPwrMode(&pwr_mode);  if((PWR_ACC == pwr_mode) || (PWR_OFF == pwr_mode)) {  isPdcActive.Init = 0; isPdcActive.Fail = 0; }  }  /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: CHM_SetPdcAvtive_manage chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: set pdc active state chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns:none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h RET_FAIL: INITIAL FAILED RET_INVALID:PARAMETER NOT AVALIABLE RET_OK: SUCCESS chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ U8 CHM_SetPdcAvtive_manage(Chm_PdcActive_ST *PdcActive) { U8 res = RET_OK;  if (FALSE == Chm_InitStatus) { res = RET_FAIL; } else if (NULL_PTR == PdcActive) { res = RET_INVALID; } else {  isPdcActive = *PdcActive; }  return res; }   /*************************************************** chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Function: CHM_GetPdcActiveStatus chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Description: get pdc active state chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Parameters: none chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Returns: RET_FAIL: INITIAL FAILED RET_INVALID:PARAMETER NOT AVALIABLE RET_OK: SUCCESS  chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $Create & Verlog:$ chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h Author:xs Date:2017-6-23 Version:V2.0 chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h $log: ****************************************************/ U8 CHM_GetPdcActiveStatus(Chm_PdcActive_ST *pActive) { U8 res = RET_OK; if (FALSE == Chm_InitStatus) { res = RET_FAIL; } else if (NULL_PTR == pActive) { res = RET_INVALID; } else { *pActive = isPdcActive; } return res; } /*=========================================================================================================== chm.c chm_cfg.h chm_info.inc chm_private.h chm_public.h File Revision History (bottom to top:first revision to last revision) * *============================================================================================================ *$Log:$ *  *Rev: Userid: date: description *----- ----- ----------- ----------- *Rev 1 xs 2017-06-23 initial ============================================================================================================*/
