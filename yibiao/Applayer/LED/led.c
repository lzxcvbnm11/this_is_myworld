  /************************************************************************** | Copyright |------------------------------------------------------------------------ |Copyright(c) by YEEDON MultiMedia Co.LTD. All rights reserved. | | this software if furnished under a license and may be used and copied | only in accordance with the terms of such license and with the inclusion | of he above copyright notic.This software or any other copies thereof | may not be provided of otherwise made available to any other persion. | No title to and ownership of the software is hereby transferred. | | the information in this software is subject to change without notice | and should not be construed as a commitment by | YEEDON MultiMedia Co.LTD. | | YEEDON MultiMedia Co.LTD. assumes no responsibility for the use or reliability | of its Software on equipment which is not supported by YEEDON MultiMedia Co.LTD. |-------------------------------------------------------------- **************************************************************************/    /*-----------------------------------------------------------------------*/ /*----Description of file-----------------------------------------------------*/ /*-----------------------------------------------------------------------*/    /************************************************************************* LED source file used for LED ON,OFF,FLASH control when warn or other event trigged *************************************************************************/   /*------------------------------------------------------------------------*/ /*-----Head of file----------------------------------------------------------*/ /*------------------------------------------------------------------------*/ #include "led_info.inc"   /*==========variables=================*/ static BOOL led_InitSts = FALSE; static U32 led_GCounter = 0; static U8 led_invalidCnt = 0; static LedEventData_ST led_EventData; static LEDLightData_ST led_data[LEDLAMP_ALL]; static LEDState_ST led_State; static LEDState_ST led_out; static LEDState_ST led_Enable;  static BOOL insCruiseLampEnPrm = FALSE; static BOOL insLoadShedLampEnPrm = FALSE; static BOOL insEPSLampEnPrm = FALSE; static BOOL insSASLampEnPrm = FALSE; static BOOL insESCLLampEnPrm = FALSE; static BOOL insDSCLampEnPrm = FALSE; static BOOL insFrFogLampEnPRm = FALSE; static BOOL insNoSmartKeyLampEnPrm = FALSE; static BOOL insSecKeyInvLampEnPrm = FALSE;/*V2*/ static BOOL insKeyBatLowLampEnPrm = FALSE; static BOOL insEcoLampEnPrm = FALSE; static BOOL insDSCOffLampEnPrm = FALSE; static BOOL insStopStartSysEnPrm = FALSE; static BOOL insTPMSFailEnPrm = FALSE;/*V2*/ static BOOL insEPBStatusEnPrm = FALSE;/*V2*/ static BOOL insAutoholdStatusEnPrm = FALSE;/*V2*/ static BOOL insHDCLampEnPrm = FALSE;/*V2*/  static U16 led_count[FREQUENCY_LED_ALL]; static BOOL led_flash[FREQUENCY_LED_ALL];  /************************************************** *Function :LED_Init *Description: LED Module Inital *Parameters:none *Returns: none **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 ***************************************************/ void LED_Init(void) { U8 i = 0; U8 res = 0;   led_GCounter = 0;  memset(&led_count, 0, sizeof(led_count)); memset(&led_flash, 0, sizeof(led_flash));  memset(&led_EventData, 0, sizeof(led_EventData)); memset(&led_State, 0, sizeof(led_State));  for (i =0; i <LEDLAMP_ALL; i++) { memset(&(led_data[i]), 0, sizeof(led_data[i])); }  led_out = led_State; led_Enable.lrm_lamp.LRM_value[0] = 0xff; led_Enable.lrm_lamp.LRM_value[1] = 0xff; led_Enable.lrm_lamp.LRM_value[2] = 0xff; led_Enable.lrm_lamp.LRM_value[3] = 0xff; led_Enable.lrm_lamp.LRM_value[4] = 0xff; led_Enable.lrm_lamp.LRM_value[5] = 0xff; led_Enable.assLamp = TRUE; led_invalidCnt = 0;   insCruiseLampEnPrm = DIAG_GetCruiseLampEn(); insEPSLampEnPrm = DIAG_GetEPSLampEn(); insSASLampEnPrm = DIAG_GetSASLampEn(); insESCLLampEnPrm = DIAG_GetESCLLampEn(); insDSCLampEnPrm = DIAG_GetDSCLampEn(); insLoadShedLampEnPrm = DIAG_GetLoadShedLampEn(); insFrFogLampEnPRm = DIAG_GetFrFogLampEn(); insNoSmartKeyLampEnPrm = DIAG_GetNoSmartKeyLampEn(); insKeyBatLowLampEnPrm = DIAG_GetKeyBatLowLampEn(); insEcoLampEnPrm = DIAG_GetEcoLampEn(); insStopStartSysEnPrm = DIAG_GetStopStartSysEn(); insTPMSFailEnPrm = DIAG_GetTPMSFailEn(); insAutoholdStatusEnPrm = DIAG_GetAutoholdStatusEn(); insHDCLampEnPrm = DIAG_GetHDCLampEn(); insEPBStatusEnPrm = DIAG_GetEPBStatusEn(); insSecKeyInvLampEnPrm = DIAG_GetInsSecKeyInvLampEnPrm();/*V2*/  led_SetLampStatus(&led_Enable, LEDLAMP_CRUISE_GREEN, insCruiseLampEnPrm); led_SetLampStatus(&led_Enable, LEDLAMP_CRUISE_YELLOW, insCruiseLampEnPrm); led_SetLampStatus(&led_Enable, LEDLAMP_SIDELIGHTS, insLoadShedLampEnPrm);  if(( TRUE == insEPSLampEnPrm) || (TRUE == insSASLampEnPrm)) { led_SetLampStatus(&led_Enable, LEDLAMP_EPS_ERROR, TRUE); } else { led_SetLampStatus(&led_Enable, LEDLAMP_EPS_ERROR, FALSE); }  if((TRUE == insEPSLampEnPrm) ||(TRUE == insESCLLampEnPrm)) { led_SetLampStatus(&led_Enable, LEDLAMP_EPS_WARN, TRUE); } else { led_SetLampStatus(&led_Enable, LEDLAMP_EPS_WARN, FALSE); }  led_SetLampStatus(&led_Enable, LEDLAMP_SCSSTART, insDSCLampEnPrm); led_SetLampStatus(&led_Enable, LEDLAMP_SCS_OFF, insDSCLampEnPrm);  led_SetLampStatus(&led_Enable, LEDLAMP_FRONT_FOG, insFrFogLampEnPRm); if ((TRUE == insNoSmartKeyLampEnPrm) || (TRUE ==insKeyBatLowLampEnPrm) || (TRUE ==insSecKeyInvLampEnPrm)) { led_SetLampStatus(&led_Enable, LEDLAMP_ALARM, TRUE); } else { led_SetLampStatus(&led_Enable, LEDLAMP_ALARM, FALSE); }  led_SetLampStatus(&led_Enable, LEDLAMP_ECOMODE, insEcoLampEnPrm);  led_SetLampStatus(&led_Enable, LEDLAMP_ASS_ACTIVE, insStopStartSysEnPrm); led_SetLampStatus(&led_Enable, LEDLAMP_ASS_ERROR, insStopStartSysEnPrm); led_SetLampStatus(&led_Enable, LEDLAMP_TPMS_WARN, insTPMSFailEnPrm); led_SetLampStatus(&led_Enable, LEDLAMP_EPB, insEPBStatusEnPrm); led_SetLampStatus(&led_Enable, LEDLAMP_EPB_OFF, insEPBStatusEnPrm); led_SetLampStatus(&led_Enable, LEDLAMP_AUTOHOLD_GREEN, insAutoholdStatusEnPrm); led_SetLampStatus(&led_Enable, LEDLAMP_HDC_GREEN, insHDCLampEnPrm); led_SetLampStatus(&led_Enable, LEDLAMP_HDC_YELLOW, insHDCLampEnPrm);   if ((FALSE == IOM_GetModuleStatus()) ||(FALSE == LRM_GetInitStatus())) { led_InitSts = FALSE; } else { led_InitSts = TRUE; } }   /************************************************** *Function :LED_Process_50ms *Description: LED Module Process *Parameters:none *Returns: none **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 ***************************************************/ void LED_Process_50ms(void) { U8 checksts; U8 i, res; U8 mode = 0;  if (TRUE == led_InitSts)  {  res = PWR_GetChkStatus(&checksts); switch(checksts) {  case STATUS_SLFCHK_ING:  led_SelfChkProcess(); break; case STATUS_SLFCHK_NOT_READY:  case STATUS_SLFCHK_FINISH: led_GCounter = 0; led_NormalProcess(); break; }  } else { /*do nothing*/ } }   /************************************************** *Function :led_SelfChkProcess *Description: LED Module SelfCheck process *Parameters:none *Returns: none **create&Verlog: *Author Name liuyingying Date:2016-11-28 Ver:01 ***************************************************/ static void led_SelfChkProcess( void ) { LRMState_UN ledOut; U8 i = 0;  led_GCounter ++; if (SELF_CHECK_CNT >= led_GCounter) { for(i = 0; i < LRM_LAMP_ALL; i ++) { ledOut.LRM_value[i] = (led_selfcheckMatrix[led_GCounter-1].lrm_lamp.LRM_value[i] & led_Enable.lrm_lamp.LRM_value[i]) ; }  if((TRUE == led_GetLampDataByIndex(&led_Enable,LEDLAMP_EPS_ERROR)) && (FALSE == led_GetLampDataByIndex(&led_Enable,LEDLAMP_EPS_WARN))) { led_SetLampStatus(&ledOut,LEDLAMP_EPS_ERROR,1); } else if((FALSE == led_GetLampDataByIndex(&led_Enable,LEDLAMP_EPS_ERROR)) && (TRUE == led_GetLampDataByIndex(&led_Enable,LEDLAMP_EPS_WARN))) { led_SetLampStatus(&ledOut,LEDLAMP_EPS_WARN,1); } else { }  if((TRUE == led_GetLampDataByIndex(&led_Enable,LEDLAMP_EPB)) && (FALSE == led_GetLampDataByIndex(&led_Enable,LEDLAMP_AUTOHOLD_GREEN))) { led_SetLampStatus(&ledOut,LEDLAMP_EPB,1); } else if((FALSE == led_GetLampDataByIndex(&led_Enable,LEDLAMP_EPB)) && (TRUE == led_GetLampDataByIndex(&led_Enable,LEDLAMP_AUTOHOLD_GREEN))) { led_SetLampStatus(&ledOut,LEDLAMP_AUTOHOLD_GREEN,1); } else { }  if (TRUE != insSecKeyInvLampEnPrm) { led_SetLampStatus(&ledOut, LEDLAMP_ALARM, FALSE); } else { }  led_out.lrm_lamp = ledOut; //led_selfcheckMatrix[led_GCounter].lrm_lamp; /*∑¿µ¡µ∆ U14 Q0 */   } else {  /*nothing*/ } }  /************************************************** *Function :led_NormalProcess *Description: LED Module normal process *Parameters:none *Returns: none **create&Verlog: *Author Name liuyingying Date:2016-11-28 Ver:01 ***************************************************/ static void led_NormalProcess( void ) { led_LampUpdateProcess(); led_OutPutProcess(); }    /************************************************** *Function :led_GetLampIndex *Description: Get Water Temperature warn type *Parameters:type: input TYPE_LED_FUEL TYPE_LED_TEMP SegIndex:LEVEL_LED_SEGNONE~LEDLAMP_FUELSEGMENT8   *Returns: LEDLamp_ENUM:the lampindex according to type and SegIndex  **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 ***************************************************/ static LEDLamp_ENUM led_GetLampIndex(U8 type, U8 index) { LEDLamp_ENUM lamp = LEDLAMP_NONE;  switch (type) { case TYPE_LED_FUEL: switch (index) { case LEVEL_LED_SEGNONE: case LEVEL_LED_SEG1: lamp = LEDLAMP_FUELSEGMENT1; break; case LEVEL_LED_SEG2: lamp = LEDLAMP_FUELSEGMENT2; break; case LEVEL_LED_SEG3: lamp = LEDLAMP_FUELSEGMENT3; break; case LEVEL_LED_SEG4: lamp = LEDLAMP_FUELSEGMENT4; break; case LEVEL_LED_SEG5: lamp = LEDLAMP_FUELSEGMENT5; break; case LEVEL_LED_SEG6: lamp = LEDLAMP_FUELSEGMENT6; break; case LEVEL_LED_SEG7: lamp = LEDLAMP_FUELSEGMENT7; break; case LEVEL_LED_SEG8: lamp = LEDLAMP_FUELSEGMENT8; break; default: /*do nothing*/ break; } break;  case TYPE_LED_TEMP: switch (index) { case LEVEL_LED_SEGNONE: lamp =LEDLAMP_NONE; break; case LEVEL_LED_SEG1: lamp = LEDLAMP_TEMPSEGMENT1; break; case LEVEL_LED_SEG2: lamp = LEDLAMP_TEMPSEGMENT2; break; case LEVEL_LED_SEG3: lamp = LEDLAMP_TEMPSEGMENT3; break; case LEVEL_LED_SEG4: lamp = LEDLAMP_TEMPSEGMENT4; break; case LEVEL_LED_SEG5: lamp = LEDLAMP_TEMPSEGMENT5; break; case LEVEL_LED_SEG6: lamp = LEDLAMP_TEMPSEGMENT6; break; case LEVEL_LED_SEG7: lamp = LEDLAMP_TEMPSEGMENT7; break; case LEVEL_LED_SEG8: lamp = LEDLAMP_TEMPSEGMENT8; break; default: /*do nothing*/ break; } break;  default: lamp =led_Matrix[index].index; break; }  return lamp; }  /************************************************** *Function :led_GetLampDataByIndex *Description: Get led function enable or disable by configuration *Parameters:type: LEDLamp_ENUM lamp input lampIndex   *Returns: TRUE:lamp enable FALSE:lamp disable  **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 *****************************************************/ static BOOL led_GetLampDataByIndex(LEDState_ST *pValue, LEDLamp_ENUM lamp) { LEDState_ST *state = pValue;  BOOL lightSts = FALSE;  switch(lamp) {  case LEDLAMP_NONE:/* Reserved Bits */ break; case LEDLAMP_AUTOHOLD_GREEN:/* Reserved Bits */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_AUTOHOLD_GREEN;//state->lrm_lamp->BYTES->LRM_TYPE_Reserve1; break; case LEDLAMP_TURNLEFT:/* ◊Û◊™œÚµ∆¬Ã */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TURNLEFT; break; case LEDLAMP_BRAKEERROR:/* ÷∆∂Ø∆˜π ’œµ∆∫Ï*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_BRAKEERROR; break; case LEDLAMP_SRS:/* ∞≤»´∆¯ƒ“µ∆∫Ï */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_SRS; break; case LEDLAMP_ABS_ERROR:/* ABSπ ’œµ∆ª∆ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_ABS_ERROR; break; case LEDLAMP_SEATBELT_UNFASTEN:/* ∞≤»´¥¯Œ¥œµµ∆∫Ï*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_SEATBELT_UNFASTEN; break; case LEDLAMP_TPMS_WARN:/* Ã•—π±®æØµ∆ª∆*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TPMS_WARN; break; case LEDLAMP_SCSSTART:/* SCS∆Ù∂Øµ∆ª∆*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_SCSSTART; break; case LEDLAMP_EPB:/* ECALL ‘§¡Ù */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_EPB_RED; break; case LEDLAMP_FUEL_WARN:/* »º”Õ±®æØµ∆ª∆ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FUEL_WARN; break; case LEDLAMP_BEAM_LAMP:/* ‘∂π‚µ∆¿∂ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_BEAM_LAMP; break; case LEDLAMP_REAR_FOG:/*∫ÛŒÌµ∆ª∆*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_REAR_FOG; break; case LEDLAMP_EPB_OFF:/* EPB OFFµ∆ª∆*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_EPB_OFF; break; case LEDLAMP_SCS_OFF:/* SCSπÿ±’µ∆ª∆*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_SCS_OFF; break; case LEDLAMP_CRUISE_GREEN:/* —≤∫Ωµ∆¬Ã*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_CRUISE_GREEN; break; case LEDLAMP_CRUISE_YELLOW: /*—≤∫Ωµ∆ª∆ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_CRUISE_YELLOW; break; case LEDLAMP_FUELSEGMENT8:/* »º”Õ8∂Œµ∆∞◊*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT8; break; case LEDLAMP_FUELSEGMENT7:/* »º”Õ7∂Œµ∆∞◊*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT7; break; case LEDLAMP_FUELSEGMENT6:/* »º”Õ6∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT6; break; case LEDLAMP_FUELSEGMENT5:/* »º”Õ5∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT5; break; case LEDLAMP_FUELSEGMENT4:/* »º”Õ4∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT4; break; case LEDLAMP_FUELSEGMENT3:/* »º”Õ3∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT3; break; case LEDLAMP_FUELSEGMENT2:/* »º”Õ2∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT2; break; case LEDLAMP_FUELSEGMENT1:/* »º”Õ1∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT1; break; case LEDLAMP_TEMPSEGMENT1:/* ÀÆŒ¬1∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT1; break; case LEDLAMP_TEMPSEGMENT8:/* ÀÆŒ¬8∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT8; break; case LEDLAMP_TEMPSEGMENT7:/*ÀÆŒ¬7∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT7; break; case LEDLAMP_TEMPSEGMENT6:/* ÀÆŒ¬6∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT6; break; case LEDLAMP_TEMPSEGMENT5:/* ÀÆŒ¬5∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT5; break; case LEDLAMP_TEMPSEGMENT4:/* ÀÆŒ¬4∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT4; break; case LEDLAMP_TEMPSEGMENT3:/* ÀÆŒ¬3∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT3; break; case LEDLAMP_TEMPSEGMENT2:/* ÀÆŒ¬2∂Œµ∆∞◊ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT2; break; case LEDLAMP_TEMP_WARN_RED: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Reserved Bits */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TEMP_WARN; break; case LEDLAMP_ASS_ACTIVE:/* SSBº§ªÓµ∆¬Ã */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_SSB_ACTIVE; break; case LEDLAMP_ASS_ERROR:/* ∆ÙÕ£π ’œµ∆ª∆*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_SSB_ERROR; break; case LEDLAMP_ECOMODE:/* æ≠º√ƒ£ Ωµ∆¬Ã */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_ECOMODE; // break; case LEDLAMP_SIDELIGHTS:/* Œª÷√µ∆¬Ã*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_SIDELIGHTS; // break; case LEDLAMP_FRONT_FOG:/* «∞ŒÌµ∆¬Ã */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FRONG_FOG; // break; case LEDLAMP_HDC_GREEN:/* ÀÆŒ¬±®æØµ∆∫Ï*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_HDC_GREEN; // break; case LEDLAMP_HDC_YELLOW:/* ÀÆŒ¬±®æØµ∆∫Ï*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_HDC_YELLOW; // break; case LEDLAMP_ALARM:/*∑¿µ¡µ∆*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_THEFTPROOF; break; case LEDLAMP_EPS_ERROR:/* EPSπ ’œµ∆∫Ï */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_EPS_ERROR; // break; case LEDLAMP_EPS_WARN:/* EPSæØ∏Êµ∆ª∆ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_EPS_WARN; // break; case LEDLAMP_CHARGER:/*Ωª¡˜≥‰µÁµ∆∫Ï */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_CHARGER; // break; case LEDLAMP_EMS_ERROR:/* ∑¢∂Øª˙π ’œµ∆ª∆*/ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_EMS_ERROR; // break; case LEDLAMP_EMISSION_ERROR:/* ≈≈∑≈π ’œµ∆ª∆ */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_EMISSION_ERROR; // break; case LEDLAMP_FUELPRESURE_LOW:/* ª˙”Õ—π¡¶µÕµ∆∫Ï */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_FUELPRESURE_LOW; // break; case LEDLAMP_TURNRIGHT:/*”“◊™œÚµ∆¬Ã */ lightSts = state->lrm_lamp.BYTES.LRM_TYPE_TURNRIGHT; // break; case LEDLAMP_ASS:/*◊‘∆ÙÕ£±®æØµ∆ */ lightSts = state->assLamp; break; default: lightSts = FALSE; break; } return lightSts; }  /************************************************** *Function :led_SetLampStatus *Description: Set Led output status *Parameters:state output structure,the bits of state will set to value lamp input lampindex, for which the value will be set value input :true set light on false set light off  *Returns: TRUE:success FALSE:fail  **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 ***************************************************/  static BOOL led_SetLampStatus(LEDState_ST *state, LEDLamp_ENUM lamp, U8 Value) { BOOL res = TRUE;  if(NULL_PTR !=state) { switch(lamp) {  case LEDLAMP_AUTOHOLD_GREEN:/* Reserved Bits */ state->lrm_lamp.BYTES.LRM_TYPE_AUTOHOLD_GREEN=Value; ///new add break; case LEDLAMP_TURNLEFT:/* ◊Û◊™œÚµ∆¬Ã */ state->lrm_lamp.BYTES.LRM_TYPE_TURNLEFT=Value; break; case LEDLAMP_BRAKEERROR:/* ÷∆∂Ø∆˜π ’œµ∆∫Ï*/ state->lrm_lamp.BYTES.LRM_TYPE_BRAKEERROR=Value; break; case LEDLAMP_SRS:/* ∞≤»´∆¯ƒ“µ∆∫Ï */ state->lrm_lamp.BYTES.LRM_TYPE_SRS=Value; break; case LEDLAMP_ABS_ERROR:/* ABSπ ’œµ∆ª∆ */ state->lrm_lamp.BYTES.LRM_TYPE_ABS_ERROR=Value; break; case LEDLAMP_SEATBELT_UNFASTEN:/* ∞≤»´¥¯Œ¥œµµ∆∫Ï*/ state->lrm_lamp.BYTES.LRM_TYPE_SEATBELT_UNFASTEN=Value; break; case LEDLAMP_TPMS_WARN:/* Ã•—π±®æØµ∆ª∆*/ state->lrm_lamp.BYTES.LRM_TYPE_TPMS_WARN=Value; break; case LEDLAMP_SCSSTART:/* SCS∆Ù∂Øµ∆ª∆*/ state->lrm_lamp.BYTES.LRM_TYPE_SCSSTART=Value; break; case LEDLAMP_EPB:/* ECALL ‘§¡Ù */ state->lrm_lamp.BYTES.LRM_TYPE_EPB_RED=Value; break; case LEDLAMP_FUEL_WARN:/* »º”Õ±®æØµ∆ª∆ */ state->lrm_lamp.BYTES.LRM_TYPE_FUEL_WARN=Value; break; case LEDLAMP_BEAM_LAMP:/* ‘∂π‚µ∆¿∂ */ state->lrm_lamp.BYTES.LRM_TYPE_BEAM_LAMP=Value; break; case LEDLAMP_REAR_FOG:/*∫ÛŒÌµ∆ª∆*/ state->lrm_lamp.BYTES.LRM_TYPE_REAR_FOG=Value; break; case LEDLAMP_EPB_OFF:/* TC OFFµ∆ª∆*/ state->lrm_lamp.BYTES.LRM_TYPE_EPB_OFF=Value; break; case LEDLAMP_SCS_OFF:/* SCSπÿ±’µ∆ª∆*/ state->lrm_lamp.BYTES.LRM_TYPE_SCS_OFF=Value; break; case LEDLAMP_CRUISE_GREEN:/* —≤∫Ωµ∆¬Ã*/ state->lrm_lamp.BYTES.LRM_TYPE_CRUISE_GREEN=Value; break; case LEDLAMP_CRUISE_YELLOW: /*—≤∫Ωµ∆ª∆ */ state->lrm_lamp.BYTES.LRM_TYPE_CRUISE_YELLOW=Value; break; case LEDLAMP_FUELSEGMENT8:/* »º”Õ8∂Œµ∆∞◊*/ state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT8=Value; break; case LEDLAMP_FUELSEGMENT7:/* »º”Õ7∂Œµ∆∞◊*/ state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT7=Value; break; case LEDLAMP_FUELSEGMENT6:/* »º”Õ6∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT6=Value; break; case LEDLAMP_FUELSEGMENT5:/* »º”Õ5∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT5=Value; break; case LEDLAMP_FUELSEGMENT4:/* »º”Õ4∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT4=Value; break; case LEDLAMP_FUELSEGMENT3:/* »º”Õ3∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT3=Value; break; case LEDLAMP_FUELSEGMENT2:/* »º”Õ2∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT2=Value; break; case LEDLAMP_FUELSEGMENT1:/* »º”Õ1∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_FUELSEGMENT1=Value; break; case LEDLAMP_TEMPSEGMENT1:/* ÀÆŒ¬1∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT1=Value; break; case LEDLAMP_TEMPSEGMENT8:/* ÀÆŒ¬8∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT8=Value; break; case LEDLAMP_TEMPSEGMENT7:/*ÀÆŒ¬7∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT7=Value; break; case LEDLAMP_TEMPSEGMENT6:/* ÀÆŒ¬6∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT6=Value; break; case LEDLAMP_TEMPSEGMENT5:/* ÀÆŒ¬5∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT5=Value; break; case LEDLAMP_TEMPSEGMENT4:/* ÀÆŒ¬4∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT4=Value; break; case LEDLAMP_TEMPSEGMENT3:/* ÀÆŒ¬3∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT3=Value; break; case LEDLAMP_TEMPSEGMENT2:/* ÀÆŒ¬2∂Œµ∆∞◊ */ state->lrm_lamp.BYTES.LRM_TYPE_TEMPSEGMENT2=Value; break; case LEDLAMP_TEMP_WARN_RED: state->lrm_lamp.BYTES.LRM_TYPE_TEMP_WARN=Value;  case LEDLAMP_ASS_ACTIVE:/* SSBº§ªÓµ∆¬Ã */ state->lrm_lamp.BYTES.LRM_TYPE_SSB_ACTIVE=Value; break; case LEDLAMP_ASS_ERROR:/* ∆ÙÕ£π ’œµ∆ª∆*/ state->lrm_lamp.BYTES.LRM_TYPE_SSB_ERROR=Value; break; case LEDLAMP_ECOMODE:/* æ≠º√ƒ£ Ωµ∆¬Ã */ state->lrm_lamp.BYTES.LRM_TYPE_ECOMODE=Value; break; case LEDLAMP_SIDELIGHTS:/* Œª÷√µ∆¬Ã*/ state->lrm_lamp.BYTES.LRM_TYPE_SIDELIGHTS=Value; break; case LEDLAMP_FRONT_FOG:/* «∞ŒÌµ∆¬Ã */ state->lrm_lamp.BYTES.LRM_TYPE_FRONG_FOG=Value; break; case LEDLAMP_HDC_GREEN:/* ÀÆŒ¬±®æØµ∆∫Ï*/ state->lrm_lamp.BYTES.LRM_TYPE_HDC_GREEN=Value; break; case LEDLAMP_HDC_YELLOW: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Reserved Bits */ state->lrm_lamp.BYTES.LRM_TYPE_HDC_YELLOW=Value; break; case LEDLAMP_ALARM: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Reserved Bits */ state->lrm_lamp.BYTES.LRM_TYPE_THEFTPROOF=Value; break; case LEDLAMP_EPS_ERROR:/* EPSπ ’œµ∆∫Ï */ state->lrm_lamp.BYTES.LRM_TYPE_EPS_ERROR=Value; break; case LEDLAMP_EPS_WARN:/* EPSæØ∏Êµ∆ª∆ */ state->lrm_lamp.BYTES.LRM_TYPE_EPS_WARN=Value; break; case LEDLAMP_CHARGER:/*Ωª¡˜≥‰µÁµ∆∫Ï */ state->lrm_lamp.BYTES.LRM_TYPE_CHARGER=Value; break; case LEDLAMP_EMS_ERROR:/* ∑¢∂Øª˙π ’œµ∆ª∆*/ state->lrm_lamp.BYTES.LRM_TYPE_EMS_ERROR=Value; break; case LEDLAMP_EMISSION_ERROR:/* ≈≈∑≈π ’œµ∆ª∆ */ state->lrm_lamp.BYTES.LRM_TYPE_EMISSION_ERROR=Value; break; case LEDLAMP_FUELPRESURE_LOW:/* ª˙”Õ—π¡¶µÕµ∆∫Ï */ state->lrm_lamp.BYTES.LRM_TYPE_FUELPRESURE_LOW=Value; break; case LEDLAMP_TURNRIGHT:/*”“◊™œÚµ∆¬Ã */ state->lrm_lamp.BYTES.LRM_TYPE_TURNRIGHT=Value; break; case LEDLAMP_ASS:/*◊‘∆ÙÕ£±®æØµ∆ */ state->assLamp=Value; break;  default: res = FALSE; break; } } else { res = FALSE; }  return res; }  /************************************************** *Function :led_EventProcess *Description: process event from STSMG,only change led_state when differ with the newest state. *Parameters:none *Returns: TRUE:means there is a warn FALSE:means no warn exist  **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 ***************************************************/ static void led_EventProcess( void ) { U8 res = FALSE;  U8 group = 0; U8 pos = 0;  LedEventData_ST curEvent;  LED_EVENT_ENUM i,j, indtem = INDEX_LED_ALL;  LEDLamp_ENUM lampIndex = LEDLAMP_NONE;  LEDEventPriority_ENUM pri = PRIORITY_NONE;   res = STSMG_GetEventLed(&curEvent);  if (RET_OK == res) { /*CAN BE OPTIMIZE LATER*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr led_dataMask ∆¡±Œ¡À*/ for (i = INDEX_LED_NULL+1; i < INDEX_LED_ALL; i++) { group = j /STSMG_EVENT_FLAG_TYPE; pos = j - (group led.c led_cfg.h led_info.inc led_private.h led_public.h STSMG_EVENT_FLAG_TYPE); if (FALSE == GET_BIT(led_dataMask.FlagMap[group], pos))//led_dataMask.FlagMap; { CLR_BIT(curEvent.FlagMap[group], pos); } else { } }  /*NEW EVENT TRIGGER*/ if (0 != memcmp(&curEvent, &led_EventData,sizeof(LedEventData_ST))) { for (i = INDEX_LED_NULL+1; i < INDEX_LED_ALL; i++) { lampIndex = led_Matrix[i].index; //lampIndex = LEDLAMP_CRUISE_GREEN;  pri= led_Matrix[i].priority; indtem = INDEX_LED_ALL;  for(j = i; j < INDEX_LED_ALL; j++) { if (lampIndex ==led_Matrix[j].index) { group = j /STSMG_EVENT_FLAG_TYPE; pos = j - (group led.c led_cfg.h led_info.inc led_private.h led_public.h STSMG_EVENT_FLAG_TYPE); if (TRUE ==GET_BIT(curEvent.FlagMap[group], pos)) { if (led_Matrix[j].priority > pri) { pri= led_Matrix[j].priority; indtem = j; } else { if (INDEX_LED_ALL == indtem) { indtem = j; } else { } } } else { } } else { break; } }  i = j - 1; group = indtem /STSMG_EVENT_FLAG_TYPE; pos = indtem - (group led.c led_cfg.h led_info.inc led_private.h led_public.h STSMG_EVENT_FLAG_TYPE); if (TRUE ==GET_BIT(curEvent.FlagMap[group], pos)) { switch (lampIndex)  {  case LEDLAMP_EPS_ERROR:  led_SetLampStatus(&led_State,lampIndex,TRUE);  led_data[lampIndex].prm = led_Matrix[indtem].data;  if (0xffff ==led_data[lampIndex].prm.Duration)  { led_data[lampIndex].TotalCnt =0xffff; } else  { led_data[lampIndex].TotalCnt = ((led_data[lampIndex].prm.Duration) /(led_counter[led_data[lampIndex].prm.Frequency]*REVERSE_FACTOR))/2; }  if (0 !=led_data[lampIndex].TotalCnt)  { led_data[lampIndex].done = FALSE;  }  else { led_data[lampIndex].Level = led_GetLampDataByIndex(&led_State,lampIndex); } break;  case LEDLAMP_EPS_WARN: if (FALSE ==led_data[LEDLAMP_EPS_ERROR].done) { led_SetLampStatus(&led_State,LEDLAMP_EPS_WARN,FALSE); led_data[LEDLAMP_EPS_WARN].Level = led_GetLampDataByIndex(&led_State,LEDLAMP_EPS_WARN); led_data[LEDLAMP_EPS_WARN].done =TRUE; break; }  if (TRUE ==led_data[LEDLAMP_EPS_ERROR].Level) { led_SetLampStatus(&led_State,LEDLAMP_EPS_WARN,FALSE); led_data[LEDLAMP_EPS_WARN].Level = led_GetLampDataByIndex(&led_State,LEDLAMP_EPS_WARN); led_data[LEDLAMP_EPS_WARN].done =TRUE; break; }  led_SetLampStatus(&led_State,lampIndex,TRUE); led_data[lampIndex].prm = led_Matrix[indtem].data;  if (0xffff ==led_data[lampIndex].prm.Duration)  { led_data[lampIndex].TotalCnt =0xffff; } else  { led_data[lampIndex].TotalCnt = ((led_data[lampIndex].prm.Duration) /(led_counter[led_data[lampIndex].prm.Frequency]*REVERSE_FACTOR))/2; }  if (0 !=led_data[lampIndex].TotalCnt)  { led_data[lampIndex].done = FALSE; //led_SetLampStatus(&led_State,LEDLAMP_EPS_WARN,FALSE); }  else { led_data[lampIndex].Level = led_GetLampDataByIndex(&led_State,lampIndex); }  break;  default: if (TRUE ==GET_BIT(led_EventData.FlagMap[group], pos)) { break; } else { }  led_SetLampStatus(&led_State,lampIndex,TRUE); led_data[lampIndex].prm = led_Matrix[indtem].data;  /*LYY ADD DURATION VIA CFG KEY*/ switch (indtem)  { case INDEX_LED_TPMS_FAULT_FLASH: led_data[lampIndex].prm.Duration = S_TO_MS(DIAG_GetTPMSLampFlaPeriod()); break;  case INDEX_LED_BRAKE_HANDON_FLASH: led_data[lampIndex].prm.Duration = S_TO_MS(DIAG_GetBrakeSysRemPeriod()); break; }  if (0xffff ==led_data[lampIndex].prm.Duration) { led_data[lampIndex].TotalCnt =0xffff; } else  { led_data[lampIndex].TotalCnt = ((led_data[lampIndex].prm.Duration) /(led_counter[led_data[lampIndex].prm.Frequency]*REVERSE_FACTOR))/2; }  if (0 !=led_data[lampIndex].TotalCnt)  { led_data[lampIndex].done = FALSE; }  else { led_data[lampIndex].Level = led_GetLampDataByIndex(&led_State,lampIndex); } break; }  } else { led_SetLampStatus(&led_State,lampIndex,FALSE);  led_data[lampIndex].Level = led_GetLampDataByIndex(&led_State,lampIndex); led_data[lampIndex].done = TRUE; }  }/*end for*/  /*disable those leds which is not used in this project*/ for(i = LEDLAMP_NONE +1; i < LEDLAMP_ALL; i ++) { if (FALSE == led_GetLampDataByIndex(&led_Enable, i)) { led_SetLampStatus(&led_State, i, FALSE); } else { } }  led_EventData = curEvent; /////BREAK POINTER5 }/*end if*/ else { } } else { } }  static void led_UpdateFuelLampProcess(void) { BOOL enable = FALSE; U8 lampIndex = 0; U8 i = 0; static U8 seg = LEVEL_LED_ALL; U8 led_fuelSeg; U8 res = RET_FAIL;  U8 curMode;  PWR_GetPwrMode(&curMode); if( (PWR_ACC == curMode) || (PWR_OFF == curMode) ) { led_fuelSeg = LEVEL_LED_ALL; } else { res = WFM_GetFuelSegmentNum(&led_fuelSeg); }  //res = WFM_GetFuelSegmentNum(&led_fuelSeg); if (seg !=led_fuelSeg)  { seg =led_fuelSeg;  /*LAMP DATA UPDATE*/ for (i = LEVEL_LED_SEGNONE; i < LEVEL_LED_ALL; i++) { if (LEVEL_LED_ALL ==led_fuelSeg)  { enable = FALSE; } else { enable = ((i <= led_fuelSeg) ? TRUE : FALSE); }  lampIndex = led_GetLampIndex(TYPE_LED_FUEL, i); led_SetLampStatus(&led_State, lampIndex, enable); led_data[lampIndex].Level = led_GetLampDataByIndex(&led_State,lampIndex);  } } else { } }  static void led_UpdateTemLampProcess(void) { BOOL enable = FALSE; U8 lampIndex = 0; U8 i = 0; static U8 wseg = LEVEL_LED_ALL; U8 led_TmptSeg; U8 res = RET_FAIL;  U8 curMode;  PWR_GetPwrMode(&curMode); if( (PWR_ACC == curMode) || (PWR_OFF == curMode) ) { led_TmptSeg = LEVEL_LED_ALL; } else { res = WFM_GetCoolantSegmentNum(&led_TmptSeg); }  //res = WFM_GetCoolantSegmentNum(&led_TmptSeg); /*LAMP DATA UPDATE*/ if (wseg !=led_TmptSeg)  { wseg =led_TmptSeg;  for (i = LEVEL_LED_SEGNONE; i < LEVEL_LED_ALL; i++) { if (LEVEL_LED_ALL ==led_TmptSeg)  { enable = FALSE; } else { enable = ((led_TmptSeg < i) ? FALSE : TRUE); }  lampIndex = led_GetLampIndex(TYPE_LED_TEMP, i); if (( LEDLAMP_TEMPSEGMENT1 <= lampIndex) && (LEDLAMP_TEMPSEGMENT2 >= lampIndex)) { led_SetLampStatus(&led_State, lampIndex, enable); led_data[lampIndex].Level = led_GetLampDataByIndex(&led_State,lampIndex); } else { } }/*end for*/ } else { /*do nothing*/ } }   /************************************************** *Function :led_LampUpdateProcess *Description: Get Water Temperature warn type *Parameters:none *Returns: NONE  **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 ***************************************************/ static void led_LampUpdateProcess(void) { led_EventProcess(); led_UpdateFuelLampProcess(); led_UpdateTemLampProcess();  } /************************************************** *Function :led_LampUpdateProcess *Description: Get Water Temperature warn type *Parameters:none *Returns: NONE  **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 ***************************************************/ static void led_OutPutProcess(void) { U8 i, j;  U8 curMode; PWR_GetPwrMode(&curMode);   /*********************************************** LED state : ON OFF ? ? FALSE == flash ? ,led_out ????????? ************************************************/ for (i =FREQUENCY_LED_NONE+1; i< FREQUENCY_LED_ALL; i++) { if (0 ==led_count[i]--) { led_count[i] =led_counter[i]-1; led_flash[i] =(!led_flash[i]);  for (j = LEDLAMP_NONE +1; j < LEDLAMP_ALL; j++)  { if (i ==led_data[j].prm.Frequency) { if (FALSE ==led_data[j].done)  { led_data[j].Level= led_flash[i];  if ((LEDLAMP_FUEL_WARN == j) && (FALSE == NWD_GetBusOffFlt())) { if((STATE_CYCLE_NEXT != WFM_GetFuelSensorCycle()) &&((PWR_RUN == curMode) ||(PWR_CRANK== curMode))) { led_data[LEDLAMP_FUELSEGMENT1].Level= led_data[j].Level; } else { } }  else { }  /************************************* do flash event update, eg.reverse  *************************************/ if (TRUE == led_data[j].Level) { if (0 == led_data[j].TotalCnt) { led_data[j].done = TRUE; if (LEDLAMP_ASS_ACTIVE ==j) { STSMG_GetStopStartEventLed(&led_data[j].Level); } else { } } else {  if (0xffff !=led_data[j].TotalCnt)  { led_data[j].TotalCnt--; } else { } } } else { } } else { if (LEDLAMP_ASS_ACTIVE ==j) { STSMG_GetStopStartEventLed(&led_data[j].Level); } else { } }  } else {  }  }  } else { } }   /*update output level*/ for (i = LEDLAMP_NONE+1; i < LEDLAMP_ALL; i++) { led_SetLampStatus(&led_out, i, led_data[i].Level); }  }   /************************************************** *Function :LED_GetLevel *Description: Get LED work status *Parameters:none *Returns: TRUE:means LED is in IDLE state FALSE:means LED is busy  **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 ***************************************************/ BOOL LED_GetLevel(void) {  if (0 <led_data[LEDLAMP_SEATBELT_UNFASTEN].Level) { return (TRUE); } else { return (FALSE); } }  BOOL LED_Get_Brake_Level(void) {  if (0 <led_data[LEDLAMP_BRAKEERROR].Level) { return (TRUE); } else { return (FALSE); } }     /************************************************** *Function :LED_GetEventResult *Description: Get LED work status *Parameters:none *Returns: TRUE:means LED is in IDLE state FALSE:means LED is busy  **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 ***************************************************/ BOOL LED_GetEventResult(LED_EVENT_ENUM index) { LEDLamp_ENUM lampIndex=LEDLAMP_NONE;  lampIndex =led_Matrix[index].index;  return led_data[lampIndex].done; } /************************************************** *Function :LED_GetLampStatus *Description: Provide interface for LRM,to get all lamp status. *Parameters: value:output ,all lrm light status size:input, lrm value size *Returns: TRUE:means there is no wrong accour FALSE:means nthere is something wrong accour **create&Verlog: *Author Name liuyingying Date:2016-11-25 Ver:01 ***************************************************/ U8 LED_GetLampStatus(LRMState_UN *value, U8 size) { U8 i,res = FALSE; if((NULL_PTR == value) || (size != (sizeof(led_out.lrm_lamp)))) { res = FALSE; } else { //for( i = 0; i < 6; i++) // led_out.lrm_lamp.LRM_value[i] = 0xff; *value = led_out.lrm_lamp; res =TRUE; } return res; }    /*=========================================================================================================== led.c led_cfg.h led_info.inc led_private.h led_public.h File Revision History (bottom to top:first revision to last revision) * *============================================================================================================ *$Log:$ *  *Rev: Userid: date: description *----- ----- ----------- ----------- *Rev 1 liuyingying 2016-11-25 initial ============================================================================================================*/
