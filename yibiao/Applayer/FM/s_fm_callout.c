/***************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr All Rights Reserved */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Automatically generated file */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /***************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ECU name: IPK */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ECU version: 1.03 */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ECU manufacturer: SAIC */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ECU description: */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ECU hardware: Freescale MPC560X */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Software compiler: Freescale CodeWarrior 2.10 */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /***************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Module name: DTC Manager */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Module version: v1.00 */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr File: s_fm_callout.c */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Date: 2017/7/18 16:22:43 */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr File description: This file contains callout functions. */ /***************************************************************/   #include "s_fm_typedef.h" #include "yd_typedefs.h" #include "sys_public.h" #include "s_fm_app.h" #include "ftr_public.h"  s_uint8 f_fm_cyclecheck( s_uint8 cycle_type) { s_uint8 ret = 0u; static BOOL WorkSts = 0; BOOL curSts = 0; U8 res,mode; static U8 pwrMode = PWR_OFF;  curSts = SYS_GetNormalWorkMode(); res = PWR_GetPwrMode(&mode); switch(cycle_type) { case WAKEUP_CYCLE: {  if((FALSE == curSts) && (FALSE == WorkSts)) { ret = NOT_IN_CYCLE; }  if((FALSE == curSts) && (TRUE == WorkSts)) { ret = CYCLE_END; } if((TRUE == curSts) && (FALSE == WorkSts)) { ret = CYCLE_START; } if((TRUE == curSts) && (TRUE == WorkSts)) { ret = CYCLING; } break; } case IG_CYCLE: { if(( (PWR_OFF == mode)||(PWR_ACC == mode)) && ((PWR_OFF == pwrMode) ||(PWR_ACC == pwrMode) )) { ret = NOT_IN_CYCLE; } else if(( (PWR_RUN== mode)||(PWR_CRANK== mode)) && ((PWR_OFF == pwrMode) ||(PWR_ACC == pwrMode) )) { ret = CYCLE_START; }  else if(( (PWR_RUN== mode)||(PWR_CRANK== mode)) && ((PWR_RUN == pwrMode) ||(PWR_CRANK == pwrMode) )) { ret = CYCLING; }  else if(( (PWR_OFF== mode)||(PWR_ACC== mode)) && ((PWR_RUN == pwrMode) ||(PWR_CRANK == pwrMode) )) { ret = CYCLE_END; } else { ret = NOT_IN_CYCLE; } break; } default: { ret = NOT_IN_CYCLE; break; } }  WorkSts = curSts; pwrMode = mode; return ret; }  void f_fm_writeDTC( s_uint16 i,  s_uint8 lib s_fm_api.h s_fm_app.h s_fm_callout.c s_fm_config.c s_fm_config.h s_fm_typeDef.h data,  s_uint8 len) { NVM_SetParas(wr_dtchanlde_table[i],data,len); }  void f_fm_writeFirstSnapshot( s_uint16 i,  s_uint8 lib s_fm_api.h s_fm_app.h s_fm_callout.c s_fm_config.c s_fm_config.h s_fm_typeDef.h data,  s_uint8 len) { NVM_SetParas(wr_snapshothandle_table[i],data,len); }  void f_fm_writeLastSnapshot( s_uint16 i,  s_uint8 lib s_fm_api.h s_fm_app.h s_fm_callout.c s_fm_config.c s_fm_config.h s_fm_typeDef.h data,  s_uint8 len) { NVM_SetParas(wr_snapshothandle_table[i],data,len); }  void f_fm_readDTCFromEEPROM( s_uint16 i,  s_uint8 lib s_fm_api.h s_fm_app.h s_fm_callout.c s_fm_config.c s_fm_config.h s_fm_typeDef.h data,  s_uint8 len) { NVM_GetParas(rd_dtchandle_table[i],data,len); }  void f_fm_readFirstSnapshotFromEEPROM( s_uint16 i,  s_uint8 lib s_fm_api.h s_fm_app.h s_fm_callout.c s_fm_config.c s_fm_config.h s_fm_typeDef.h data,  s_uint8 len) { NVM_GetParas(rd_snapshothandle_table[i],data,len); }  void f_fm_readLastSnapshotFromEEPROM( s_uint16 i,  s_uint8 lib s_fm_api.h s_fm_app.h s_fm_callout.c s_fm_config.c s_fm_config.h s_fm_typeDef.h data,  s_uint8 len) { NVM_GetParas(rd_snapshothandle_table[i],data,len); }  void f_fm_readDID( s_uint16 DID,  s_uint8 lib s_fm_api.h s_fm_app.h s_fm_callout.c s_fm_config.c s_fm_config.h s_fm_typeDef.h data,  s_uint8 len) { U16 value = 0; U32 value32 = 0; U8 value8; PU8 p = NULL; PTime_ST time; switch(DID) { case 0x0112u: { if(1 == len) { if( RET_OK == BAT_GetBatValue(&value)) { *data = (U8)((((value -978)/20.13) + 60)); } else { /*do nothing*/ } } else { /*do nothing*/ #if LYY_DEBUG_WHILE1 while(1) { } #endif } break; } case 0xE101u: { if( 3 == len) { if (RET_OK == ODO_GetODOValue(INDEX_ODO_METER,&value32)) { value32 = (value32/1000); *(data +2) = (value32&0xff);  *(data +1) = ((value32&0xff00)>>8);  *(data +0) = ((value32&0xff0000)>>16); } else { /*do nothing*/ } } else { /*do nothing*/ #if LYY_DEBUG_WHILE1 while(1) { } #endif } break; } case 0xD001u: { if( 1 == len) { *(data +0) = PWR_Get_D001_Value(); } else { /*do nothing*/ #if LYY_DEBUG_WHILE1 while(1) { } #endif  } break; } case 0x010Bu: { if( 6 == len) { if (RET_OK == RTC_GetCurTime(&time)) { *(data +0) = (time.year);  *(data +1) = (time.month);  *(data +2) = (time.day);  *(data +3) = (time.hour);  *(data +4) = (time.minute);  *(data +5) = (time.sec);  } else { /*do nothing*/ } } else { /*do nothing*/ #if LYY_DEBUG_WHILE1 while(1) { } #endif }  break; } case 0x010Cu://coolant temprature { if( 1 == len) { if(RET_OK == WFM_GetCoolantTemp(&value8)) { *(data +0) = (U8)(value8 + 40);  } else { /*do nothing*/ } } else { /*do nothing*/ #if LYY_DEBUG_WHILE1 while(1) { } #endif } break; } case 0x0100u: { //p=FTR_GetDID_0100(16); NVM_GetParas(INDEX_NVM_0100,data,16); // memcpy(data,p,16);; break; } default: { break; } } }  void f_fm_sendDTCTrigger( s_uint8 lib s_fm_api.h s_fm_app.h s_fm_callout.c s_fm_config.c s_fm_config.h s_fm_typeDef.h data,  s_uint8 len) { __DI(); v_wr_bytes(DTCInfomationIPK_handle,data,len,0); __EI(); }  s_bool f_fm_getTriggerCANbusStatus(void) { s_bool ret = 1u;  ret = 1-NWD_GetBusOffFlt();  return ret; }
