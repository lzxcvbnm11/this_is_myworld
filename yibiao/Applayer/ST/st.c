/***************************************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Copyright (C) 2016 ShenZhen Yeedon Media co.,LTD. All rights reserved. * st.c st_cfg.h st_info.inc st_private.h st_public.h File Name : st.c st.c st_cfg.h st_info.inc st_private.h st_public.h Description :st module api. st.c st_cfg.h st_info.inc st_private.h st_public.h Author: Xueping.Chen st.c st_cfg.h st_info.inc st_private.h st_public.h Date: 2016-12-06 ******************************************************************************/ #include "st_info.inc"  static U8 st_GCounter = 0; /*自检和周期调用计数*/ static MOMWorkStatus_ENUM st_WrkMode[METER_ALL]; /*马达工作状态*/ static U16 st_NetRVehSpdAvgDrvn = 0; /*用于存储从CAN 获取RVehSpdAvgDrvn*/  static U8 st_NetRVehSpdAvgDrvnV = VALID; /*用于存储从CAN 获取RVehSpdAvgDrvnV*/  static U16 st_NetSClstrDspdVehSpd = 0; /*用于存储从CAN 获取SClstrDspdVehSpd*/  static U32 st_AverageSpeed1 = 0; /*平均速度1*/ static U32 st_AverageSpeed2 = 0; /*平均速度2*/ static BOOL st_InitSts = FALSE; /*初始化*/ static U8 AngleOffset = 0; /*小调零的角度*/ static U32 curAngleSpdValue = 0;  static U8 insEngRunTimePrm; static S32 insSpeedoAdjustConstantPrm; static U8 EngineRunningFlagHysteresis = 0x00; static U8 EngineMaxCnt = 0; static U8 EngineCurCnt = 0; static BOOL EngineRunningFlag = FALSE;  /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: ST_Init st.c st_cfg.h st_info.inc st_private.h st_public.h Description: the initializing of the st module st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters: none st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: none st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Author:Xueping.Chen Date:2016-12-06 Version:V1.0 ****************************************************/ void ST_Init(void) { U8 res = RET_FAIL; st_GCounter = 0; st_WrkMode[METER_SPEED] = MOTOR_TOZERO; st_WrkMode[METER_TACHO] = MOTOR_TOZERO; st_NetRVehSpdAvgDrvn = 0; st_NetRVehSpdAvgDrvnV = VALID; st_NetSClstrDspdVehSpd = 0; st_AverageSpeed1 = 0; st_AverageSpeed2 = 0; AngleOffset = 0; st_InitSts = MOM_GetInitSts(); /*配置字的读取*/ res = NVM_GetParas(INDEX_NVM_Y_ANGLEOFFSET, &AngleOffset, 1);  insEngRunTimePrm = DIAG_GetEngRunTime();  EngineMaxCnt =S_TO_MS(insEngRunTimePrm)/ST_PROCESS_PERIOD; EngineCurCnt = 0;  insSpeedoAdjustConstantPrm = DIAG_GetSpeedoAdjustConstant(); EngineRunningFlagHysteresis = DIAG_GetEngineRunningFlagHysteresis();  curAngleSpdValue = 0; }  /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: ST_Process_50ms st.c st_cfg.h st_info.inc st_private.h st_public.h Description: the process of the st module st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters: none st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: none st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Author:Xueping.Chen Date:2016-12-06 Version:V1.0 ****************************************************/ void ST_Process_50ms(void) { U8 rstsource; U8 chksts = 0; U8 res = RET_FAIL; BOOL busOffFlt = FALSE; U8 batSts = 0;  U8 mode = 0; static U8 st_pwrMode = PWR_OFF;  if(TRUE == st_InitSts) { BAT_GetBatFltSts(TYPE_BATDET_TD,&batSts); if(FLT_BAT_NO == batSts) { if (RET_OK == PWR_GetPwrMode(&mode)) { if ((PWR_OFF == mode ||PWR_ACC == mode) && (PWR_RUN== st_pwrMode ||PWR_CRANK== st_pwrMode)) {  st_WrkMode[METER_SPEED] = MOTOR_TOZERO; st_WrkMode[METER_TACHO] = MOTOR_TOZERO; st_GCounter = 0; MOM_SetWorkMode(MOTOR_TOZERO); } else { if ( (MOTOR_TOZERO == st_WrkMode[METER_SPEED]) && (MOTOR_TOZERO == st_WrkMode[METER_TACHO]) ) { /*if do zero protect wait for MOM Status change to IDLE*/ st_Zero_Process();  } else { } } st_pwrMode = mode;  if ( ((PWR_RUN == mode) || (PWR_CRANK== mode)) && (MOTOR_SELF_CHECKING == st_WrkMode[METER_SPEED]) && (MOTOR_SELF_CHECKING == st_WrkMode[METER_TACHO]) ) { st_Check_Process(); } else { }  if (((PWR_RUN == mode) || (PWR_CRANK== mode)) && (MOTOR_NORMAL == st_WrkMode[METER_SPEED]) && (MOTOR_NORMAL == st_WrkMode[METER_TACHO])) { busOffFlt = NWD_GetBusOffFlt(); if(TRUE == busOffFlt) { MOM_SetStep(METER_SPEED, DIR_LEFT, 0); MOM_SetStep(METER_TACHO, DIR_LEFT, 0); } else { st_Normal_Process(); } } else { } } else { } } else { MOM_SetStep(METER_SPEED, DIR_LEFT, 0); MOM_SetStep(METER_TACHO, DIR_LEFT, 0); } } else { } }  /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: st_Zero_Process st.c st_cfg.h st_info.inc st_private.h st_public.h Description: the process of zero setting by the st st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters: none st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: none st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Author:Xueping.Chen Date:2016-12-06 Version:V1.0 ****************************************************/ static void st_Zero_Process(void) {  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr wait for MOM Status change to IDLE ,then change mode to selfchek*/ #if 1 if(TRUE == MOM_GetZpdDone()) { st_WrkMode[METER_SPEED] = MOTOR_SELF_CHECKING; st_WrkMode[METER_TACHO] = MOTOR_SELF_CHECKING; MOM_SetWorkMode(MOTOR_SELF_CHECKING); } else { /*do nothing*/ } #else if((TRUE == MOM_IsReachedDesAngle(METER_SPEED)) && (TRUE == MOM_IsReachedDesAngle(METER_TACHO))) { st_WrkMode[METER_SPEED] = MOTOR_SELF_CHECKING; st_WrkMode[METER_TACHO] = MOTOR_SELF_CHECKING; MOM_SetWorkMode(MOTOR_SELF_CHECKING); } else { /*do nothing*/ } #endif  }  /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: st_Normal_Process st.c st_cfg.h st_info.inc st_private.h st_public.h Description: the normal process of the st st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters: none st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: none st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Author:Xueping.Chen Date:2016-12-06 Version:V1.0 ****************************************************/ static void st_Normal_Process(void) { U32 time1 = 0; U32 time2 = 0; U32 odovalue1 = 0; U32 odovalue2 = 0; static U32 time1_bak = 0; static U32 time2_bak = 0;  st_TachoProcess_50ms(); st_GCounter++;  if(st_GCounter%2) {  st_SpeedProcess_100ms(); st_CalCurSpeedMotorAngle(); } else { }  if (PROCESS_SIGNAL_CNT <= st_GCounter) { st_GCounter = 0; RTC_GetDrivenTime(E_DRIVEN_TIME1, &time1);  if (0 != time1) { if(time1_bak != time1) { ODO_GetODOValue(INDEX_ODO_TRIP1, &odovalue1); st_AverageSpeed1= (odovalue1*36)/ time1; } else { } } else { st_AverageSpeed1 = 0; } time1_bak = time1;  RTC_GetDrivenTime(E_DRIVEN_TIME2, &time2); if (0 != time2) { if(time2_bak != time2) { ODO_GetODOValue(INDEX_ODO_TRIP2, &odovalue2); st_AverageSpeed2 = (odovalue2*36) / time2; } else { } } else { st_AverageSpeed2 = 0; }  time2_bak = time2; } else { } }  /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: st_Check_Process st.c st_cfg.h st_info.inc st_private.h st_public.h Description: the checking process of the st st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters: none st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: none st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Author:Xueping.Chen Date:2016-12-06 Version:V1.0 ****************************************************/  //extern void AddSelfCheckOffset(void); static void st_Check_Process(void) { #if 0 static U8 step = 0; U8 res = 0; U8 chkstatus = 0; static U8 st_ChkSts = 0;   st_GCounter++; if (CHECK_DELAY_CNT == st_GCounter ) { MOM_SetStep(METER_SPEED, DIR_LEFT,ANGLE_MIN); MOM_SetStep(METER_TACHO,DIR_LEFT,ANGLE_MIN); step = 1; } else if ((CHECK_DELAY_CNT + CHECK_TRANSIT_CNT ) == st_GCounter ) { MOM_SetStep(METER_SPEED, DIR_RIGHT, ANGLE_MAX*METER_PRECISION_FACTOR3);  MOM_SetStep(METER_TACHO, DIR_RIGHT, ANGLE_MAX*METER_PRECISION_FACTOR3); step = 2;  } else if(step == 2){ if((TRUE == MOM_IsReachedDesAngle(METER_SPEED)) && (TRUE == MOM_IsReachedDesAngle(METER_TACHO))){ step = 3; } }else if(step == 3){ MOM_SetStep(METER_SPEED, DIR_LEFT,ANGLE_MIN); MOM_SetStep(METER_TACHO,DIR_LEFT,ANGLE_MIN); step = 4; }else if(step == 4){ if((TRUE == MOM_IsReachedDesAngle(METER_SPEED)) && (TRUE == MOM_IsReachedDesAngle(METER_TACHO))){ st_WrkMode[METER_SPEED] = MOTOR_NORMAL; st_WrkMode[METER_TACHO] = MOTOR_NORMAL; step = 0; MOM_SetWorkMode(MOTOR_NORMAL); } }  #else   static U8 step = 0; U8 res = 0; U8 chkstatus = 0; static U8 st_ChkSts = 0;   st_GCounter++; if (CHECK_DELAY_CNT >= st_GCounter ) { step = 1; } else if ((CHECK_DELAY_CNT + CHECK_TRANSIT_CNT - 20) >= st_GCounter ) { if(step == 1) { step = 2; } else  { step = 3; } } else if ((CHECK_DELAY_CNT + CHECK_TRANSIT_CNT + CHECK_REMAIN_WAIT_CNT) >= st_GCounter ) { step = 3; } else if ((CHECK_DELAY_CNT + CHECK_TRANSIT_CNT + CHECK_REMAIN_WAIT_CNT +  CHECK_TRANSIT_CNT +10) >= st_GCounter) { step = 4; } else if(CHECK_MAX_CNT >= st_GCounter ) { step = 5; } else { step = 6; }  switch(step) { case 1:  MOM_SetStep(METER_SPEED, DIR_LEFT,ANGLE_MIN); MOM_SetStep(METER_TACHO,DIR_LEFT,ANGLE_MIN);  break; case 2: case 3:  MOM_SetStep(METER_SPEED, DIR_RIGHT, (ANGLE_MAX)*METER_PRECISION_FACTOR3);  MOM_SetStep(METER_TACHO, DIR_RIGHT, (ANGLE_MAX)*METER_PRECISION_FACTOR3); if(step == 2){ ;//AddSelfCheckOffset(); } break; case 4:  MOM_SetStep(METER_SPEED, DIR_LEFT,ANGLE_MIN); MOM_SetStep(METER_TACHO,DIR_LEFT,ANGLE_MIN);   break; default:  if((TRUE == MOM_IsReachedDesAngle(METER_SPEED)) && (TRUE == MOM_IsReachedDesAngle(METER_TACHO))) { st_WrkMode[METER_SPEED] = MOTOR_NORMAL; st_WrkMode[METER_TACHO] = MOTOR_NORMAL; step = 0; MOM_SetWorkMode(MOTOR_NORMAL); } else { }   break; }  #endif }  static void st_CalCurSpeedMotorAngle(void) {  U8 range = 0; U32 angle = 0;  U32 spd = 0; U16 offset = 0;  MOM_GetCurAngle(METER_SPEED,&angle);  //printf("MOM_GetCurAngle =%d\n",angle);  if(angle <= (45*12)) { range = 0; spd = 3703 *angle ; } else { range = 1; spd = ((angle -(45*12))*7407)+2000000; } spd +=50000; spd = (spd/100000); offset = 100;//(100 + (insSpeedoAdjustConstantPrm/10)); if (220 < (U32)((spd st.c st_cfg.h st_info.inc st_private.h st_public.h offset) / 100)) { curAngleSpdValue= 220; } else { curAngleSpdValue = (U32)((spd st.c st_cfg.h st_info.inc st_private.h st_public.h offset) / 100);/*need to add calculate*/ }  }  U32 ST_GetCurAngleSpeed(void) { return curAngleSpdValue; } /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: st_SpeedProcess_100ms st.c st_cfg.h st_info.inc st_private.h st_public.h Description: the process of the speed st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters: none st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: none st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Author:Xueping.Chen Date:2016-12-06 Version:V1.0 ****************************************************/ static void st_SpeedProcess_100ms(void) { U32 curSpeed = 0; U8 range = 0; S8 dir; U16 step = 0; U8 Valid = INVALID; static U8 spCnt = 0; U8 scsNodemissing = FALSE; U32 DestSpd = 0;  COM_GetSignalValue_8(INDEX_COM_RS_VEHSPDAVGDRVNV, &Valid); COM_GetSignalValue_16(INDEX_COM_RS_VEHSPDAVGDRVN, &st_NetRVehSpdAvgDrvn); NWD_GetNodeMissing(INDEX_SCS_NODE,&scsNodemissing); if(TRUE == scsNodemissing) { Valid = INVALID; st_NetRVehSpdAvgDrvn = 0; } else { }   if(Valid != st_NetRVehSpdAvgDrvnV) { spCnt = 0; } else { }  if(spCnt <5 ) { spCnt ++; } else { } st_NetRVehSpdAvgDrvnV = Valid;  if (VALID == st_NetRVehSpdAvgDrvnV) { if(spCnt <5 ) { return ; } else { }   DestSpd = (U16)((st_NetRVehSpdAvgDrvn st.c st_cfg.h st_info.inc st_private.h st_public.h (1000 +insSpeedoAdjustConstantPrm))/1000);  if (DestSpd >= 220) { DestSpd = 220; } else { }  st_NetSClstrDspdVehSpd = DestSpd; curSpeed = (U32)(DestSpd st.c st_cfg.h st_info.inc st_private.h st_public.h KILOMETER_TO_CMETER);  if (curSpeed <= SPEED_DIVISION) { range = 0; step = ABS_SUB(curSpeed, 0) / st_Speed[st_meterMode][range].Precision; } else { range = 1; step = (ABS_SUB(curSpeed, SPEED_DIVISION) / st_Speed[st_meterMode][range].Precision)+ANGLE_SPEED_RANGE*METER_PRECISION_FACTOR3; } MOM_SetStep(METER_SPEED, DIR_LEFT, step); //printf("MOM_SetStep =%d\n",step); } else { if(spCnt >=5 ) { MOM_SetStep(METER_SPEED, DIR_LEFT, 0); st_NetSClstrDspdVehSpd = 0; } else { } } }  /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: ST_SendNetSignal_50ms st.c st_cfg.h st_info.inc st_private.h st_public.h Description: send the net signal of the st module st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters: none st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: none st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Author:Xueping.Chen Date:2016-12-06 Version:V1.0 ****************************************************/ void ST_SendNetSignal_50ms(void) { U32 angle_OdoPriy;  angle_OdoPriy = (((curAngleSpdValue & 0x0000ff) << 16) | (curAngleSpdValue & 0x00ff00) | ((curAngleSpdValue & 0xff0000) >> 16));  v_wr_bytes(SIAOdoPriy_handle, &angle_OdoPriy, 3, 0);  #if 0 st_NetSClstrDspdVehSpd = (U16)((st_NetRVehSpdAvgDrvn st.c st_cfg.h st_info.inc st_private.h st_public.h (100 +(insSpeedoAdjustConstantPrm/10)))/100); #endif v_wr_8(ClstrDspdVehSpd_handle, st_NetSClstrDspdVehSpd); }  /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: st_TachoProcess_50ms st.c st_cfg.h st_info.inc st_private.h st_public.h Description: the process of tacho st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters: none st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: none st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Version:V1.0 Author:Xueping.Chen Date:2016-12-06   st.c st_cfg.h st_info.inc st_private.h st_public.h Version:V1.1 Author:liuyingying Date:2017-04-05  st.c st_cfg.h st_info.inc st_private.h st_public.h $log:modify st_netREnSpdSts as static  ****************************************************/ static void st_TachoProcess_50ms(void) { U32 curTacho = 0; S8 dir; U16 step; U8 spdSts; U8 ecmNodeMissing = FALSE; static U8 spdCnt = 0; U16 st_NetREnSpd = 0; static U8 st_netREnSpdSts = 0;  COM_GetSignalValue_16(INDEX_COM_RS_ENSPD, &st_NetREnSpd); COM_GetSignalValue_8(INDEX_COM_RS_ENSPDSTS, &spdSts);  NWD_GetNodeMissing(INDEX_ECM_NODE,&ecmNodeMissing); if(TRUE == ecmNodeMissing) { st_NetREnSpd = 0; spdSts = 3; } else { }  if(spdSts != st_netREnSpdSts) { spdCnt = 0; } else { }  st_netREnSpdSts = spdSts;  if(spdCnt < 2) { spdCnt ++; } else { }  if(st_netREnSpdSts != 3) { if(spdCnt <2) { return; } else { }  curTacho = st_NetREnSpd*100; if (curTacho >= TACHO_MAX_VAULE ) { curTacho = TACHO_MAX_VAULE; } else { }  if(FALSE == EngineRunningFlag) { if(TACHO_ENGINERUNNING_THREASHOLD < st_NetREnSpd) { EngineCurCnt ++; if(EngineMaxCnt <= EngineCurCnt) { EngineRunningFlag = TRUE; EngineCurCnt = 0; } else { } } else { EngineCurCnt = 0; } } else { if((TACHO_ENGINERUNNING_THREASHOLD - EngineRunningFlagHysteresis) > st_NetREnSpd) {  EngineRunningFlag = FALSE; EngineCurCnt = 0;  } else { EngineCurCnt = 0; } } step = (U16)(ABS_SUB(curTacho, 0) / st_Tacho[st_meterMode].Precision); dir = DIR_LEFT; MOM_SetStep(METER_TACHO, dir, step); } else { if(spdCnt >= 2) { st_netREnSpdSts = 0; MOM_SetStep(METER_TACHO, DIR_LEFT, 0); } else { } } }   /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: ST_GetDisplaySpeed st.c st_cfg.h st_info.inc st_private.h st_public.h Description: get the value of the speed st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters: output  speed : the value of the speed st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: RET_FAIL RET_INVALID RET_OK st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Author:Xueping.Chen Date:2016-12-06 Version:V1.0 ****************************************************/ U8 ST_GetDisplaySpeed(PU32 speed) { U8 res = RET_FAIL; U8 offset = 0;  if (FALSE == st_InitSts) { res = RET_FAIL; } else if (NULL_PTR == speed) { res = RET_INVALID; } else { if(INVALID == st_NetRVehSpdAvgDrvnV) { *speed = 0; } else { offset = (100 + (insSpeedoAdjustConstantPrm/10)); if (220 < (U32)((st_NetRVehSpdAvgDrvn st.c st_cfg.h st_info.inc st_private.h st_public.h offset) / 100)) { *speed = 220; } else { *speed = (U32)((st_NetRVehSpdAvgDrvn st.c st_cfg.h st_info.inc st_private.h st_public.h offset) / 100);/*need to add calculate*/ } } res = RET_OK; } return res; }  /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: ST_GetAverageSpeed st.c st_cfg.h st_info.inc st_private.h st_public.h Description: get the value of the average speed st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters:  input index : the index of the average speed output speed : the value of the average speed st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: RET_FAIL RET_INVALID RET_OK st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Author:Xueping.Chen Date:2016-12-06 Version:V1.0 ****************************************************/ U8 ST_GetAverageSpeed(U8 Index, PU32 pSpeed) { U8 res = RET_FAIL;  if (FALSE == st_InitSts) { res = RET_FAIL; } else if ((NULL_PTR == pSpeed) || ( E_ST_AVERAGE_ALL <= Index)) { res = RET_INVALID; } else { if (E_ST_AVERAGE_SPEED1 == Index) { *pSpeed = st_AverageSpeed1; res = RET_OK; } else if (E_ST_AVERAGE_SPEED2 == Index) { *pSpeed = st_AverageSpeed2; res = RET_OK; } else { res = RET_FAIL; } } return res; }  /*************************************************** st.c st_cfg.h st_info.inc st_private.h st_public.h Function: ST_GetEngineRuningFlag st.c st_cfg.h st_info.inc st_private.h st_public.h Description: get the state of the engine st.c st_cfg.h st_info.inc st_private.h st_public.h Parameters: none st.c st_cfg.h st_info.inc st_private.h st_public.h Returns: none st.c st_cfg.h st_info.inc st_private.h st_public.h $Create & Verlog:$ st.c st_cfg.h st_info.inc st_private.h st_public.h Author:Xueping.Chen Date:2016-12-06 Version:V1.0 ****************************************************/  BOOL ST_GetEngineRuningFlag(void) { return EngineRunningFlag; } /*=========================================================================== st.c st_cfg.h st_info.inc st_private.h st_public.h File Revision History(bottom to top:first revision to last revision) *============================================================================ st.c st_cfg.h st_info.inc st_private.h st_public.h $Log:$ * st.c st_cfg.h st_info.inc st_private.h st_public.h Rev: Userid: Date: Description *-------- ---------- --------- ------------------------------ * st.c st_cfg.h st_info.inc st_private.h st_public.h V1.0 Xueping.Chen 2016-12-06 Initial * *===========================================================================*/
