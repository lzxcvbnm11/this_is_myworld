/******************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr All Rights Reserved */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Automatically generated file */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /******************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ECU name: IPK */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ECU version: 1.03 */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ECU manufacturer: SAIC */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ECU description: */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ECU hardware: Freescale MPC560X */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Software compiler: Freescale CodeWarrior 2.10 */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /******************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Module name: Transport_Module */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Module version: v1.00 */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr File: s_tpm_callout.c */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Date: 2017-07-18,16:22:43 */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr File description: TPM callout function source file. */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr */ /******************************************************************************/  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr please include the header files of CAN communication module */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr COM header */ /* #include "s_com_cfg.h" */  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr CAN driver header */ /* #include "s_msc12s.h" */ #include "s_tpm_cfg.h" #include "s_tpm.h" #include "s_dsm_api.h" S_FUNC_PRE s_bool S_FUNC_SUF s_dsm_channel_is_used(const s_tpm_channel* channel); /****************************************************************************** lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Function: s_dsm_channel_is_used lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Description: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h This function is to check if the input channel is used for DSM. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Parameter: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h channel[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h TPM channel pointer. * lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Return: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_TRUE: The current channel is used for DSM. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_FALSE: The current channel is not used for DSM. lib/ S_FUNC_PRE s_bool S_FUNC_SUF s_dsm_channel_is_used(const s_tpm_channel* channel) { s_tpm_channel_handle dsm_used_channel; s_bool ret = S_FALSE; s_uint8 i; i = 0u; do { dsm_used_channel = s_tpm_chl_dsm_used[i];  if (channel == dsm_used_channel) { ret = S_TRUE;  break; }  i++; }while (dsm_used_channel != S_NULL);  return ret; } /****************************************************************************** lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Function: s_tpm_co_confirm  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Description:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h This callout is used by the Transport Module during a call lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h to s_tpm_task() for three situations. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h 1. when it needs a buffer for the transmission of a message, lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h 2. when a transmission is completed, lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h 3. when the transmission fails for some reason. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Parameter:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h channel[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h TPM channel pointer. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h status[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The TPM transmission status. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h rem_length[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The remaining number of bytes to be transmitted. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h buffer[OUT]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The buffer address application provided. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h buffer_length[OUT]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The buffer length application provided. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Return:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_TPM_TX_BUFFER_MODE_SINGLE: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The buffer length application provided is less than the TPM lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h needed to complete a PDU. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_TPM_TX_BUFFER_MODE_MANY:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The buffer length application provided is enough for more than lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h one PDU. lib/ S_FUNC_PRE s_uint8 S_FUNC_SUF s_tpm_co_confirm(const s_tpm_channel* channel, s_uint8 status, s_uint16 rem_length, volatile s_uint8 lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h volatile lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h const buffer, volatile s_uint16 lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h const buffer_length) { s_uint8 ret; if(s_dsm_channel_is_used(channel) == S_TRUE) { ret = s_dsm_confirm(channel, status, rem_length, buffer,  buffer_length); } else { } return(ret); } /****************************************************************************** lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Function: s_tpm_co_indication  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Description:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h This callout is used by the Transport Module during a call lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h to s_tpm_task()for three situations. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h 1. when it needs a buffer for the reception of a message, lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h 2. when a message has been received successfully, lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h 3. when the reception fails for some reason. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Parameter:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h channel[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h TPM channel pointer. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h status[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The TPM reception status. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h rem_length[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The remaining number of bytes to be received. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h buffer[OUT]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The buffer address application provided. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h buffer_length[OUT]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The buffer length application provided. * lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Return: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_TPM_RX_BUFFER_MODE_SINGLE: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The buffer length application provided is less than the TPM lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h needs to complete a PDU. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_TPM_RX_BUFFER_MODE_MANY: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The buffer length application provided is enough for more than lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h one PDU. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_TPM_RX_BUFFER_MODE_OVERFLOW: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h This value is only allowed to be returned when the callout lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h is invoked with status S_TPM_STATUS_RX_FIRST_FRAME. In this lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h case it signifies that the application cannot handle messages lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h of the size specified by the msg_length parameter. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_TPM_RX_BUFFER_MODE_CANCEL:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h If the user wants to abort this message, it can return this lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h value. lib/ S_FUNC_PRE s_uint8 S_FUNC_SUF s_tpm_co_indication(const s_tpm_channel* channel, s_uint8 status, s_uint16 rem_length, volatile s_uint8 lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h volatile lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h const buffer, volatile s_uint16 lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h const buffer_length) { s_uint8 ret; if(s_dsm_channel_is_used(channel) == S_TRUE) { ret = s_dsm_indication(channel, status, rem_length, buffer,  buffer_length); } else { } return(ret); } /****************************************************************************** lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Function: s_tpm_co_bypass_indication  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Description:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h When the TPM receives a bypass frame, this function will be lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h called. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Parameter:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h channel[IN]:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h TPM channel pointer.  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Return:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h none.  lib/ S_FUNC_PRE void S_FUNC_SUF s_tpm_co_bypass_indication(const s_tpm_channel* channel) { if(s_dsm_channel_is_used(channel) == S_TRUE) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr bypass data: 0x3Eu,0x80u, DefaultChannel */ s_dsm_bypass_indication(channel); } else { } return; } /****************************************************************************** lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Function: s_tpm_frm_rx  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Description:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h This function is used to query whether the communication lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h module receives the frame with given can_id. If the frame is lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h successfully received, CAN frame data can be access through buffer. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Parameter:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h buffer[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h CAN frame receive buffer. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h can_id[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The frame identification to receive. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Return:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_TRUE:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h TPM has received the frame.  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_FALSE:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h TPM hasn't received the frame.  lib/ S_FUNC_PRE s_bool S_FUNC_SUF s_tpm_frm_rx(s_uint8* buffer, s_uint32 can_id) { s_bool ret = S_FALSE; switch(can_id) { case 0x760u: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The CANID of DiagPhysAddrReq in DefaultChannel. */ { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr call COM interface */  ret = v_imf_rx(DIAG_PhysReq_IPK_handle);  if (S_TRUE == ret) { v_rd_bytes(DiagnosticReqIPK_handle, buffer, 0x08u, 0x00u ); }    /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr call CAN driver interface */ /* ret = s_msc12s_read_frame( can_id, buffer ); lib/  break; } case 0x7DFu: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The CANID of DiagFuncAddrReq in DefaultChannel. */ { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr call COM interface */  ret = v_imf_rx(DIAG_FuncReq_HSC1_handle);  if (S_TRUE == ret) { v_rd_bytes(DiagnosticFuncAddrReq_handle, buffer, 0x08u, 0x00u ); }    /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr call CAN driver interface */ /* ret = s_msc12s_read_frame( can_id, buffer ); */  break; } default: { break; } } return(ret); } /****************************************************************************** lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Function: s_tpm_frm_tx  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Description:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The TPM transmits a frame with given can_id and data. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Parameter:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h data[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h CAN frame data buffer to transmit. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h can_id[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The frame identification to transmit. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Return: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h none. lib/ S_FUNC_PRE void S_FUNC_SUF s_tpm_frm_tx(s_uint8* data, s_uint32 can_id) { s_uint32 send_canid;  switch(can_id) { case 0x768u: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The CANID of DiagPhysAddrResp in DefaultChannel. */ { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr call COM interface lib/  v_wr_bytes(DiagnosticRespIPK_handle, data, 0x08, 0x00); v_imf_tx(DIAG_PhysResp_IPK_handle);    /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr call CAN driver interface */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr CAN id convert to register value and call CAN driver to transmit frame */ /* send_canid = id2reg( can_id ); (void)s_msc12s_send_frame( data, send_canid, 8 ); */  break; } default: { break; } } return; } /****************************************************************************** lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Function: s_tpm_frm_check_tx_state  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Description:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h This function is used to query the transmission state of the lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h frame with given can_id. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Parameter:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h can_id[IN]: lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The frame identification. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Return:  lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_FRM_NOT_IN_QUEUE(0x00u): lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The frame has been successfully transmitted. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_FRM_IN_QUEUE(0x01u): lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The frame is currently queued. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_FRM_NOT_IN_MODE(0x02u): lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h The frame is not in the current mode. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_FRM_MODE_CHANGE(0x03u): lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h A frame mode change is in progress. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h S_FRM_ERROR(0x04u): lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h Other error occurs. lib s_tpm.h s_tpm_callout.c s_tpm_cfg.c s_tpm_cfg.h  lib/ S_FUNC_PRE s_uint8 S_FUNC_SUF s_tpm_frm_check_tx_state(s_uint32 can_id) { s_uint8 ret = S_FRM_NOT_IN_QUEUE;  switch(can_id) { case 0x768u: /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The CANID of DiagPhysAddrResp in DefaultChannel. */ { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr call COM interface */  ret = v_imf_queued(DIAG_PhysResp_IPK_handle);    break; } default: { break; } } return(ret); }
