#include "nzm_info.inc"  #pragma ghs startdata  #pragma ghs section bss = ".rbss" static NZM_ZS12Data_UN data; #pragma ghs section bss = default #pragma ghs enddata  static BOOL nzm_Init = FALSE; static BOOL nzm_success = FALSE;  /*************************************************** nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Function: NZM_Init nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Description: the initialized of the NZM module nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Parameters: none nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Returns: none nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h $Create & Verlog:$ nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Author:liuyingyign Date:2017-09-25 Version:V2.0 ****************************************************/  void NZM_Init(void) {  U8 chkSum = 0; RtcaTime_ST sysTime; RtcaTime_ST nzm_sysTime; U64 value1 = 0; U64 value2 = 0; U8 i = 0; U16 day = 0;   nzm_Init = FALSE; nzm_success =FALSE;  for (i =0; i <NZM_DATA_LEN-1; i++)  { chkSum +=data.buf[i]; }  if(chkSum == data.buf[NZM_DATA_LEN-1]) { nzm_success =TRUE; printf("legal data,you can use!!\r\n"); } else { memset(data.buf,0,NZM_DATA_LEN); }   #if 0//liuyingying @20171221 rtc RTCA_GetTime(&sysTime); value1 = sysTime.year *365*24*60*60; for(i = 1; i <sysTime.month; i ++) { day +=monthDayTab[i]; if((2 == i) && (0 == sysTime.year%4)) day +=1; } value1 +=(day+sysTime.day)*24*60*60; value1 +=(sysTime.hour*60*60); value1 +=(sysTime.minute*60); value1 +=(sysTime.sec);  //NZM_GetDataValue(INDEX_NZM_SYSTIME,&nzm_sysTime,9);  value2 = data.Info.time.year *365*24*60*60; for(i = 1; i <data.Info.time.month; i ++) { day +=monthDayTab[i]; if((2 == i) && (0 == sysTime.year%4)) day +=1; } value2 +=(day+data.Info.time.day)*24*60*60; value2 +=(data.Info.time.hour*60*60); value2 +=(data.Info.time.minute*60); value2 +=(data.Info.time.sec);  if(value1 > value2) { if((value1 - value2) >60*60) { data.Info.data.drvTime1 = 0; data.Info.data.trip1 = 0; } else { } } data.Info.time = sysTime; #endif   //data.Info.data.littleZPD = 0; nzm_Init = TRUE; }   /*************************************************** nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Function: NZM_Update_50ms nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Description: the process of the NZM update  nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Parameters: none nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Returns: none nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h $Create & Verlog:$ nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Author:liuyingyign Date:2017-09-25 Version:V2.0 ****************************************************/  void NZM_Update_50ms(void) {  U8 i; U8 chkSum = 0;  DM_UpdatePageInfo(&(data.Info.disp)); switch(data.Info.disp.MainPage) { case MAINFUCTION_TC: memcpy(&data.Info.tc,&(data.Info.disp),sizeof(Dm_CMD_ST)); break;  case MAINFUCTION_SET: memcpy(&(data.Info.set),&(data.Info.disp),sizeof(Dm_CMD_ST)); break; case MAINFUCTION_ENTERTAINMENT: break; case MAINFUCTION_FAULT: memcpy(&(data.Info.flt),&(data.Info.disp),sizeof(Dm_CMD_ST)); break; }   ILLU_GetILLULevel(&(data.Info.data.illuLevel)); // DM_GetIlluLevel(&(data.Info.data.illuLevel)); DM_GetSetMainIndex(&(data.Info.data.setIndex)); DM_GetFltListIndex(&(data.Info.data.fltIndex));  ODO_GetODOValue(INDEX_ODO_TRIP1, &(data.Info.data.trip1)); ODO_GetODOValue(INDEX_ODO_TRIP2, &(data.Info.data.trip2)); RTC_GetDrivenTime(E_DRIVEN_TIME1, &(data.Info.data.drvTime1)); RTC_GetDrivenTime(E_DRIVEN_TIME2, &(data.Info.data.drvTime2));  ODO_GetODOValue(INDEX_ODO_METER,&(data.Info.data.odo)); TRIP_GetRTCTime(&(data.Info.time));  for (i =0; i <NZM_DATA_LEN-1; i++)  { chkSum +=data.buf[i]; }  data.buf[NZM_DATA_LEN-1] = chkSum;  }  /*************************************************** nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Function: NZM_GetDataValue nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Description: According to the index to get data from NZM nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Parameters: index:input date index  pValue:The pointer of he data size: date size nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Returns:  RET_FAIL RET_INVALID RET_OK nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h $Create & Verlog:$ nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Author:liuyingyign Date:2017-09-25 Version:V2.0 ****************************************************/  U8 NZM_GetDataValue(nzm_dataInfo_ENUM index,PU8 pValue,U8 size) { if (FALSE == nzm_Init) { return RET_FAIL; } else if (FALSE == nzm_success) { return RET_FAIL; } else { if(NULL_PTR == pValue) { return RET_INVALID; } else { switch(index) { case INDEX_NZM_TRIP1: if(4 == size) memcpy(pValue,& data.Info.data.trip1,size); break; case INDEX_NZM_TRIP2: if(4 == size) memcpy(pValue,& data.Info.data.trip2,size); break; case INDEX_NZM_TIME1: if(4 == size) memcpy(pValue,& data.Info.data.drvTime1,size); break; case INDEX_NZM_TIME2: if(4 == size) memcpy(pValue,& data.Info.data.drvTime2,size); break;  case INDEX_NZM_ODO: if(4 == size) memcpy(pValue,& data.Info.data.odo,size); break; case INDEX_NZM_MAINPAGE: if(1 == size) memcpy(pValue,& data.Info.disp.MainPage,size); break; case INDEX_NZM_TCSUBPAGE: if(1 == size) memcpy(pValue,& data.Info.tc.SubPage,size); break;  case INDEX_NZM_SETINDEX:  if(1 == size) memcpy(pValue,& data.Info.data.setIndex,size); break; case INDEX_NZM_ILLULEVEL:  if(1 == size) memcpy(pValue,& data.Info.data.illuLevel,size); break; case INDEX_NZM_FLTINDEX:  if(1 == size) memcpy(pValue,& data.Info.data.fltIndex,size); break;  //liuyingying @20171220 case INDEX_NZM_LITTLEZPD:  if(1 == size) memcpy(pValue,& data.Info.data.littleZPD,size); break; #if 1//liuyingying @20171221 rtc case INDEX_NZM_SYSTIME:  if(10 == size) memcpy(pValue,& data.Info.time,size); break; #endif default: break;  } return RET_OK; } } }   /*************************************************** nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Function: NZM_SetLittleZpd nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Description:set little Zero Position Detect status nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Parameters: sts: input Zero Position Detect status nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Returns: RET_OK nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h $Create & Verlog:$ nzm.c nzm_cfg.h nzm_info.inc nzm_private.h nzm_public.h Author:liuyingyign Date:2017-12-20 Version:V2.0 ****************************************************/  U8 NZM_SetLittleZpd(U8 sts) { data.Info.data.littleZPD = sts; return RET_OK; } 
