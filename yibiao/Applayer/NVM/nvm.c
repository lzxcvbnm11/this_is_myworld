/***************************************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Copyright (C) 2016 ShenZhen Yeedon Media co.,LTD. All rights reserved. * nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h File Name : nvm.c nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description : nvm module nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author: Xuenian.Feng nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Date: 2016-12-1 ******************************************************************************/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Files for including */ #include "nvm_info.inc"  static BOOL nvm_InitSts = FALSE; static U8 nvm_WriteCmdCnt =0;  static U8 nvm_Busy = FALSE; static NVMKeyBlock_ENUM nvm_WriteCmdBuf[INDEX_NVM_ALL] = {INDEX_NVM_NONE};   static nvm_RW_ST nvm_W_Data; /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_Init nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: NVM module initialized nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: none nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: none nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/   void NVM_Init(void) { BOOL res = 0; U16 i,j = 0; U8 buf[32] = {0}; U8 chkSum = 0; PU8 pData = NULL;  memset(nvm_Data.page0.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.page1.buf,0,SIZE_NVM_PAGE); for(i = 0;i < 18; i ++) { memset(nvm_Data.logist.flow1.buf[i],0,SIZE_NVM_PAGE); } for(i = 0;i < 10; i ++) { memset(nvm_Data.logist.flow2.buf,0,SIZE_NVM_PAGE); } memset(nvm_Data.page1.buf,0,SIZE_NVM_PAGE);  memset(nvm_Data.config.page0.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page1.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page2.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page3.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page4.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page5.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page6.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page7.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page8.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page9.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page10.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page11.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page12.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page13.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page14.page,0,SIZE_NVM_PAGE); memset(nvm_Data.config.page15.page,0,SIZE_NVM_PAGE);  memset(nvm_Data.dtc.page0.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page1.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page2.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page3.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page4.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page5.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page6.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page7.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page8.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page9.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page10.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page11.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page12.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page13.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page14.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page15.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page16.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page17.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page18.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page19.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page20.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page21.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page22.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page23.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.dtc.page24.buf,0,SIZE_NVM_PAGE);  memset(nvm_Data.snapshort[0].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.snapshort[1].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.snapshort[2].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.snapshort[3].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.snapshort[4].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.snapshort[5].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.snapshort[6].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.snapshort[7].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.snapshort[9].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.snapshort[10].buf,0,SIZE_NVM_PAGE);  memset(nvm_Data.function.page0.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.function.page1.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.function.odo[0].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.function.odo[1].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.function.odo[2].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.function.odo[3].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.function.odo[4].buf,0,SIZE_NVM_PAGE); memset(nvm_Data.function.angle.buf,0,SIZE_NVM_PAGE); memset(nvm_Data.function.page8.buf,0,SIZE_NVM_PAGE);  memset(&nvm_W_Data,0,sizeof(nvm_RW_ST));  #if 0 for(i = 0 ;i < 16;i ++) { buf[i] = 0xFF; }   for (j = 0; j <45;j ++) { res = EED_WriteBytes(16 *j, buf, SIZE_NVM_PAGE); WDT_Feed(); }  for (j = 112; j <128;j ++) { if(j == 120) buf[0] = 1; else buf[0] = 0xFF; res = EED_WriteBytes(16 *j, buf, SIZE_NVM_PAGE); WDT_Feed(); }  printf("clean finish\r\n"); while(1); #endif res = EED_ReadBytes(ADDR_SYS_PAGE0+0x00, nvm_Data.page0.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_SYS_PAGE0+0x10, nvm_Data.page1.buf, SIZE_NVM_PAGE);  res = EED_ReadBytes(ADDR_LOGIST_PAGE0+0X00, nvm_Data.logist.page0.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_LOGIST_PAGE0+0X10, nvm_Data.logist.page1.buf, SIZE_NVM_PAGE); for (i =0 ; i < 18; i ++) { res = EED_ReadBytes(ADDR_LOGIST_PAGE0+0X20+ i *0x10, nvm_Data.logist.flow1.buf[i], SIZE_NVM_PAGE); }  for (i =0 ; i < 10; i ++) { res = EED_ReadBytes(ADDR_LOGIST_PAGE1+0X20+ i *0x10, nvm_Data.logist.flow2.buf[i], SIZE_NVM_PAGE); }   res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0x00, nvm_Data.config.page0.page, SIZE_NVM_PAGE); if(FALSE == res) {  nvm_Data.config.page0.page0_U.C111.insEngineType = INSENGINETYPE_DEF_VALUE; nvm_Data.config.page0.page0_U.C111.insStandbyTPrm = INSSTANDBYTPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C111.insSRSEchoMesInhibPeriod = INSSRSECHOMESINHIBPERIOD_DEF_VALUE; nvm_Data.config.page0.page0_U.C111.insStopStartSysEnPrm = INSSTOPSTARTSYSENPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C111.insEchoMesPeriodPrm = INSECHOMESPERIODPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C111.insEchoMesMinPeriodPrm = INSECHOMESMINPERIODPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C111.insIgnOffDispPeriodPrm = INSIGNOFFDISPPERIODPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C111.insTyrePresUnitsPrm = INSTYREPRESUNNITSPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C111.insUnitsPrm = INSUNITSPRM_DEF_VALUE;  nvm_Data.config.page0.page0_U.C112.PmWaitForClutchDelayPrm = PMWAITFORCLUTCHDELAYPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.PmWaitForBrakeDelayPrm = PMWAITFORBRAKEDELAYPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.PmSSBActivePressTimePrm = PMSSBACTIVEPRESSTIMEPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.PmSSBPressesWinTimePrm = PMSSBPRESSESWINTIMEPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.PmSSBPressesToTurnOFFPrm = PMSSBPRESSESTOTURNOFFPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.PmSSBPressTimeToTurnOFFPrm = PMSSBPRESSTIMETOTURNOFFPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.PmACCToOFFDelayPrm = PMACCTOOFFDELAYPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.GloVehMovingThresholdPrm = GLOVEHMOVINGTHRESHOLDPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.GloVehStoppedThresholdPrm = GLOVEHSTOPPEDTHRESHOLDPRM_DEF_VALUE; //nvm_Data.config.page0.page0_U.C112.pmOperationalMode = PMOPERATIONALMODE_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.GloEnPEPSIGNOffUseSSBPrm = GLOENPEPSIGNOFFUSESSBPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.PmMultiPressEnPRm = PMMULTIPRESSENPRM_DEF_VALUE; nvm_Data.config.page0.page0_U.C112.InsVehWithPepsEnPrm = INSVEHWITHPEPSENPRM_DEF_VALUE; }  res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0x10, nvm_Data.config.page1.page, SIZE_NVM_PAGE); if(FALSE == res) { nvm_Data.config.page1.page1_U.C113.PmSSBMismatchCouterPrm = PMSSBMISMATCHCOUTERPRM_DEF_VALUE; nvm_Data.config.page1.page1_U.C113.PmWaitForUIDAuthDelayPrm = PMWAITFORUIDAUTHDELAYPRM_DEF_VALUE; nvm_Data.config.page1.page1_U.C113.PEPSSenseSSBWithinTimePrm = PEPSSENSESSBWITHINTIMEPRM_DEF_VALUE; nvm_Data.config.page1.page1_U.C113.PmSSBStuckSWTimePrm = PMSSBSTUCKSWTIMEPRM_DEF_VALUE; nvm_Data.config.page1.page1_U.C121.insOdoOffestPrm = INSODOOFFESTPRM_DEF_VALUE; nvm_Data.config.page1.page1_U.C121.insOdoIncFactorPlatformPrm = INSODOINCFACTORPLATFORMPRM_DEF_VALUE;  nvm_Data.config.page1.page1_U.C122.insOdoStorePrm_Byte1 = INSODOSTOREPRM_DEF_VALUE; nvm_Data.config.page1.page1_U.C122.insOdoStorePrm_Byte2 = INSODOSTOREPRM_DEF_VALUE; nvm_Data.config.page1.page1_U.C122.insOdoStorePrm_Byte3 = INSODOSTOREPRM_DEF_VALUE; nvm_Data.config.page1.page1_U.C122.insOdoStorePrm_Byte4 = INSODOSTOREPRM_DEF_VALUE; } res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0x20, nvm_Data.config.page2.page, SIZE_NVM_PAGE); if(FALSE == res) { nvm_Data.config.page2.page2_U.C131.insTripRollOverPrm = INSTRIPROLLOVERPRM_DEF_VALUE; nvm_Data.config.page2.page2_U.C131.insTripResetTimeoutPrm = INSTRIPRESETTIMEOUTPRM_DEF_VALUE; nvm_Data.config.page2.page2_U.C141.insEngRunTimePrm = INSENGRUNTIMEPRM_DEF_VALUE; } res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0x30, nvm_Data.config.page3.page, SIZE_NVM_PAGE); if(FALSE == res) { nvm_Data.config.page3.page3_U.C151.insSpeedoAdjustConstantPrm = INSSPEEDOADJUSTCONSTANTPRM_DEF_VALUE;  nvm_Data.config.page3.page3_U.C164.insFuelSeg4ThresPrm_HB= ((INSFUELSEG4THRESPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page3.page3_U.C164.insFuelSeg4ThresPrm_LB= (INSFUELSEG4THRESPRM_DEF_VALUE & 0xFF);   nvm_Data.config.page3.page3_U.C164.insFuelSeg3ThresPrm_HB= ((INSFUELSEG3THRESPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page3.page3_U.C164.insFuelSeg3ThresPrm_LB= (INSFUELSEG3THRESPRM_DEF_VALUE & 0xFF);   nvm_Data.config.page3.page3_U.C164.insFuelSeg2ThresPrm_HB= ((INSFUELSEG2THRESPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page3.page3_U.C164.insFuelSeg2ThresPrm_LB= (INSFUELSEG2THRESPRM_DEF_VALUE & 0xFF);   nvm_Data.config.page3.page3_U.C164.insFuelSeg1ThresPrm_HB= ((INSFUELSEG1THRESPRM_DEF_VALUE & 0xFF00)>>8);  nvm_Data.config.page3.page3_U.C164.insFuelSeg1ThresPrm_LB= (INSFUELSEG1THRESPRM_DEF_VALUE & 0xFF); }  res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0x40, nvm_Data.config.page4.page, SIZE_NVM_PAGE); if(FALSE == res) { nvm_Data.config.page4.page4_U.C165.insFuelSeg8ThresPrm_HB= ((INSFUELSEG8THRESPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page4.page4_U.C165.insFuelSeg8ThresPrm_LB= (INSFUELSEG8THRESPRM_DEF_VALUE & 0xFF);  nvm_Data.config.page4.page4_U.C165.insFuelSeg7ThresPrm_HB= ((INSFUELSEG7THRESPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page4.page4_U.C165.insFuelSeg7ThresPrm_LB= (INSFUELSEG7THRESPRM_DEF_VALUE & 0xFF);  nvm_Data.config.page4.page4_U.C165.insFuelSeg6ThresPrm_HB= ((INSFUELSEG6THRESPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page4.page4_U.C165.insFuelSeg6ThresPrm_LB= (INSFUELSEG6THRESPRM_DEF_VALUE & 0xFF);  nvm_Data.config.page4.page4_U.C165.insFuelSeg5ThresPrm_HB= ((INSFUELSEG5THRESPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page4.page4_U.C165.insFuelSeg5ThresPrm_LB= (INSFUELSEG5THRESPRM_DEF_VALUE & 0xFF);   nvm_Data.config.page4.page4_U.C166.insFuelRisingRatePrm_HB= ((INSFUELRISINGRATEPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page4.page4_U.C166.insFuelRisingRatePrm_LB= (INSFUELRISINGRATEPRM_DEF_VALUE & 0xFF);  nvm_Data.config.page4.page4_U.C166.insFuelRefillQtyPrm_HB= ((INSFUELREFILLQTYPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page4.page4_U.C166.insFuelRefillQtyPrm_LB= (INSFUELREFILLQTYPRM_DEF_VALUE & 0xFF);  nvm_Data.config.page4.page4_U.C166.insFuelDisplayHysPrm_HB= ((INSFUELDISPLAYHYSPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page4.page4_U.C166.insFuelDisplayHysPrm_LB= (INSFUELDISPLAYHYSPRM_DEF_VALUE & 0xFF); }  res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0x50, nvm_Data.config.page5.page, SIZE_NVM_PAGE); if(FALSE == res) { nvm_Data.config.page5.page5_U.C167.insFuelTankTotalCapacity = INSFUELTANKTOTALCAPACITY_DEF_VALUE; nvm_Data.config.page5.page5_U.C167.insFuelUpperTolerancePrm = INSFUELUPPERTOLERANCEPRM_DEF_VALUE; nvm_Data.config.page5.page5_U.C167.insFuelLowerTolerancePrm = INSFUELLOWERTOLERANCEPRM_DEF_VALUE;  nvm_Data.config.page5.page5_U.C167.insFuelFallingRatePrm_HB= ((INSFUELFALLINGRATEPRM_DEF_VALUE & 0xFF00)>>8); nvm_Data.config.page5.page5_U.C167.insFuelFallingRatePrm_LB= (INSFUELFALLINGRATEPRM_DEF_VALUE & 0xFF);  nvm_Data.config.page5.page5_U.C171.insTempSeg8ThresPrm = INSTEMPSEG8THRESPRM_DEF_VALUE; nvm_Data.config.page5.page5_U.C171.insTempSeg7ThresPrm = INSTEMPSEG7THRESPRM_DEF_VALUE; nvm_Data.config.page5.page5_U.C171.insTempSeg6ThresPrm = INSTEMPSEG6THRESPRM_DEF_VALUE; nvm_Data.config.page5.page5_U.C171.insTempSeg5ThresPrm = INSTEMPSEG5THRESPRM_DEF_VALUE; nvm_Data.config.page5.page5_U.C171.insTempSeg4ThresPrm = INSTEMPSEG4THRESPRM_DEF_VALUE; nvm_Data.config.page5.page5_U.C171.insTempSeg3ThresPrm = INSTEMPSEG3THRESPRM_DEF_VALUE; nvm_Data.config.page5.page5_U.C171.insTempSeg2ThresPrm = INSTEMPSEG2THRESPRM_DEF_VALUE; }  res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0x60, nvm_Data.config.page6.page, SIZE_NVM_PAGE); if(FALSE == res) {    nvm_Data.config.page6.page6_U.C172.insTempDisplayHysPrm = INSTEMPDISPLAYHYSPRM_DEF_VALUE;   nvm_Data.config.page6.page6_U.C181.insPDCFMesEnPrm = INSPDCFMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insBattFailMesEnPrm = INSBATTFAILMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insEPBAssistMesEnPrm = INSEPBASSISTMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insDSCLampEnPrm = INSDSCLAMPENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insWinOpenEchoMesEnPrm = INSWINOPENECHOMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insLampFailMesEnPrm = INSLAMPFAILMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insStartstopButtonFMesEnPrm = INSSTARTSTOPBUTTONFMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insIgnitionRelayFMesEnPrm = INSIGNITIONRELAYFMESENPRM_DEF_VALUE;   nvm_Data.config.page6.page6_U.C181.insPutKeyIntoBkupPMesEnPrm = INSPUTKEYINTOBKUPPMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insPutShifterParkMesEnPrm = INSPUTSHIFTERPARKMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insTakeSmarKeyMesEnPrm =INSTAKESMARKEYMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insTyrTemDisUntPrm = INSTYRTEMDISUNTPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insTPMSRemMesEnPrm = INSTPMSREMMESENPRM_DEF_VALUE ; nvm_Data.config.page6.page6_U.C181.insTPMSFailEnPrm =INSTPMSFAILENPRM_DEF_VALUE ; nvm_Data.config.page6.page6_U.C181.insTPMSGongEnPrm =INSTPMSGONGENPRM_DEF_VALUE ;  nvm_Data.config.page6.page6_U.C181.InsTPMSLampFlaPeriodPrm =INSTPMSLAMPFLAPERIODPRM_DEF_VALUE ; nvm_Data.config.page6.page6_U.C181.insTPMSTempDisEnPrm = INSTPMSTEMPDISENPRM_DEF_VALUE;  nvm_Data.config.page6.page6_U.C181.insPressBrakeShiftMesEnPrm =INSPRESSBRAKESHIFTMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insPressButtonEngineOffMesEnPrm = INSPRESSBUTTONENGINEOFFMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insAutoholdAssistMesEnPrm = INSAUTOHOLDASSISTMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insESCLLampEnPrm =INSESCLLAMPENPRM_DEF_VALUE ; nvm_Data.config.page6.page6_U.C181.insStopStartOffMesPrm = INSSTOPSTARTOFFMESPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insSASLampEnPrm =INSSASLAMPENPRM_DEF_VALUE ; nvm_Data.config.page6.page6_U.C181.insEPSLampEnPrm = INSEPSLAMPENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insStopStartOnMesEnPrm = INSSTOPSTARTONMESENPRM_DEF_VALUE;  nvm_Data.config.page6.page6_U.C181.insSelectNeutralRestartMesEnPrm = INSSELECTNEUTRALRESTARTMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insFastenSeatbeltRestartMesEnPrm = INSFASTENSEATBELTRESTARTMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insCloseDriverDoorRestartMesEnPrm = INSCLOSEDRIVERDOORRESTARTMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insBrakeMesEnPrm = INSBRAKEMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insLoadShedLampEnPrm = INSLOADSHEDLAMPENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insLoadShedGongEnPrm =INSLOADSHEDGONGENPRM_DEF_VALUE ; nvm_Data.config.page6.page6_U.C181.insClutchMesEnPrm = INSCLUTCHMESENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insHDCLampEnPrm = INSHDCLAMPENPRM_DEF_VALUE;  nvm_Data.config.page6.page6_U.C181.insEPBConstantGongPeriodPrm = INSEPBCONSTANTGONGPERIODPRM_DEF_VALUE;  nvm_Data.config.page6.page6_U.C181.insLampCheckTimePrm = INSLAMPCHECKTIMEPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insAutoholdStatusEnPrm = INSAUTOHOLDSTATUSENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insCruiseLampEnPrm =INSCRUISELAMPENPRM_DEF_VALUE; nvm_Data.config.page6.page6_U.C181.insEPBStatusEnPrm =INSEPBSTATUSENPRM_DEF_VALUE;   }  res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0x70, nvm_Data.config.page7.page, SIZE_NVM_PAGE); if(FALSE == res) {  nvm_Data.config.page7.page7_U.C182.InsIgnOffSpelWarnPeriodPrm = INSIGNOFFSPELWARNPERIODPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C182.insEcoLampEnPrm = INSECOLAMPENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C182.insNoSmartKeyLampEnPrm = INSNOSMARTKEYLAMPENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C182.insPEPSAntFltMesEnPrm = INSPEPSANTFLTMESENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C182.insKeyBatLowLampEnPrm = INSKEYBATLOWLAMPENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C182.insPlsInitWndMesEnPrm = INSPLSINITWNDMESENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C182.insSecKeyInvLampEnPrm = INSSECKEYINVLAMPENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C182.inPlsEnPkOrNtlToStartMesEnPrm= INSPLSENPKORNTLTOSTARTMESENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C182.insFrFogLampEnPrm = INSFRFOGLAMPENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C182.insSBeltRemPeriodPrm = INSSBELTREMPERIODPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C182.insBrakeSysRemPeriodPrm = INSBRAKESYSREMPERIODPRM_DEF_VALUE;  nvm_Data.config.page7.page7_U.C191.insOSThreshPrm = INSOSTHRESHPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C191.insOSHysPrm = INSOSHYSPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C191.insGearShiftUpDwnWarnPrm = INSGEARSHIFTUPDWNWARNPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C191.insRecomGearEnPrm = INSRECOMGEARENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C191.insPDCInitSucGongTotalTimePrm = INSPDCINITSUCGONGTOTALTIMEPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C191.insPDCStaAWarnEnPrm = INSPDCSTAAWARNENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C191.insPDCMesEnPrm = INSPDCMESENPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C191.insPDCFailGongTotalTimePrm = INSPDCFAILGONGTOTALTIMEPRM_DEF_VALUE; nvm_Data.config.page7.page7_U.C191.insHandofDrivePrm = INSHANDOFDRIVEPRM_DEF_VALUE; }  res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0x80, nvm_Data.config.page8.page, SIZE_NVM_PAGE); if(FALSE == res) {  nvm_Data.config.page8.page8_U.C192.insCruiseActLampEnPrm = INSCRUISEACTLAMPENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C192.insCruiseSWTypePrm = INSCRUISESWTYPEPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C192.CruiseSwitchAD2Stuck = CRUISESWITCHAD2STUCK_DEF_VALUE;   nvm_Data.config.page8.page8_U.C1A1.insTempUnitsPrm = INSTEMPUNITSPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insFuelConUnitsPrm = INSFUELCONUNITSPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.InsDistanceUnitsPrm = INSDISTANCEUNITSPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insLangPrm = INSLANGPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insPresstime2Prm = INSPRESSTIME2PRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insPresstime1Prm = INSPRESSTIME1PRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insTCDispTimeoutPrm = INSTCDISPTIMEOUTPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insMenuSIAEnPrm = INSMENUSIAENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insSCSOffSwitchEnPrm = INSSCSOFFSWITCHENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insTCConUnitsPrm = INSTCCONUNITSPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insIvspeedEnPrm = INSIVSPEEDENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insMenuDigCEnPrm = INSMENUDIGCENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insMenuIllumAdEnPrm = INSMENUILLUMADENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insRTEEnPrm = INSRTEENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insIFCEnPrm = INSIFCENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insMenuEntryEnPrm = INSMENUENTRYENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insTrip1UserEnPrm = INSTRIP1USERENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insTrip2UserEnPrm = INSTRIP2USERENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insMenuSpeedTresholdPrm = INSMENUSPEEDTRESHOLDPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insDTPMSPrm = INSDTPMSPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insBattDisplayPrm = INSBATTDISPLAYPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.InspaddleshiftEnPrm = INSPADDLESHIFTENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.insPrndEnPrm = INSPRNDENPRM_DEF_VALUE; nvm_Data.config.page8.page8_U.C1A1.InsSCSOffRemPrm = INSSCSOFFREMPRM_DEF_VALUE; } ISM_setDeviceID(nvm_Data.config.page8.page8_U.C1A1.insPresstime2Prm); res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0x90, nvm_Data.config.page9.page, SIZE_NVM_PAGE); if(FALSE == res) { nvm_Data.config.page9.page9_U.C1B1.insSoundTypPrm = INSSOUNDTYPPRM_DEF_VALUE; nvm_Data.config.page9.page9_U.C1B1.insTickTockVolumePrm = INSTICKTOCKVOLUMEPRM_DEF_VALUE; nvm_Data.config.page9.page9_U.C1B1.insGong1TotalTimePrm = INSGONGTOTALTIMEPRM_DEF_VALUE; nvm_Data.config.page9.page9_U.C1B1.insGong1FadeOffPrm = INSGONGFADEOFFPRM_DEF_VALUE; nvm_Data.config.page9.page9_U.C1B1.insGong1VolumePrm = INSGONGVOLUMEPRM_DEF_VALUE;  nvm_Data.config.page9.page9_U.C1B1.insGong1FreqPrm_Bit8 = 0; nvm_Data.config.page9.page9_U.C1B1.insGong1FreqPrm_bit0to7 = INSGONGFREQPRM_DEF_VALUE; nvm_Data.config.page9.page9_U.C1B1.insPDCEnableprm = INSPDCENABLEPRM_DEF_VALUE; nvm_Data.config.page9.page9_U.C1B1.insGong1DurationPrm = INSGONGDURATIONPRM_DEF_VALUE;  nvm_Data.config.page9.page9_U.C1B2.insTacho0PRMCaliPrm_HB =  ((INSTACHO0PRMCALIPRM_DEF_VALUE &0XFF00) >> 8);  nvm_Data.config.page9.page9_U.C1B2.insTacho0PRMCaliPrm_LB =  ((INSTACHO0PRMCALIPRM_DEF_VALUE & 0XFF) >> 0);   nvm_Data.config.page9.page9_U.C1B2.insTacho4KPRMCaliPrm_HB =  ((INSTACHO4KPRMCALIPRM_DEF_VALUE &0XFF00) >> 8);  nvm_Data.config.page9.page9_U.C1B2.insTacho4KPRMCaliPrm_LB =  ((INSTACHO4KPRMCALIPRM_DEF_VALUE & 0XFF) >> 0);   nvm_Data.config.page9.page9_U.C1B2.insTacho8KPRMCaliPrm_HB =  ((INSTACHO8KPRMCALIPRM_DEF_VALUE &0XFF00) >> 8);  nvm_Data.config.page9.page9_U.C1B2.insTacho8KPRMCaliPrm_LB =  ((INSTACHO8KPRMCALIPRM_DEF_VALUE & 0XFF) >> 0);  }  #if 1 nvm_Data.config.page9.page9_U.C1B2.insTacho0PRMCaliPrm_HB = 0xaa; nvm_Data.config.page9.page9_U.C1B2.insTacho0PRMCaliPrm_LB = 0x55;   nvm_Data.config.page9.page9_U.C1B2.insTacho4KPRMCaliPrm_HB = 0xCC; nvm_Data.config.page9.page9_U.C1B2.insTacho4KPRMCaliPrm_HB = 0xAA;   nvm_Data.config.page9.page9_U.C1B2.insTacho8KPRMCaliPrm_HB = 0X55; nvm_Data.config.page9.page9_U.C1B2.insTacho8KPRMCaliPrm_HB = 0XCC; #endif   res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0xA0, nvm_Data.config.page10.page, SIZE_NVM_PAGE); if(FALSE == res) { nvm_Data.config.page10.page10_U.C1C1.insTachoSpeedoIllCharPrm_Byte1 =  ((INSTACHOSPEEDOILLCHARPRM_DEF_VALUE & 0xFF000000)>>24); nvm_Data.config.page10.page10_U.C1C1.insTachoSpeedoIllCharPrm_Byte2 =  ((INSTACHOSPEEDOILLCHARPRM_DEF_VALUE & 0xFF0000)>>16); nvm_Data.config.page10.page10_U.C1C1.insTachoSpeedoIllCharPrm_Byte3 =  ((INSTACHOSPEEDOILLCHARPRM_DEF_VALUE & 0xFF00)>>8);  nvm_Data.config.page10.page10_U.C1C1.insTachoSpeedoIllCharPrm_Byte4 =  (INSTACHOSPEEDOILLCHARPRM_DEF_VALUE & 0xFF);    nvm_Data.config.page10.page10_U.C1C2.insTachoSpeedoPointerIllCharPrm_Byte1 =  ((INSTACHOSPEEDOPOINTERILLCHARPRM_DEF_VALUE & 0xFF000000)>>24); nvm_Data.config.page10.page10_U.C1C2.insTachoSpeedoPointerIllCharPrm_Byte2 =  ((INSTACHOSPEEDOPOINTERILLCHARPRM_DEF_VALUE & 0xFF0000)>>16); nvm_Data.config.page10.page10_U.C1C2.insTachoSpeedoPointerIllCharPrm_Byte3 =  ((INSTACHOSPEEDOPOINTERILLCHARPRM_DEF_VALUE & 0xFF00)>>8);  nvm_Data.config.page10.page10_U.C1C2.insTachoSpeedoPointerIllCharPrm_Byte4 =  (INSTACHOSPEEDOPOINTERILLCHARPRM_DEF_VALUE & 0xFF);   } res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0xB0, nvm_Data.config.page11.page, SIZE_NVM_PAGE); if(FALSE == res) {  nvm_Data.config.page11.page11_U.C1C3.insSegLCDWhiteIllCharPrm_Byte1 =  ((INSSEGLCDWHITEILLCHARPRM_DEF_VALUE & 0xFF000000)>>24); nvm_Data.config.page11.page11_U.C1C3.insSegLCDWhiteIllCharPrm_Byte2 =  ((INSSEGLCDWHITEILLCHARPRM_DEF_VALUE & 0xFF0000)>>16); nvm_Data.config.page11.page11_U.C1C3.insSegLCDWhiteIllCharPrm_Byte3 =  ((INSSEGLCDWHITEILLCHARPRM_DEF_VALUE & 0xFF00)>>8);  nvm_Data.config.page11.page11_U.C1C3.insSegLCDWhiteIllCharPrm_Byte4 =  (INSSEGLCDWHITEILLCHARPRM_DEF_VALUE & 0xFF);    nvm_Data.config.page11.page11_U.C1C4.insWarnIllCharPrm_Byte1 =  ((INSWARNILLCHARPRM_DEF_VALUE & 0xFF000000)>>24); nvm_Data.config.page11.page11_U.C1C4.insWarnIllCharPrm_Byte2 =  ((INSWARNILLCHARPRM_DEF_VALUE & 0xFF0000)>>16); nvm_Data.config.page11.page11_U.C1C4.insWarnIllCharPrm_Byte3 =  ((INSWARNILLCHARPRM_DEF_VALUE & 0xFF00)>>8);  nvm_Data.config.page11.page11_U.C1C4.insWarnIllCharPrm_Byte4 =  (INSWARNILLCHARPRM_DEF_VALUE & 0xFF);       } res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0xC0, nvm_Data.config.page12.page, SIZE_NVM_PAGE); if(FALSE == res) { nvm_Data.config.page12.page12_U.C1C5.insIllumAdEnPrm = INSILLUMADENPRM_DEF_VALUE; nvm_Data.config.page12.page12_U.C1C5.insTachoSpeedoWhiteIllAFactorPrm = INSTACHOSPEEDOWHITEILLAFACTORPRM_DEF_VALUE;  } res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0xD0, nvm_Data.config.page13.page, SIZE_NVM_PAGE); if(FALSE == res) { } res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0xE0, nvm_Data.config.page14.page, SIZE_NVM_PAGE); if(FALSE == res) {   nvm_Data.config.page14.page14_U.C1D1.insSIADistGongEnPrm = INSSIADISTGONGENPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1D1.insSIADistFlashEnPrm = INSSIADISTFLASHENPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1D1.insSIADistThresPrm_bi5 = 0xE8; nvm_Data.config.page14.page14_U.C1D1.insSIADistThresPrm_bit0 = 0x3;  nvm_Data.config.page14.page14_U.C1D1.insSIAOdoPrm_HB= 0x00; nvm_Data.config.page14.page14_U.C1D1.insSIAOdoPrm_MB= 0x00; nvm_Data.config.page14.page14_U.C1D1.insSIAOdoPrm_LB= 0x00;  nvm_Data.config.page14.page14_U.C1D1.insSIADistPrm_HB = 0x27; nvm_Data.config.page14.page14_U.C1D1.insSIADistPrm_LB = 0x10;  nvm_Data.config.page14.page14_U.C1D1.insSIAModePrm = INSSIAMODEPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1D1.insSIADispTPrm = INSSIADISPTPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1E1.insTCFuelDispUpdatePrm = INSTCFUELDISPUPDATEPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1E1.insRTEDisIntervalPrm = INSRTEDISINTERVALPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1E1.insDigiClockEnPrm = INSDIGICLOCKENPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1E1.insICETypePrm = INSICETYPEPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1E1.InsRTEDefFuelConS = INSRTEDEFFUELCONS_DEF_VALUE; nvm_Data.config.page14.page14_U.C1E1.insTCRangeRESPrm = INSTCRANGERESPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1E1.insTCRangeRFPrm = INSTCRANGERFPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1E1.insTCFuelConsLowerLimitPrm = INSTCFUELCONSLOWERLIMITPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1E1.insTCFuelConsUpperLimitPrm = INSTCFUELCONSUPPERLIMITPRM_DEF_VALUE; nvm_Data.config.page14.page14_U.C1E1.insTCFuelConsCorFactorPrm = INSTCFUELCONSCORFACTORPRM_DEF_VALUE; } res = EED_ReadBytes(ADDR_CONFIG_PAGE0+0xF0, nvm_Data.config.page15.page, SIZE_NVM_PAGE);  if(FALSE == res) { nvm_Data.config.page15.page15_U.C1E2.insSpd0KmCaliPrm_HB =  ((INSSPD0KMCALIPRM_DEF_VALUE &0xFF00)>> 8); nvm_Data.config.page15.page15_U.C1E2.insSpd0KmCaliPrm_LB =  ((INSSPD0KMCALIPRM_DEF_VALUE &0xFF)>> 0);  nvm_Data.config.page15.page15_U.C1E2.insSpd100KmCaliPrm_HB =  ((INSSPD100KMCALIPRM_DEF_VALUE &0xFF00)>> 8); nvm_Data.config.page15.page15_U.C1E2.insSpd100KmCaliPrm_LB =  ((INSSPD100KMCALIPRM_DEF_VALUE &0xFF)>> 0);  nvm_Data.config.page15.page15_U.C1E2.insSpd220KmCaliPrm_HB =  ((INSSPD220KMCALIPRM_DEF_VALUE &0xFF00)>> 8); nvm_Data.config.page15.page15_U.C1E2.insSpd220KmCaliPrm_LB =  ((INSSPD220KMCALIPRM_DEF_VALUE &0xFF)>> 0); }  #if 1 nvm_Data.config.page15.page15_U.C1E2.insSpd0KmCaliPrm_HB = 0xaa; nvm_Data.config.page15.page15_U.C1E2.insSpd0KmCaliPrm_LB = 0x55;  nvm_Data.config.page15.page15_U.C1E2.insSpd100KmCaliPrm_HB = 0xCC; nvm_Data.config.page15.page15_U.C1E2.insSpd100KmCaliPrm_LB = 0xAA;  nvm_Data.config.page15.page15_U.C1E2.insSpd220KmCaliPrm_HB = 0X55; nvm_Data.config.page15.page15_U.C1E2.insSpd220KmCaliPrm_LB = 0XCC; #endif   res = EED_ReadBytes(ADDR_DTC_PAGE0+0x00, nvm_Data.dtc.page0.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x10, nvm_Data.dtc.page1.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x20, nvm_Data.dtc.page2.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x30, nvm_Data.dtc.page3.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x40, nvm_Data.dtc.page4.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x50, nvm_Data.dtc.page5.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x60, nvm_Data.dtc.page6.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x70, nvm_Data.dtc.page7.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x80, nvm_Data.dtc.page8.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x90, nvm_Data.dtc.page9.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0xA0, nvm_Data.dtc.page10.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0xB0, nvm_Data.dtc.page11.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0xC0, nvm_Data.dtc.page12.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0xD0, nvm_Data.dtc.page13.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0xE0, nvm_Data.dtc.page14.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0xF0, nvm_Data.dtc.page15.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x100, nvm_Data.dtc.page16.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x110, nvm_Data.dtc.page17.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x120, nvm_Data.dtc.page18.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x130, nvm_Data.dtc.page19.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x140, nvm_Data.dtc.page20.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x150, nvm_Data.dtc.page21.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x160, nvm_Data.dtc.page22.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x170, nvm_Data.dtc.page23.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_DTC_PAGE0+0x180, nvm_Data.dtc.page24.buf, SIZE_NVM_PAGE);  for (i =0 ; i < 10; i ++) { res = EED_ReadBytes(ADDR_SNAPSHOT_PAGE0+ i *0x10, nvm_Data.snapshort[i].buf, SIZE_NVM_PAGE); }  res = EED_ReadBytes(ADDR_FUNCTION_PAGE0+0x00, nvm_Data.function.page0.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_FUNCTION_PAGE0+0x10, nvm_Data.function.page1.buf, SIZE_NVM_PAGE); chkSum = 0; for (i =0 ; i < 15; i ++) { chkSum += nvm_Data.function.page1.buf[i]; }  if(nvm_Data.function.page1.buf[15] != chkSum) { nvm_Data.function.page1.FunPage1_U.K_FullFuelConsumption = 66; nvm_Data.function.page1.FunPage1_U.K_RecentFuelConsumption = 66; nvm_Data.function.page1.FunPage1_U.K_OdometerSum = 0; nvm_Data.function.page1.FunPage1_U.K_FuelSum = 0; nvm_Data.function.page1.FunPage1_U.K_RangeToEmpty = 0; nvm_Data.function.page1.FunPage1_U.K_DisplayFuel = 2000; nvm_Data.function.page1.FunPage1_U.K_CompareFuel = 2000; } res = EED_ReadBytes(ADDR_FUNCTION_PAGE0+0x20, nvm_Data.function.odo[0].buf, SIZE_NVM_PAGE);  res = EED_ReadBytes(ADDR_FUNCTION_PAGE0+0x30, nvm_Data.function.odo[1].buf, SIZE_NVM_PAGE);  res = EED_ReadBytes(ADDR_FUNCTION_PAGE0+0x40, nvm_Data.function.odo[2].buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_FUNCTION_PAGE0+0x50, nvm_Data.function.odo[3].buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_FUNCTION_PAGE0+0x60, nvm_Data.function.odo[4].buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_FUNCTION_PAGE0+0x70, nvm_Data.function.angle.buf, SIZE_NVM_PAGE); res = EED_ReadBytes(ADDR_FUNCTION_PAGE0+0x80, nvm_Data.function.page8.buf, SIZE_NVM_PAGE); for (j =0; j <5; j ++)  {  for (i =0; i <15 ; i++)  { chkSum += nvm_Data.function.odo[j].buf[i]; } if(chkSum != nvm_Data.function.odo[j].buf[15]) { memset(nvm_Data.function.odo[j].buf,0,16); } chkSum = 0; }   nvm_InitSts = EED_GetInitStatus();   }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: NVM_Process_50ms nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: the process of the NVM module nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: none nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: NONE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ void NVM_Process_50ms(void) { NVMKeyBlock_ENUM index =INDEX_NVM_NONE; U8 i;  if (TRUE == nvm_InitSts) { if (nvm_WriteCmdCnt >0) { nvm_Busy = TRUE; index =nvm_WriteCmdBuf[0]; if (TRUE ==nvm_Write(index)) { nvm_WriteCmdCnt--; for (i =0; i <nvm_WriteCmdCnt; i++) { nvm_WriteCmdBuf[i] =nvm_WriteCmdBuf[i+1]; } } else { /*do nothing*/ } } else { nvm_Busy = FALSE; }  } else { /*do nothing*/ } }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: NVM_GetParas nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: Read the paras of NVM module nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: RET_FAIL RET_OK RET_INVALID nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/  U8 NVM_GetParas(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE;  U8 len = size; U8 buf[32] ={ 0};  U8 nvm_Res = RET_FAIL; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ив??? return*/  if (FALSE == nvm_InitSts) { nvm_Res = NVM_WR_DATAINVALID; } else if ( NULL_PTR == pRes) { nvm_Res = NVM_WR_DATAINVALID; } else { switch (nvm_datasts[index].sts) { case STS_ERR: nvm_Res = NVM_WR_EEDFLT; break;  case STS_WAIT: case STS_WRITE: nvm_Res = NVM_WR_ING; break;  case STS_IDLE: default: nvm_Res = NVM_WR_OK; switch (index) { case INDEX_NVM_AF00: case INDEX_NVM_AF01: case INDEX_NVM_AF02: res = nvm_SYS_GetPage0(index, pRes, size); break; case INDEX_NVM_AF03: case INDEX_NVM_D101: res = nvm_SYS_GetPage1(index, pRes, size); break; case INDEX_NVM_F100: if (NVM_LOGIST_F100_LEN == size) { memcpy(pRes, nvm_Data.logist.page0.data.F100, NVM_LOGIST_F100_LEN); res = TRUE; } else { } break; case INDEX_NVM_F110: if (NVM_LOGIST_F110_LEN == size) { memcpy(pRes, nvm_Data.logist.page1.F110, NVM_LOGIST_F110_LEN); res = TRUE; } else { } break; case INDEX_NVM_F111: if (NVM_LOGIST_F111_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F111, NVM_LOGIST_F111_LEN); res = TRUE; } else { } break; case INDEX_NVM_F112: if (NVM_LOGIST_F112_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F112, NVM_LOGIST_F112_LEN); res = TRUE; } else { } break; case INDEX_NVM_F113:  if (NVM_LOGIST_F113_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F113, NVM_LOGIST_F113_LEN); res = TRUE; } else { } break; case INDEX_NVM_F114: if (NVM_LOGIST_F114_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F114, NVM_LOGIST_F114_LEN); res = TRUE; } else { } break; case INDEX_NVM_F115: if (NVM_LOGIST_F115_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F115, NVM_LOGIST_F115_LEN); res = TRUE; } else { } break; case INDEX_NVM_F116: if (NVM_LOGIST_F116_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F116, NVM_LOGIST_F116_LEN); res = TRUE; } else { } break; case INDEX_NVM_F117: if (NVM_LOGIST_F117_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F117, NVM_LOGIST_F117_LEN); res = TRUE; } else { } break; case INDEX_NVM_F118: if (NVM_LOGIST_F118_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F118, NVM_LOGIST_F118_LEN); res = TRUE; } else { } break; case INDEX_NVM_F119: if (NVM_LOGIST_F119_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F119, NVM_LOGIST_F119_LEN); res = TRUE; } else { } break; case INDEX_NVM_F11A: if (NVM_LOGIST_F11A_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F11A, NVM_LOGIST_F11A_LEN); res = TRUE; } else { } break; case INDEX_NVM_F11B: if (NVM_LOGIST_F11B_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F11B, NVM_LOGIST_F11B_LEN); res = TRUE; } else { } break; case INDEX_NVM_F11C: if (NVM_LOGIST_F11C_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F11C, NVM_LOGIST_F11C_LEN); res = TRUE; } else { } break; case INDEX_NVM_F11D: if (NVM_LOGIST_F11D_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F11D, NVM_LOGIST_F11D_LEN); res = TRUE; } else { } break; case INDEX_NVM_F11E: if (NVM_LOGIST_F11E_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F11E, NVM_LOGIST_F11E_LEN); res = TRUE; } else { } break; case INDEX_NVM_F11F: if (NVM_LOGIST_F11F_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F11F, NVM_LOGIST_F11F_LEN); res = TRUE; } else { } break; case INDEX_NVM_F120: if (NVM_LOGIST_F120_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F120, NVM_LOGIST_F120_LEN); res = TRUE; } else { } break; case INDEX_NVM_F121: if (NVM_LOGIST_F121_LEN == size) { memcpy(pRes, nvm_Data.logist.flow1.data.F121, NVM_LOGIST_F121_LEN); res = TRUE; } else { } break; case INDEX_NVM_F187:  if (NVM_LOGIST_F187_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F187, NVM_LOGIST_F187_LEN); res = TRUE; } else { } break; case INDEX_NVM_F18A: if (NVM_LOGIST_F18A_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F18A, NVM_LOGIST_F18A_LEN); res = TRUE; } else { } break; case INDEX_NVM_F18B: if (NVM_LOGIST_F18B_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F18B, NVM_LOGIST_F18B_LEN); res = TRUE; } else { } break; case INDEX_NVM_F18C: if (NVM_LOGIST_F18C_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F18C, NVM_LOGIST_F18C_LEN); res = TRUE; } else { } break; case INDEX_NVM_F190: if (NVM_LOGIST_F190_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F190, NVM_LOGIST_F190_LEN); res = TRUE; } else { } break; case INDEX_NVM_F191: if (NVM_LOGIST_F191_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F191, NVM_LOGIST_F191_LEN); res = TRUE; } else { } break; case INDEX_NVM_F192: if (NVM_LOGIST_F192_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F192, NVM_LOGIST_F192_LEN); res = TRUE; } else { } break; case INDEX_NVM_F198: if (NVM_LOGIST_F198_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F198, NVM_LOGIST_F198_LEN); res = TRUE; } else { } break; case INDEX_NVM_F1A8: if (NVM_LOGIST_F1A8_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F1A8, NVM_LOGIST_F1A8_LEN); res = TRUE; } else { } break; case INDEX_NVM_F1A9: if (NVM_LOGIST_F1A9_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F1A9, NVM_LOGIST_F1A9_LEN); res = TRUE; } else { } break; case INDEX_NVM_F1AA:   if (NVM_LOGIST_F1AA_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.F1AA, NVM_LOGIST_F1AA_LEN); res = TRUE; } else { } break; case INDEX_NVM_AFFC: if (NVM_FBL_AFFC_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.AFFC, NVM_FBL_AFFC_LEN); res = TRUE; } else { } break; case INDEX_NVM_AFFD: if (NVM_FBL_AFFD_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.AFFD, NVM_FBL_AFFD_LEN); res = TRUE; } else { } break; case INDEX_NVM_AFFE: if (NVM_FBL_AFFE_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.AFFE, NVM_FBL_AFFE_LEN); res = TRUE; } else { } break; case INDEX_NVM_AFFF: if (NVM_FBL_AFFF_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.AFFF, NVM_FBL_AFFF_LEN); res = TRUE; } else { } break; case INDEX_NVM_ISPFLG: if (NVM_FBL_PJTENTRY_LEN == size) { memcpy(pRes, nvm_Data.logist.flow2.data.PrjEntry, NVM_FBL_PJTENTRY_LEN); res = TRUE; } else { } break;   case INDEX_NVM_C111: case INDEX_NVM_C112: res = nvm_CFG_GetPage0(index, pRes, size); break;  case INDEX_NVM_C113: case INDEX_NVM_C121: case INDEX_NVM_C122: res = nvm_CFG_GetPage1(index, pRes, size); break;  case INDEX_NVM_C131:/*yingying update*/ case INDEX_NVM_C141:/*yingying update*/ res = nvm_CFG_GetPage2(index, pRes, size); break;  case INDEX_NVM_C151: case INDEX_NVM_C164: res = nvm_CFG_GetPage3(index, pRes, size); break;  case INDEX_NVM_C165: case INDEX_NVM_C166: res = nvm_CFG_GetPage4(index, pRes, size); break;  case INDEX_NVM_C167: case INDEX_NVM_C171: res = nvm_CFG_GetPage5(index, pRes, size); break;  case INDEX_NVM_C172: case INDEX_NVM_C181: res = nvm_CFG_GetPage6(index, pRes, size); break;   case INDEX_NVM_C182: case INDEX_NVM_C191: res = nvm_CFG_GetPage7(index, pRes, size); break;  case INDEX_NVM_C192: case INDEX_NVM_C1A1: res = nvm_CFG_GetPage8(index, pRes, size); break;  case INDEX_NVM_C1B1: case INDEX_NVM_C1B2: res = nvm_CFG_GetPage9(index, pRes, size); break;  case INDEX_NVM_C1C1: case INDEX_NVM_C1C2: res = nvm_CFG_GetPage10(index, pRes, size); break;  case INDEX_NVM_C1C3: case INDEX_NVM_C1C4: res = nvm_CFG_GetPage11(index, pRes, size); break;  case INDEX_NVM_C1C5: case INDEX_NVM_C1C6: res = nvm_CFG_GetPage12(index, pRes, size); break;  case INDEX_NVM_C1C7: res = nvm_CFG_GetPage13(index, pRes, size); break; case INDEX_NVM_C1D1: case INDEX_NVM_C1E1: res = nvm_CFG_GetPage14(index, pRes, size); break; case INDEX_NVM_C1E2: /*RESERVE*/ res = nvm_CFG_GetPage15(index, pRes, size); break; case INDEX_NVM_0100: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page0.page0_U.dtc_0100,16); res = TRUE; } else { } break; case INDEX_NVM_DTC01: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page1.page1_U.dtc01,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC02: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page1.page1_U.dtc02,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC03: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page2.page2_U.dtc03,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC04: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page2.page2_U.dtc04,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC05: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page3.page3_U.dtc05,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC06: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page3.page3_U.dtc06,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC07: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page4.page4_U.dtc07,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC08: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page4.page4_U.dtc08,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC09: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page5.page5_U.dtc09,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC10: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page5.page5_U.dtc10,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC11: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page6.page6_U.dtc11,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC12: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page6.page6_U.dtc12,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC13: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page7.page7_U.dtc13,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC14: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page7.page7_U.dtc14,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC15: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page8.page8_U.dtc15,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC16: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page8.page8_U.dtc16,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC17: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page9.page9_U.dtc17,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC18: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page9.page9_U.dtc18,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC19: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page10.page10_U.dtc19,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC20: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page10.page10_U.dtc20,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC21: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page11.page11_U.dtc21,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC22: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page11.page11_U.dtc22,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC23: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page12.page12_U.dtc23,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC24: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page12.page12_U.dtc24,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC25: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page13.page13_U.dtc25,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC26: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page13.page13_U.dtc26,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC27: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page14.page14_U.dtc27,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC28: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page14.page14_U.dtc28,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC29: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page15.page15_U.dtc29,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC30: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page15.page15_U.dtc30,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC31: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page16.page16_U.dtc31,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC32: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page16.page16_U.dtc32,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC33: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page17.page17_U.dtc33,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC34: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page18.page18_U.dtc34,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC35: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page19.page19_U.dtc35,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC36: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page20.page20_U.dtc36,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC37: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page21.page21_U.dtc37,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC38: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page22.page22_U.dtc38,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_DTC39: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.dtc.page23.page23_U.dtc39,nvm_WriteMatrix[index].size); res = TRUE; } else { } break; case INDEX_NVM_SNAPSHORT01: if (nvm_WriteMatrix[index].size >= size) { memcpy(pRes, nvm_Data.snapshort[0].buf,size /*nvm_WriteMatrix[index].size */); res = TRUE; } else { }  break; case INDEX_NVM_SNAPSHORT02: if (nvm_WriteMatrix[index].size >= size) { memcpy(pRes, nvm_Data.snapshort[1].buf,size/*nvm_WriteMatrix[index].size*/); res = TRUE; } else { }  break; case INDEX_NVM_SNAPSHORT03: if (nvm_WriteMatrix[index].size >= size) { memcpy(pRes, nvm_Data.snapshort[2].buf,size/*nvm_WriteMatrix[index].size*/); res = TRUE; } else { }  break; case INDEX_NVM_SNAPSHORT04: if (nvm_WriteMatrix[index].size >= size) { memcpy(pRes, nvm_Data.snapshort[3].buf,size/*nvm_WriteMatrix[index].size*/); res = TRUE; } else { }  break; case INDEX_NVM_SNAPSHORT05: if (nvm_WriteMatrix[index].size >= size) { memcpy(pRes, nvm_Data.snapshort[4].buf,size/*nvm_WriteMatrix[index].size*/); res = TRUE; } else { }  break; case INDEX_NVM_SNAPSHORT06: if (nvm_WriteMatrix[index].size == size) { memcpy(pRes, nvm_Data.snapshort[5].buf,size/*nvm_WriteMatrix[index].size*/); res = TRUE; } else { }  break; case INDEX_NVM_SNAPSHORT07: if (nvm_WriteMatrix[index].size >= size) { memcpy(pRes, nvm_Data.snapshort[6].buf,size/*nvm_WriteMatrix[index].size*/); res = TRUE; } else { }  break; case INDEX_NVM_SNAPSHORT08: if (nvm_WriteMatrix[index].size >= size) { memcpy(pRes, nvm_Data.snapshort[7].buf,size/*nvm_WriteMatrix[index].size*/); res = TRUE; } else { }  break; case INDEX_NVM_SNAPSHORT09: if (nvm_WriteMatrix[index].size >= size) { memcpy(pRes, nvm_Data.snapshort[8].buf,size/*nvm_WriteMatrix[index].size*/); res = TRUE; } else { }  break; case INDEX_NVM_SNAPSHORT10: if (nvm_WriteMatrix[index].size >= size) { memcpy(pRes, nvm_Data.snapshort[9].buf,size/*nvm_WriteMatrix[index].size*/); res = TRUE; } else { }  break;  case INDEX_NVM_B102: case INDEX_NVM_B111: case INDEX_NVM_E102: case INDEX_NVM_E103: case INDEX_NVM_E104: case INDEX_NVM_E105: case INDEX_NVM_Y_SIAODOPRIY: res = nvm_Function_GetPage0(index, pRes, size); break; case INDEX_NVM_K_COMPAREFUEL: case INDEX_NVM_K_DISPLAYFUEL: case INDEX_NVM_K_RANGETOEMPTY: case INDEX_NVM_K_FULLFUELCOMSUMPTION: case INDEX_NVM_K_RECENTFUELCONSUMPTION: case INDEX_NVM_K_ODOMETERSUM: case INDEX_NVM_K_FUELSUM: case INDEX_NVM_Y_LASTDISTANCECNT: res = nvm_Function_GetPage1(index, pRes, size); break; case INDEX_NVM_ODO0: /*RESERVE*/ case INDEX_NVM_ODO1: /*RESERVE*/ case INDEX_NVM_ODO2: /*RESERVE*/ case INDEX_NVM_ODO3: /*RESERVE*/ case INDEX_NVM_ODO4: res = nvm_Function_GetPageODO(index, pRes, size); break; case INDEX_NVM_Y_ANGLEOFFSET: case INDEX_NVM_ESUM_FUEL: case INDEX_NVM_ESUM2_FUEL: case INDEX_NVM_WRT_181B: case INDEX_NVM_WRT_181C: case INDEX_NVM_SAFAIL_CNT: case INDEX_NVM_WRT_1890: res = nvm_Function_GetPage7(index, pRes, size); break;  case INDEX_NVM_B112: res = nvm_Function_GetPage8(index, pRes, size); break;  case INDEX_NVM_RUNKEEP: res = nvm_Function_GetPage8(index, pRes, size); break;  default: break; } break; }   } return nvm_Res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: NVM_SetParas nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: Write a paras for nvm nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : set the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: RET_FAIL RET_OK RET_INVALID nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ U8 NVM_SetParas(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 i = 0;  U8 res = NVM_WR_OK;  if (FALSE == nvm_InitSts) { res = NVM_WR_DATAINVALID; } else if ( (NULL_PTR == pRes) || (nvm_WriteCmdCnt >= INDEX_NVM_ALL)) { res = NVM_WR_DATAINVALID; } else { }  if((STS_IDLE == nvm_datasts[index].sts) || (STS_WAIT== nvm_datasts[index].sts) ||(STS_ERR== nvm_datasts[index].sts)) {  //nvm_datasts[index].sts = STS_WAIT; res = nvm_Update(index, pRes, size); if(FALSE != res) /*IF DATA IS DIFFERENT*/ { for (i = 0; i < nvm_WriteCmdCnt; i++) { if (nvm_WriteCmdBuf[i] == index) { break; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr do nothing */ } }  if (i == nvm_WriteCmdCnt) { nvm_WriteCmdBuf[nvm_WriteCmdCnt++] = index; } else { nvm_WriteCmdBuf[i] = index; }  if(STS_ERR == nvm_datasts[index].sts) { res = NVM_WR_ERR_PRIVIOUS; } else { res = NVM_WR_ING; } nvm_datasts[index].sts = STS_WAIT; } else { res = NVM_WR_OK; } } else/* nvm is writing a data*/ { res = NVM_WR_ING; } return res; }   U8 NVM_GetWriteResult(NVMKeyBlock_ENUM index, PU8 pRes) { U8 i = 0;  U8 res = RET_FAIL;  if (FALSE == nvm_InitSts) { res = RET_FAIL; } else if (NULL_PTR == pRes) { res = RET_INVALID; } else { *pRes =nvm_datasts[index].sts; res = RET_OK; }   return res; }   U8 NVM_GetWorkSts(void) { return nvm_Busy; }  U8 NVM_SetIspFlag(void) { U8 buffer[8]; nvm_Data.logist.flow2.data.PrjEntry[0] = 0x01; EED_WriteBytes(0X2A0, nvm_Data.logist.flow2.buf[8], SIZE_NVM_PAGE); EED_ReadBytes(0X2A0,buffer,8); return TRUE; }    /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_Write nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: write the value to the nvm nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input : index: the index of NVMKeyBlock_ENUM nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns:TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_Write(NVMKeyBlock_ENUM index) { U8 res = TRUE;  switch (nvm_W_Data.Step)  { case 0x02: if (nvm_W_Data.EndByte >0) /*╫ю║є╥╗╥│╩г╧┬╫╓╜┌╩¤*/ { res =EED_WriteBytes(nvm_W_Data.PageAddr, nvm_WriteMatrix[index].pValue+nvm_W_Data.ofs, SIZE_NVM_PAGE); } else { }  if (res ==TRUE) { nvm_W_Data.Error=0; nvm_W_Data.Step =0x00; nvm_datasts[index].sts = STS_IDLE; } else { if (++nvm_W_Data.Error>3) { nvm_W_Data.Step=0X00; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr EED╣╩╒╧*/ nvm_datasts[index].sts = STS_ERR; } else { } } break;  case 0x01: if (nvm_W_Data.PageNum >0) /*╩г╧┬═ъ╒√╥│*/ { res =EED_WriteBytes(nvm_W_Data.PageAddr, nvm_WriteMatrix[index].pValue+nvm_W_Data.ofs, SIZE_NVM_PAGE); if (res ==TRUE) { nvm_W_Data.PageNum--; nvm_W_Data.PageAddr +=SIZE_NVM_PAGE; nvm_W_Data.ofs +=SIZE_NVM_PAGE;  } else { } } else { }  if (res ==TRUE) { nvm_W_Data.Error=0; if (nvm_W_Data.PageNum ==0) { if (nvm_W_Data.EndByte >0) { nvm_W_Data.Step=0x02; } else { nvm_W_Data.Step=0x00; nvm_datasts[index].sts = STS_IDLE; } } else { } } else { if (++nvm_W_Data.Error>3) { nvm_W_Data.Step=0X00; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr EED╣╩╒╧*/ nvm_datasts[index].sts = STS_ERR; } else { } } break;  case 0x00: default: nvm_datasts[index].sts = STS_WRITE; nvm_W_Data.ofs =0;  nvm_W_Data.PageAddr =nvm_WriteMatrix[index].addr;  nvm_W_Data.FirstByte =SIZE_NVM_PAGE -(nvm_WriteMatrix[index].offset%SIZE_NVM_PAGE); if (nvm_WriteMatrix[index].size >nvm_W_Data.FirstByte)  { nvm_W_Data.PageNum =(nvm_WriteMatrix[index].size -nvm_W_Data.FirstByte)/SIZE_NVM_PAGE; nvm_W_Data.EndByte =(nvm_WriteMatrix[index].size -nvm_W_Data.FirstByte)%SIZE_NVM_PAGE; } else { nvm_W_Data.PageNum =0; nvm_W_Data.EndByte =0; }  res =EED_WriteBytes(nvm_W_Data.PageAddr, nvm_WriteMatrix[index].pValue+nvm_W_Data.ofs, SIZE_NVM_PAGE); if (res == TRUE) {   nvm_W_Data.Error=0; if (nvm_WriteMatrix[index].size >nvm_W_Data.FirstByte)  { nvm_W_Data.PageAddr +=SIZE_NVM_PAGE; nvm_W_Data.ofs +=SIZE_NVM_PAGE;  if (nvm_W_Data.PageNum >0) { nvm_W_Data.Step=0x01; } else { nvm_W_Data.Step=0x02; } } else { nvm_datasts[index].sts = STS_IDLE; } } else { if (++nvm_W_Data.Error>3) { nvm_datasts[index].sts = STS_ERR; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr EED╣╩╒╧*/ } else { } } break; }  if (0==nvm_W_Data.Step) { res =TRUE; } else { res =FALSE; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_UpdateData nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: update the data of the NVM nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns:TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_Update(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 i = 0;  U8 buf[32] ={ 0};  S32 res = FALSE;   if(NULL_PTR == pRes) { res = FALSE; } else { switch (index) { case INDEX_NVM_F18B: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.logist.flow2.data.F18B, pRes, size); if(FALSE != res) { memcpy(nvm_Data.logist.flow2.data.F18B, pRes, size); } else { }  } else { } break;  case INDEX_NVM_F18C: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.logist.flow2.data.F18C, pRes, size); if(FALSE != res) { memcpy(nvm_Data.logist.flow2.data.F18C, pRes, size); } else { }  } else { } break;   case INDEX_NVM_F190: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.logist.flow2.data.F190, pRes, size); if(FALSE != res) { memcpy(nvm_Data.logist.flow2.data.F190, pRes, size); } else { }  } else { } break;  case INDEX_NVM_F198: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.logist.flow2.data.F198, pRes, size); if(FALSE != res) { memcpy(nvm_Data.logist.flow2.data.F198, pRes, size); } else { }  } else { } break;  case INDEX_NVM_F1A8: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.logist.flow2.data.F1A8, pRes, size); if(FALSE != res) { memcpy(nvm_Data.logist.flow2.data.F1A8, pRes, size); } else { }  } else { } break;  case INDEX_NVM_F1A9: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.logist.flow2.data.F1A9, pRes, size); if(FALSE != res) { memcpy(nvm_Data.logist.flow2.data.F1A9, pRes, size); } else { }  } else { } break;  case INDEX_NVM_AFFC: case INDEX_NVM_AFFD: case INDEX_NVM_AFFE: case INDEX_NVM_AFFF: case INDEX_NVM_ISPFLG: break;  case INDEX_NVM_C111: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page0.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page0.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C112: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page0.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page0.page+nvm_WriteMatrix[index].offset, pRes, size);  } else { }  } else { } break; case INDEX_NVM_C113: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page1.page, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page1.page, pRes, size); } else { } } else { } break; case INDEX_NVM_C121: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page1.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page1.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C122: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page1.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page1.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C131: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page2.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page2.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C141: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page2.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page2.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C151: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page3.page, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page3.page, pRes, size); } else { } } else { } break; case INDEX_NVM_C164: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page3.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page3.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C165: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page4.page, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page4.page, pRes, size); } else { } } else { } break; case INDEX_NVM_C166: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page4.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page4.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C167: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page5.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page5.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C171: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page5.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page5.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C172: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page6.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page6.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C181: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page6.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page6.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C182: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page7.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page7.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C191: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page7.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) {  memcpy(nvm_Data.config.page7.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C192: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page8.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page8.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1A1: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page8.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page8.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1B1: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page9.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page9.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1B2: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page9.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page9.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1C1: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page10.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page10.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1C2: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page10.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page10.page + nvm_WriteMatrix[index].offset, pRes, size); } else { }  } else { } break; case INDEX_NVM_C1C3: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page11.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page11.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1C4: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page11.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page11.page + nvm_WriteMatrix[index].offset, pRes, size); } else { }  } else { } break; case INDEX_NVM_C1C5: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page12.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page12.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1C6: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page12.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page12.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1C7: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page13.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page13.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1C8: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page13.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page13.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1D1: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page14.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page14.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1E1: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page14.page + nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page14.page + nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_C1E2: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.config.page15.page+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.config.page15.page+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break;  case INDEX_NVM_0100: if (nvm_WriteMatrix[index].size == size) { res = memcmp(nvm_Data.dtc.page0.buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page0.buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_DTC01: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page1.page1_U.dtc01+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page1.page1_U.dtc01+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break;  case INDEX_NVM_DTC02: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page1.page1_U.dtc02+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page1.page1_U.dtc01+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break;   case INDEX_NVM_DTC03: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page2.page2_U.dtc03+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page2.page2_U.dtc03+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC04: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page2.page2_U.dtc04+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page2.page2_U.dtc04+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC05: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page3.page3_U.dtc05+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page3.page3_U.dtc05+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC06: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page3.page3_U.dtc06+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page3.page3_U.dtc06+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC07: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page4.page4_U.dtc07+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page4.page4_U.dtc07+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC08: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page4.page4_U.dtc08+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page4.page4_U.dtc08+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { } break; case INDEX_NVM_DTC09: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page5.page5_U.dtc09+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page5.page5_U.dtc09+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC10: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page5.page5_U.dtc10+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page5.page5_U.dtc10+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC11: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page6.page6_U.dtc11+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page6.page6_U.dtc11+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC12: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page6.page6_U.dtc12+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page6.page6_U.dtc12+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC13: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page7.page7_U.dtc13+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page7.page7_U.dtc13+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC14: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page7.page7_U.dtc14+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page7.page7_U.dtc14+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC15: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page8.page8_U.dtc15+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page8.page8_U.dtc15+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC16: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page8.page8_U.dtc16+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page8.page8_U.dtc16+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC17: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page9.page9_U.dtc17+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page9.page9_U.dtc17+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC18: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page9.page9_U.dtc18+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page9.page9_U.dtc18+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC19: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page10.page10_U.dtc19+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page10.page10_U.dtc19+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC20: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page10.page10_U.dtc20+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page10.page10_U.dtc20+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC21: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page11.page11_U.dtc21+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page11.page11_U.dtc21+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC22: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page11.page11_U.dtc22+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page11.page11_U.dtc22+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC23: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page12.page12_U.dtc23+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page12.page12_U.dtc23+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } break; case INDEX_NVM_DTC24: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page12.page12_U.dtc24+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page12.page12_U.dtc24+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC25: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page13.page13_U.dtc25+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page13.page13_U.dtc25+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC26: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page13.page13_U.dtc26+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page13.page13_U.dtc26+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC27: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page14.page14_U.dtc27+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page14.page14_U.dtc27+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC28: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page14.page14_U.dtc28+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page14.page14_U.dtc28+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC29: if (nvm_WriteMatrix[index].size >=size) { res = memcmp(nvm_Data.dtc.page15.page15_U.dtc29+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page15.page15_U.dtc29+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC30: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page15.page15_U.dtc30+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page15.page15_U.dtc30+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC31: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page16.page16_U.dtc31+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page16.page16_U.dtc31+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC32: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page16.page16_U.dtc32+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page16.page16_U.dtc32+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC33: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page17.page17_U.dtc33+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page17.page17_U.dtc33+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC34: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page18.page18_U.dtc34+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page18.page18_U.dtc34+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC35: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page19.page19_U.dtc35+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page19.page19_U.dtc35+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC36: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page20.page20_U.dtc36+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page20.page20_U.dtc36+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC37: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page21.page21_U.dtc37+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page21.page21_U.dtc37+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC38: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page22.page22_U.dtc38+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page22.page22_U.dtc38+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_DTC39: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.dtc.page23.page23_U.dtc39+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.dtc.page23.page23_U.dtc39+ nvm_WriteMatrix[index].offset, pRes, size); } else { } res = TRUE; } else { } break; case INDEX_NVM_SNAPSHORT01: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.snapshort[0].buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.snapshort[0].buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { }  break; case INDEX_NVM_SNAPSHORT02: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.snapshort[1].buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.snapshort[1].buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { }  break; case INDEX_NVM_SNAPSHORT03: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.snapshort[2].buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.snapshort[2].buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { }  break; case INDEX_NVM_SNAPSHORT04: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.snapshort[3].buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.snapshort[3].buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { }  break; case INDEX_NVM_SNAPSHORT05: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.snapshort[4].buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.snapshort[4].buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { }  break; case INDEX_NVM_SNAPSHORT06: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.snapshort[5].buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.snapshort[5].buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { }  break;  case INDEX_NVM_SNAPSHORT07: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.snapshort[6].buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.snapshort[6].buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { }  break;  case INDEX_NVM_SNAPSHORT08: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.snapshort[7].buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.snapshort[7].buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { }  break;  case INDEX_NVM_SNAPSHORT09: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.snapshort[8].buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.snapshort[8].buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { }  break;  case INDEX_NVM_SNAPSHORT10: if (nvm_WriteMatrix[index].size >= size) { res = memcmp(nvm_Data.snapshort[9].buf+ nvm_WriteMatrix[index].offset, pRes, size); if(FALSE != res) { memcpy(nvm_Data.snapshort[9].buf+ nvm_WriteMatrix[index].offset, pRes, size); } else { } } else { }  break;  /*RESERVE DTC AND SNAPSHOT*/ case INDEX_NVM_B102: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page0.FunPage0_U.B102), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page0.FunPage0_U.B102), pRes, size); nvm_Data.function.page0.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page0.buf, SIZE_NVM_PAGE-1); } else { } } else { } break; case INDEX_NVM_B111: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page0.FunPage0_U.B111), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page0.FunPage0_U.B111), pRes, size); nvm_Data.function.page0.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page0.buf, SIZE_NVM_PAGE-1); } else { } } else { } break; case INDEX_NVM_E102: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page0.FunPage0_U.E102), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page0.FunPage0_U.E102), pRes, size); nvm_Data.function.page0.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page0.buf, SIZE_NVM_PAGE-1); } else { }  } else { } break;  case INDEX_NVM_E103: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page0.FunPage0_U.E103), pRes, size); if(FALSE != res) {  memcpy(&(nvm_Data.function.page0.FunPage0_U.E103), pRes, size); nvm_Data.function.page0.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page0.buf, SIZE_NVM_PAGE-1); } else { }  } else { } break;  case INDEX_NVM_E104: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page0.FunPage0_U.E104), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page0.FunPage0_U.E104), pRes, size); nvm_Data.function.page0.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page0.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_E105: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page0.FunPage0_U.E105), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page0.FunPage0_U.E105), pRes, size); nvm_Data.function.page0.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page0.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_Y_SIAODOPRIY: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page0.FunPage0_U.SIAOdoPriy), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page0.FunPage0_U.SIAOdoPriy), pRes, size); nvm_Data.function.page0.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page0.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_K_COMPAREFUEL: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page1.FunPage1_U.K_CompareFuel), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page1.FunPage1_U.K_CompareFuel), pRes, size); nvm_Data.function.page1.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page1.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_K_DISPLAYFUEL: if (nvm_WriteMatrix[index].size == size) {  res = memcmp(&(nvm_Data.function.page1.FunPage1_U.K_DisplayFuel), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page1.FunPage1_U.K_DisplayFuel), pRes, size); nvm_Data.function.page1.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page1.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_K_RANGETOEMPTY: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page1.FunPage1_U.K_RangeToEmpty), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page1.FunPage1_U.K_RangeToEmpty), pRes, size); nvm_Data.function.page1.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page1.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_K_FULLFUELCOMSUMPTION: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page1.FunPage1_U.K_FullFuelConsumption), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page1.FunPage1_U.K_FullFuelConsumption), pRes, size); nvm_Data.function.page1.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page1.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_K_RECENTFUELCONSUMPTION: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page1.FunPage1_U.K_RecentFuelConsumption), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page1.FunPage1_U.K_RecentFuelConsumption), pRes, size); nvm_Data.function.page1.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page1.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_K_ODOMETERSUM: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page1.FunPage1_U.K_OdometerSum), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page1.FunPage1_U.K_OdometerSum), pRes, size); nvm_Data.function.page1.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page1.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_K_FUELSUM: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page1.FunPage1_U.K_FuelSum), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page1.FunPage1_U.K_FuelSum), pRes, size); nvm_Data.function.page1.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page1.buf, SIZE_NVM_PAGE-1); } else { } } else { } break; case INDEX_NVM_Y_LASTDISTANCECNT: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page1.FunPage1_U.lastDistanceCnt), pRes, size); if(FALSE != res) { memcpy(&(nvm_Data.function.page1.FunPage1_U.lastDistanceCnt), pRes, size);  nvm_Data.function.page1.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page1.buf, SIZE_NVM_PAGE-1); } else { } } else { }  break;  case INDEX_NVM_ODO0: case INDEX_NVM_ODO1: case INDEX_NVM_ODO2: case INDEX_NVM_ODO3: case INDEX_NVM_ODO4: if (nvm_WriteMatrix[index].size == size) { //res = memcmp(&(nvm_Data.function.odo[index-INDEX_NVM_ODO0].Funodo_U.B101),pRes,size);  // if(FALSE != res) // { memcpy(&(nvm_Data.function.odo[index-INDEX_NVM_ODO0].Funodo_U.B101),pRes,size); nvm_Data.function.odo[index-INDEX_NVM_ODO0].buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.odo[index-INDEX_NVM_ODO0].buf, SIZE_NVM_PAGE-1); res = TRUE; // } // else // { // } } else { } break;  case INDEX_NVM_Y_ANGLEOFFSET: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.angle.FunPage7_U.AngleOffset),pRes,size); if(FALSE != res) { memcpy(&(nvm_Data.function.angle.FunPage7_U.AngleOffset),pRes,size); nvm_Data.function.angle.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.angle.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_ESUM_FUEL: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.angle.FunPage7_U.e_sum_fuel),pRes,size); if(FALSE != res) { memcpy(&(nvm_Data.function.angle.FunPage7_U.e_sum_fuel),pRes,size); nvm_Data.function.angle.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.angle.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_ESUM2_FUEL: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.angle.FunPage7_U.e_sum2_fuel),pRes,size); if(FALSE != res) { memcpy(&(nvm_Data.function.angle.FunPage7_U.e_sum2_fuel),pRes,size); nvm_Data.function.angle.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.angle.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_WRT_181B: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.angle.FunPage7_U.F18B_WRCNT),pRes,size); if(FALSE != res) { memcpy(&(nvm_Data.function.angle.FunPage7_U.F18B_WRCNT),pRes,size); nvm_Data.function.angle.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.angle.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_WRT_181C: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.angle.FunPage7_U.F18C_WRCNT),pRes,size); if(FALSE != res) { memcpy(&(nvm_Data.function.angle.FunPage7_U.F18C_WRCNT),pRes,size); nvm_Data.function.angle.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.angle.buf, SIZE_NVM_PAGE-1); } else { }  } else { } break;  case INDEX_NVM_SAFAIL_CNT: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.angle.FunPage7_U.SA_FailCnt),pRes,size); if(FALSE != res) { memcpy(&(nvm_Data.function.angle.FunPage7_U.SA_FailCnt),pRes,size); nvm_Data.function.angle.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.angle.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;   case INDEX_NVM_WRT_1890: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.angle.FunPage7_U.F190_WRCNT),pRes,size); if(FALSE != res) { memcpy(&(nvm_Data.function.angle.FunPage7_U.F190_WRCNT),pRes,size); nvm_Data.function.angle.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.angle.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_B112: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page8.FunPage8_U.pmOperationMode),pRes,size); if(FALSE != res) { memcpy(&(nvm_Data.function.page8.FunPage8_U.pmOperationMode),pRes,size); nvm_Data.function.page8.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page8.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;  case INDEX_NVM_RUNKEEP: if (nvm_WriteMatrix[index].size == size) { res = memcmp(&(nvm_Data.function.page8.FunPage8_U.runkeep),pRes,size); if(FALSE != res) { memcpy(&(nvm_Data.function.page8.FunPage8_U.runkeep),pRes,size); nvm_Data.function.page8.buf[SIZE_NVM_PAGE-1] = nvm_CalCheckSum(nvm_Data.function.page8.buf, SIZE_NVM_PAGE-1); } else { } } else { } break;   } }  return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_sys_Get_page0 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE0 in sys nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_SYS_GetPage0(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_AF00: if (NVM_SYS0_AF00_LEN == size) { memcpy(pRes, nvm_Data.page0.data.AF00, NVM_SYS0_AF00_LEN); res = TRUE; } else { } break;  case INDEX_NVM_AF01: if (NVM_SYS0_AF01_LEN == size) { memcpy(pRes, nvm_Data.page0.data.AF01, NVM_SYS0_AF01_LEN); res = TRUE; } else { } break;  case INDEX_NVM_AF02: if (NVM_SYS0_AF02_LEN == size) { memcpy(pRes, nvm_Data.page0.data.AF02, NVM_SYS0_AF02_LEN); res = TRUE; } else { } break; default: break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_sys_Get_page1 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE1 in sys nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_SYS_GetPage1(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_AF03: if (NVM_SYS1_AF03_LEN == size) { memcpy(pRes, nvm_Data.page1.data.AF03, NVM_SYS1_AF03_LEN); res = TRUE; } else { } break; case INDEX_NVM_D101: if (NVM_SYS1_D101_LEN == size) { memcpy(pRes, nvm_Data.page1.data.D101, NVM_SYS1_D101_LEN); res = TRUE; } else { } break; default: break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_cfg_Get_page0 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: index,pRes,size nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: none nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage0(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C111: if (8 == size) { memcpy(pRes, nvm_Data.config.page0.page, 8); res = TRUE; } else { } break;  case INDEX_NVM_C112: if (8 == size) { memcpy(pRes, nvm_Data.config.page0.page+NVM_CFG_DID_LEN8, 8); res = TRUE; } else { } break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage1 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE1 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage1(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C113: if (8 == size) { memcpy(pRes, nvm_Data.config.page1.page, 8); res = TRUE; } else { } break; case INDEX_NVM_C121: if (4 == size) { memcpy(pRes, nvm_Data.config.page1.page+8, 4); res = TRUE; } else { } break;  case INDEX_NVM_C122: if (4 == size) { memcpy(pRes, nvm_Data.config.page1.page+12, 4); res = TRUE; } else { }  break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage2 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE2 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage2(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C131: if (4 == size) { memcpy(pRes, nvm_Data.config.page2.page, 4); res = TRUE; } else { } break;  case INDEX_NVM_C141: if (8 == size) { memcpy(pRes, nvm_Data.config.page2.page+8, 8); res = TRUE; } else { } break;  } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage3 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE3 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage3(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C151: if (8 == size) { memcpy(pRes, nvm_Data.config.page3.page, 8); res = TRUE; } else { } break;  case INDEX_NVM_C164: if (8 == size) { memcpy(pRes, nvm_Data.config.page3.page+8, 8); res = TRUE; } else { } break;  } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage4 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE4 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage4(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C165: if (8 == size) { memcpy(pRes, nvm_Data.config.page4.page, 8); res = TRUE; } else { } break;  case INDEX_NVM_C166: if (8 == size) { memcpy(pRes, nvm_Data.config.page4.page+8, 8); res = TRUE; } else { } break;  } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage5 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE5 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage5(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C167: if (8 == size) { memcpy(pRes, nvm_Data.config.page5.page, 8); res = TRUE; } else { } break;  case INDEX_NVM_C171: if (8 == size) { memcpy(pRes, nvm_Data.config.page5.page+8, 8); res = TRUE; } else { } break;  } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage6 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE6 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage6(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C172: if (4 == size) { memcpy(pRes, nvm_Data.config.page6.page, 4); res = TRUE; } else { } break;  case INDEX_NVM_C181: if (8 == size) { memcpy(pRes, nvm_Data.config.page6.page+8, 8); res = TRUE; } else { } break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage7 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE7 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage7(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C182: if (8 == size) { memcpy(pRes, nvm_Data.config.page7.page, 8); res = TRUE; } else { } break;  case INDEX_NVM_C191: if (8 == size) { memcpy(pRes, nvm_Data.config.page7.page+8, 8); res = TRUE; } else { } break;  } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage8 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE8 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage8(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C192: if (8 == size) { memcpy(pRes, nvm_Data.config.page8.page, 8); res = TRUE; } else { } break;  case INDEX_NVM_C1A1: if (8 == size) { memcpy(pRes, nvm_Data.config.page8.page+8, 8); res = TRUE; } else { } break;  } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage9 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE9 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage9(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C1B1: if (8 == size) { memcpy(pRes, nvm_Data.config.page9.page, 8); res = TRUE; } else { } break;  case INDEX_NVM_C1B2: if (8 == size) { memcpy(pRes, nvm_Data.config.page9.page+8, 8); res = TRUE; } else { } break; /*RESERVE*/ } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage10 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE10 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage10(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C1C1: if (8 == size) { memcpy(pRes, nvm_Data.config.page10.page, 8); res = TRUE; } else { } break; case INDEX_NVM_C1C2: if (8 == size) { memcpy(pRes, nvm_Data.config.page10.page+8, 8); res = TRUE; } else { } break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage11 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE11 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage11(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C1C3: if (8 == size) { memcpy(pRes, nvm_Data.config.page11.page, 8); res = TRUE; } else { } break; case INDEX_NVM_C1C4: if (8 == size) { memcpy(pRes, nvm_Data.config.page11.page+8, 8); res = TRUE; } else { } break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage12 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE12 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage12(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C1C5: if (8 == size) { memcpy(pRes, nvm_Data.config.page12.page, 8); res = TRUE; } else { } break;  case INDEX_NVM_C1C6: if (8 == size) { memcpy(pRes, nvm_Data.config.page12.page+8, 8); res = TRUE; } else { } break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage13 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE13 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage13(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C1C7: if (8 == size) { memcpy(pRes, nvm_Data.config.page13.page, 8); res = TRUE; } else { } break; case INDEX_NVM_C1C8: if (8 == size) { memcpy(pRes, nvm_Data.config.page13.page+8, 8); res = TRUE; } else { } break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage14 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE14 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage14(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C1D1: if (8 == size) { memcpy(pRes, nvm_Data.config.page14.page, 8); res = TRUE; } else { } break;  case INDEX_NVM_C1E1: if (8 == size) { memcpy(pRes, nvm_Data.config.page14.page+8, 8); res = TRUE; } else { } break;  /*RESERVE*/ } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CFG_GetPage15 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: get the value of PAGE15 in config nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: TRUE or FALSE nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CFG_GetPage15(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = FALSE; switch (index) { case INDEX_NVM_C1E2: if (8 == size) { memcpy(pRes, nvm_Data.config.page15.page,size); res = TRUE; } else { } break; default: if (NVM_CFG_PAGE_LEN == size) { memcpy(pRes, nvm_Data.config.page15.page, NVM_CFG_PAGE_LEN*SIZE_NVM_PAGE); res = TRUE; } else { } break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_function_Get_page0 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: read Parameters of page0 in function nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: true or false nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_Function_GetPage0(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = TRUE;  switch (index) { case INDEX_NVM_B102: if (3 == size) { memcpy(pRes,&( nvm_Data.function.page0.FunPage0_U.B102), 3); } else { res = FALSE; }  break; case INDEX_NVM_B111: if (3 == size) { memcpy(pRes, &(nvm_Data.function.page0.FunPage0_U.B111), 3); } else { res = FALSE; }  break; case INDEX_NVM_E102: if (2 == size) { memcpy(pRes, &(nvm_Data.function.page0.FunPage0_U.E102), 2); } else { res = FALSE; }  break; case INDEX_NVM_E103: if (1 == size) { *pRes = nvm_Data.function.page0.FunPage0_U.E103; } else { res = FALSE; }  break; case INDEX_NVM_E104: if (2 == size) { *pRes = nvm_Data.function.page0.FunPage0_U.E104; } else { res = FALSE; }  break; case INDEX_NVM_E105: if (1 == size) { *pRes = nvm_Data.function.page0.FunPage0_U.E105; } else { res = FALSE; }  break; case INDEX_NVM_Y_SIAODOPRIY: if (3 == size) { memcpy(pRes, &(nvm_Data.function.page0.FunPage0_U.SIAOdoPriy), 3); } else { res = FALSE; }  break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_function_Get_page1_U nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: read Parameters of page1 in function nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para  nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: True or False nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_Function_GetPage1(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = TRUE;  switch (index) {  case INDEX_NVM_K_COMPAREFUEL: if (2 == size) { memcpy(pRes, &(nvm_Data.function.page1.FunPage1_U.K_CompareFuel), 2); } else { res = FALSE; }  break; case INDEX_NVM_K_DISPLAYFUEL: if (2 == size) { memcpy(pRes,&( nvm_Data.function.page1.FunPage1_U.K_DisplayFuel), 2); } else { res = FALSE; }  break; case INDEX_NVM_K_RANGETOEMPTY: if (4 == size) { memcpy(pRes, &(nvm_Data.function.page1.FunPage1_U.K_RangeToEmpty), 4); } else { res = FALSE; }  break; case INDEX_NVM_K_FULLFUELCOMSUMPTION: if (1 == size) { memcpy(pRes, &(nvm_Data.function.page1.FunPage1_U.K_FullFuelConsumption), 1); } else { res = FALSE; }  break; case INDEX_NVM_K_RECENTFUELCONSUMPTION: if (1 == size) { memcpy(pRes, &(nvm_Data.function.page1.FunPage1_U.K_RecentFuelConsumption), 1); } else { res = FALSE; }  break; case INDEX_NVM_K_ODOMETERSUM: if (1 == size) { memcpy(pRes, &(nvm_Data.function.page1.FunPage1_U.K_OdometerSum), 1); } else { res = FALSE; }  break; case INDEX_NVM_K_FUELSUM: if (2 == size) { memcpy(pRes, &(nvm_Data.function.page1.FunPage1_U.K_FuelSum), 2); } else { res = FALSE; }  break; case INDEX_NVM_Y_LASTDISTANCECNT: if (2 == size) { memcpy(pRes, &(nvm_Data.function.page1.FunPage1_U.lastDistanceCnt), 2); } else { res = FALSE; }  break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_Function_GetpageODO nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: read Parameters of pageODO in function nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: true or false nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/  static U8 nvm_Function_GetPageODO(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = TRUE; switch (index) { case INDEX_NVM_ODO0: if (4 == size) { memcpy(pRes, &(nvm_Data.function.odo[0].buf), 4); } else { res = FALSE; }  break; /*RESERVE*/ case INDEX_NVM_ODO1: if (4 == size) { memcpy(pRes, &(nvm_Data.function.odo[1].buf), 4); } else { res = FALSE; }  break; /*RESERVE*/ case INDEX_NVM_ODO2: if (4 == size) { memcpy(pRes, &(nvm_Data.function.odo[2].buf), 4);  } else { res = FALSE; }  break; /*RESERVE*/ case INDEX_NVM_ODO3: if (4 == size) { memcpy(pRes,&( nvm_Data.function.odo[3].buf), 4);  } else { res = FALSE; }  break; /*RESERVE*/ case INDEX_NVM_ODO4: if (4 == size) { memcpy(pRes, &(nvm_Data.function.odo[4].buf), 4);  } else { res = FALSE; }  break; } return res; }  /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_function_Get_page7 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: read Parameters of page7 in function nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para  nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: true or false nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_Function_GetPage7(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = TRUE;  switch (index) { case INDEX_NVM_Y_ANGLEOFFSET: if (2 == size) { // nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h pRes = nvm_Data.function.angle.FunPage7_U.AngleOffset; memcpy(pRes, &(nvm_Data.function.angle.FunPage7_U.AngleOffset), 2); } else { res = FALSE; }  break; case INDEX_NVM_ESUM_FUEL: if (4 == size) { // nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h pRes = nvm_Data.function.angle.FunPage7_U.e_sum_fuel;  memcpy(pRes, &(nvm_Data.function.angle.FunPage7_U.e_sum_fuel), 4); } else { res = FALSE; }  break;  case INDEX_NVM_ESUM2_FUEL: if (4 == size) { // nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h pRes = nvm_Data.function.angle.FunPage7_U.e_sum2_fuel;   memcpy(pRes, &(nvm_Data.function.angle.FunPage7_U.e_sum2_fuel), 4); } else { res = FALSE; }  break; case INDEX_NVM_WRT_181B: if (1 == size) { nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h pRes = nvm_Data.function.angle.FunPage7_U.F18B_WRCNT; } else { res = FALSE; }  break; case INDEX_NVM_WRT_181C: if (1 == size) { nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h pRes = nvm_Data.function.angle.FunPage7_U.F18C_WRCNT; } else { res = FALSE; }  break; case INDEX_NVM_SAFAIL_CNT: if (1 == size) { nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h pRes = nvm_Data.function.angle.FunPage7_U.SA_FailCnt; } else { res = FALSE; }  break;  case INDEX_NVM_WRT_1890: if (1 == size) { nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h pRes = nvm_Data.function.angle.FunPage7_U.F190_WRCNT; } else { res = FALSE; }  break; } return res; }    /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_function_Get_page8 nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: read Parameters of page7 in function nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input: index : the index of NVMEEDParaMap_ENUM size : the size of the para output: pRes : get the value of the para  nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: true or false nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/  static U8 nvm_Function_GetPage8(NVMKeyBlock_ENUM index, PU8 pRes, U8 size) { U8 res = TRUE;  switch (index) { case INDEX_NVM_B112: if (1 == size) { nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h pRes = nvm_Data.function.page8.FunPage8_U.pmOperationMode; } else { res = FALSE; }  break; case INDEX_NVM_RUNKEEP: if (1 == size) { nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h pRes = nvm_Data.function.page8.FunPage8_U.runkeep; } else { res = FALSE; }  break; } return res; }   /*************************************************** nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Function: nvm_CalCheckSum nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Description: checksum nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Parameters: input : the size of the data output: the checksum of the data nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Returns: checkSum nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Create & Verlog:$ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Author:Xuenian.Feng Date:2016-12-1 Version:V1.0 ****************************************************/ static U8 nvm_CalCheckSum(PU8 pRes, U8 size) { U8 checkSum = 0; U8 i = 0; if (NULL != pRes) { for (i = 0; i < size; i++) { checkSum += *(pRes + i); } } else { } return checkSum; }   /*=========================================================================== nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h File Revision History(bottom to top:first revision to last revision) *============================================================================ nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h $Log:$ * nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h Rev: Userid: Date: Description *-------- ---------- --------- ------------------------------ * nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h V1.0 Xuenian.Feng 2016-12-1 Initial nvm.c nvm_cfg.h nvm_info.inc nvm_private.h nvm_public.h V2.0 chensongming 2017-07-12 Initial *===========================================================================*/
