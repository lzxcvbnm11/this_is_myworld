/* **************************************************************************** PROJECT : SFMA driver FILE : $Id: r_sys_sfma.c 7539 2016-02-04 13:01:47Z florian.zimmermann $ ============================================================================ DESCRIPTION SFMA support functions for d1x ============================================================================ C O P Y R I G H T ============================================================================ Copyright (c) 2013 - 2014 by Renesas Electronics (Europe) GmbH. Arcadiastrasse 10 D-40472 Duesseldorf Germany All rights reserved. ============================================================================ Purpose: only for testing, not for mass production  DISCLAIMER  LICENSEE has read, understood and accepted the terms and conditions defined in the license agreement, especially the usage rights. In any case, it is LICENSEE's responsibility to make sure that any user of the software complies with the terms and conditions of the signed license agreement.  SAMPLE CODE is not part of the licensed software, as such it must not be used in mass-production applications. It can only be used for evaluation and demonstration purposes at customer's premises listed in the signed license agreement.  **************************************************************************** */   /*************************************************************************** Title: SFMA Driver support functions  Implementation of the SFMA support functions for the D1x device.  */  /*************************************************************************** Section: Includes */ #include "r_typedefs.h" #include "yd_sfma_api.h" #include "r_sfma_api.h" #include "yd_sfma_sys.h" #include "yd_config_sfma.h" #include "r_dev_api.h"  //#include "BSP_LowInit.h"  /*************************************************************************** Section: Local Defines */  /******************************************************************************* Constant: LOC_YD_SYS_SFMA_INTERNAL_BUS_CLOCK  This constant is the internal bus clock. D1L2 + D1Mx: PLL1 => 480MHz SFMA clock => 480MHz / 3 = 160MHz D1L1: PLL1 => 480MHz SFMA clock => 480MHz / 6 = 80MHz */ #define LOC_YD_SYS_SFMA_INTERNAL_BUS_CLOCK (160 r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c 1000 r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c 1000) #define LOC_YD_SYS_SFMA_INTERNAL_BUS_CLOCK_D1L1 (80 r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c 1000 r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c 1000)  /******************************************************************************* Constant: LOC_YD_SYS_SFMA_CKDLY  The offset value of the CKDLY register from the base address. */ #define LOC_YD_SYS_SFMA_CKDLY (0x00000050uL)  /******************************************************************************* Constant: LOC_YD_SYS_SFMA_SPODLY  The offset value of the SPODL register from the base address. */ #define LOC_YD_SYS_SFMA_SPODLY (0x00000068uL)  /******************************************************************************* Constant: LOC_YD_SYS_SFMA_CLOCK_ADJUSTED_LIMIT  The limit value which needs the adjustment of the phase relationship. */ #define LOC_YD_SYS_SFMA_CLOCK_ADJUSTED_LIMIT (60 r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c 1000 r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c 1000)  /*************************************************************************** Constant: LOC_YD_SYS_SFMA_DRCR  The offset value of the DRCR register from the base address. */ #define LOC_YD_SYS_SFMA_DRCR (0x0c)  #define LOC_YD_SYS_SFMA_DREAR (0x14)  /*************************************************************************** Constant: LOC_YD_SYS_SFMA_CKDLY_MASK  Mask for the CKDLY register. */ #define LOC_YD_SYS_SFMA_CKDLY_MASK (0xFFF8FFF8uL)   /*************************************************************************** Constant: LOC_YD_SFMA_DEFAULT_CAL  Default calibration for Serial flash memory.  SPBCLK clock phase shift 3 (Upper 16bits) Sampling point phase shift 1 (Lower 16 bits) */  #define SPBCLK_CLOCK_PHASE_SHIFT (3u) #define SAMPLING_POINT_PHASE_SHIFT (1u) #define LOC_YD_SFMA_DEFAULT_CAL ((SPBCLK_CLOCK_PHASE_SHIFT << 16) | SAMPLING_POINT_PHASE_SHIFT)  /*************************************************************************** Function: YD_SFMA_Sys_CalibSetting  see: <yd_sfma_sys.h> */ yd_sfma_Error_t YD_SFMA_Sys_CalibSetting(const uint32_t Unit, const yd_sfma_Config_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config) { uint32_t base; uint32_t regval; yd_sfma_Error_t sys_err = YD_SFMA_ERR_OK;  if (Config != R_NULL) { base = YD_SFMA_BASE_ADD;  if (Config->SerialFlashMemoryMaxClock >= LOC_YD_SYS_SFMA_CLOCK_ADJUSTED_LIMIT) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr check for valid calibration values */ if(0 == (LOC_YD_SYS_SFMA_CKDLY_MASK & Config->Calibration)) { YD_SFMA_WRITE32((base+LOC_YD_SYS_SFMA_CKDLY), 0xa5000000u + Config->Calibration); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Clock delay */ YD_SFMA_WRITE32((base+LOC_YD_SYS_SFMA_SPODLY), 0xa5000000u); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr No Data delay */ } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr error use a default */ YD_SFMA_WRITE32((base+LOC_YD_SYS_SFMA_CKDLY), 0xa5000000u + LOC_YD_SFMA_DEFAULT_CAL); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Clock delay */ YD_SFMA_WRITE32((base+LOC_YD_SYS_SFMA_SPODLY), 0xa5000000u); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr No Data delay */  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr error calibration value */ sys_err = YD_SFMA_ERR_PARAM_INCORRECT; } } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr low frequency setting */  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr clock delay */ YD_SFMA_WRITE32((base+LOC_YD_SYS_SFMA_CKDLY), 0xa5000000u);  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr fixed 2ns delay */ YD_SFMA_WRITE32((base+LOC_YD_SYS_SFMA_SPODLY), 0xa5001111u); } } else { sys_err = YD_SFMA_ERR_PARAM_INCORRECT; }  regval = YD_SFMA_READ32(base + LOC_YD_SYS_SFMA_DREAR);  return sys_err; }   /*************************************************************************** Function: YD_SFMA_Sys_Close  see: <yd_sfma_sys.h> */ yd_sfma_Error_t YD_SFMA_Sys_Close(const uint32_t Unit) { uint32_t base; yd_sfma_Error_t sys_err = YD_SFMA_ERR_OK; uint32_t regval;  if (Unit == 0) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr terminate any transfers from external address space */ base = YD_SFMA_BASE_ADD;  regval = YD_SFMA_READ32(base + LOC_YD_SYS_SFMA_DRCR); YD_SFMA_WRITE32((base + LOC_YD_SYS_SFMA_DRCR), (regval | 0x01000000uL)); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr set negate */ } else { sys_err = YD_SFMA_ERR_PARAM_INCORRECT; }  return sys_err; }   /*************************************************************************** Function: YD_SFMA_Sys_DDREnable  see: <yd_sfma_sys.h> */ uint8_t YD_SFMA_Sys_DDREnable(void) { uint32_t device; uint8_t ret; #if 0 device = u32g_BSP_LowInit_DevNumTyp; if (device == R_BSP_LowInit_DEV_R7F701401) { ret = R_FALSE; } else { ret = R_TRUE; } #else ret = R_TRUE; #endif return ret; }  /*************************************************************************** Function: YD_SFMA_Sys_BusWidth8BitEnable  see: <yd_sfma_sys.h> */ uint8_t YD_SFMA_Sys_BusWidth8BitEnable(void) { uint32_t device; uint8_t ret; #if 0 device = u32g_BSP_LowInit_DevNumTyp; if ((device == R_BSP_LowInit_DEV_R7F701401) || (device == R_BSP_LowInit_DEV_R7F701402)) { ret = R_FALSE; } else { ret = R_TRUE; } #else ret = R_FALSE; #endif  return ret; }  /*************************************************************************** Function: YD_SFMA_Sys_SyncPeripheral  see: <yd_sfma_sys.h> */ void YD_SFMA_Sys_SyncPeripheral(void) { R_DEV_SyncP(); }   /*************************************************************************** Function: YD_SFMA_Sys_Relax  see: <yd_sfma_sys.h> */ yd_sfma_Error_t YD_SFMA_Sys_Relax(const uint32_t Unit) { yd_sfma_Error_t sys_err = YD_SFMA_ERR_OK;  if (Unit >= YD_SFMA_MACRO_NUM) { sys_err = YD_SFMA_ERR_RANGE_UNIT; }  return sys_err; }   /*************************************************************************** Function: YD_SFMA_Sys_GetCal  see: <yd_sfma_sys.h> */ uint32_t YD_SFMA_Sys_GetCal(const uint32_t Unit) { uint32_t base; uint32_t regval;  if (Unit == 0) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr get the base address */ base = YD_SFMA_BASE_ADD;  regval = YD_SFMA_READ32(base + LOC_YD_SYS_SFMA_CKDLY); } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr error */ regval = 0xFFFFFFFFuL; }  return regval; }
