/* **************************************************************************** PROJECT : SFMA driver FILE : $Id: r_sfma_spibsc.c 7491 2016-02-02 16:51:40Z florian.zimmermann $ ============================================================================ DESCRIPTION Driver for the SFMA(Serial Flash Memory Interface) macro ============================================================================ C O P Y R I G H T ============================================================================ Copyright (c) 2013 - 2014 by Renesas Electronics (Europe) GmbH. Arcadiastrasse 10 D-40472 Duesseldorf Germany All rights reserved. ============================================================================  DISCLAIMER  LICENSEE has read, understood and accepted the terms and conditions defined in the license agreement, especially the usage rights. In any case, it is LICENSEE's responsibility to make sure that any user of the software complies with the terms and conditions of the signed license agreement.  **************************************************************************** */  /*************************************************************************** Title: SFMA Spibsc Driver  SFMA Internal Interface  */  /*************************************************************************** Section: Includes */ #include "r_typedefs.h" #include "r_sfma_api.h" #include "r_sfma_spibsc.h" #include "r_config_sfma.h" //#include "r_sfma_sys.h"  /*************************************************************************** Section: Local Defines */ /*************************************************************************** Constants: LOC_SFMA_EVEN_CHECK_NUM  This constant is even number check. */ #define LOC_SFMA_EVEN_CHECK_NUM (1u)  /*************************************************************************** Constants: LOC_SFMA_WAIT_FLAG  This constant is waiting flag.  LOC_SFMA_WAIT_FLAG_TRUE - Wait true. LOC_SFMA_WAIT_FLAG_FALSE - Wait false. */ #define LOC_SFMA_WAIT_FLAG_TRUE (1u) #define LOC_SFMA_WAIT_FLAG_FALSE (0u)  /*************************************************************************** Constants: LOC_SFLASHCMD_READ_JEDEC  This constant is Read JEDEC of serial flash command ID */ #define LOC_SFLASHCMD_READ_JEDEC (0x9FuL)  /*************************************************************************** Constants: LOC_SFMA_SPIBSC_SET_EAV_SHIFT  This constant is shift values of EAV field of DREAR register. */ #define LOC_SFMA_SPIBSC_SET_EAV_SHIFT (25uL)  /*************************************************************************** Constants: LOC_SFMA_SPIBSC_SET_EAV_MASK  This constant is mask values of EAV field of DREAR register. */ #define LOC_SFMA_SPIBSC_SET_EAV_MASK (0xFFuL)  /*************************************************************************** Constants: LOC_SFMA_MASK_BYTE_LOW  This constant is mask values of lower byte of 32 bit register. */ #define LOC_SFMA_MASK_BYTE_LOW (0x000000FFuL)  /*************************************************************************** Constants: LOC_SFMA_SPIBSC_SPBR  This constant is value of setting SPBR.  LOC_SFMA_SPIBSC_SPBR_MIN - The setting value of minimum SPBR value. LOC_SFMA_SPIBSC_SPBR_MAX - The setting value of max SPBR value. */ #define LOC_SFMA_SPIBSC_SPBR_MIN (1uL) #define LOC_SFMA_SPIBSC_SPBR_MAX (255uL)  /*************************************************************************** Constants: LOC_SFMA_SPIBSC_BRDV  This constant is BRDV setting.  LOC_SFMA_SPIBSC_BRDV_BASE - The setting value of BRDV base. LOC_SFMA_SPIBSC_BRDV_2DIV - The setting value of BRDV divided by 2. LOC_SFMA_SPIBSC_BRDV_4DIV - The setting value of BRDV divided by 4. LOC_SFMA_SPIBSC_BRDV_8DIV - The setting value of BRDV divided by 8. */ #define LOC_SFMA_SPIBSC_BRDV_BASE (0uL) #define LOC_SFMA_SPIBSC_BRDV_2DIV (1uL) #define LOC_SFMA_SPIBSC_BRDV_4DIV (2uL) #define LOC_SFMA_SPIBSC_BRDV_8DIV (3uL)  /*************************************************************************** Constants: LOC_SFMA_SPIBSC_SPBR_SET  This constant is bit rate setting.  LOC_SFMA_SPIBSC_SPBR_SET_DIV2 - Base bit rate divided by 2. LOC_SFMA_SPIBSC_SPBR_SET_DIV4 - Base bit rate divided by 4. LOC_SFMA_SPIBSC_SPBR_SET_DIV8 - Base bit rate divided by 8. LOC_SFMA_SPIBSC_SPBR_SET_DIV16 - Base bit rate divided by 16. */ #define LOC_SFMA_SPIBSC_SPBR_SET_DIV2 (2uL) #define LOC_SFMA_SPIBSC_SPBR_SET_DIV4 (4uL) #define LOC_SFMA_SPIBSC_SPBR_SET_DIV8 (8uL) #define LOC_SFMA_SPIBSC_SPBR_SET_DIV16 (16uL)  /*************************************************************************** Constants: LOC_SFMA_SPIBSC_CLK_MAX  This constant is max bit rate frequency.  LOC_SFMA_SPIBSC_CLK_MAX - MAX bit rate frequency division when BRDV is 0. LOC_SFMA_SPIBSC_CLK_MAX_DIV2 - MAX bit rate frequency division when BRDV is 1. LOC_SFMA_SPIBSC_CLK_MAX_DIV4 - MAX bit rate frequency division when BRDV is 2. LOC_SFMA_SPIBSC_CLK_MAX_DIV8 - MAX bit rate frequency division when BRDV is 3. */ #define LOC_SFMA_SPIBSC_CLK_MAX (510uL) #define LOC_SFMA_SPIBSC_CLK_MAX_DIV2 (1020uL) #define LOC_SFMA_SPIBSC_CLK_MAX_DIV4 (2040uL) #define LOC_SFMA_SPIBSC_CLK_MAX_DIV8 (4080uL)  /*************************************************************************** Section: Local functions */ /*************************************************************************** Function: loc_Spibsc_SetMode  Description: This function sets Quad I/O operation for the register of the serial flash memory according to the configuration.  Parameter: Unit : The parameter specifies the instance number. Req : The parameter specifies the request to the serial flash memory. SpiConfig : This is a pointer to the r_sfma_SpiConfig_t structure to the configuration of the unit.  Return value: See <r_sfma_Error_t>. */ static r_sfma_Error_t loc_Spibsc_SetMode(const uint32_t Unit, const r_sfma_Req_t Req, const r_sfma_SpiConfig_t *SpiConfig);  static r_sfma_Error_t loc_Spibsc_SetMode(const uint32_t Unit, const r_sfma_Req_t Req, const r_sfma_SpiConfig_t *SpiConfig) { r_sfma_Error_t ret; uint8_t st_reg1; uint8_t st_reg2; uint8_t cf_reg1; uint8_t cf_reg2; r_sfma_SpibscSpimdReg_t spibsc_reg;  if (SpiConfig == R_NULL) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else { ret = R_SFMA_SpibscReadStatusRegister(Unit, &st_reg1, &st_reg2, SpiConfig); if (ret == R_SFMA_ERR_OK) { ret = R_SFMA_SpibscReadConfigRegister(Unit, &cf_reg1, &cf_reg2, SpiConfig); if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr set serial-flash(1) same value of serial-flash(0) */ if (Req == R_SFMA_REQ_SERIALMODE) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ---- set dual/serial mode ---- */ if (SpiConfig->Command.QuadIoMode.Reg == R_SFMA_STATUS_REG) { st_reg1 &= (uint8_t)~SpiConfig->Command.QuadIoMode.BitPosition; } else if (SpiConfig->Command.QuadIoMode.Reg == R_SFMA_CONFIG_REG) { cf_reg1 &= (uint8_t)~SpiConfig->Command.QuadIoMode.BitPosition; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Do Nothing */ ; } } else if (Req == R_SFMA_REQ_QUADMODE) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ---- set quad mode ---- */ if (SpiConfig->Command.QuadIoMode.Reg == R_SFMA_STATUS_REG) { st_reg1 |= SpiConfig->Command.QuadIoMode.BitPosition; } else if (SpiConfig->Command.QuadIoMode.Reg == R_SFMA_CONFIG_REG) { cf_reg1 |= SpiConfig->Command.QuadIoMode.BitPosition; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Do Nothing */ ; } } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr error in argument */ ret = R_SFMA_ERR_PARAM_INCORRECT; }  if (ret == R_SFMA_ERR_OK) { if (SpiConfig->Command.DummyCycle.Reg == R_SFMA_STATUS_REG) { st_reg1 &= (uint8_t)~SpiConfig->Command.DummyCycle.BitMask; st_reg1 |= SpiConfig->Command.DummyCycle.BitSet; } else if (SpiConfig->Command.DummyCycle.Reg == R_SFMA_CONFIG_REG) { cf_reg1 &= (uint8_t)~SpiConfig->Command.DummyCycle.BitMask; cf_reg1 |= SpiConfig->Command.DummyCycle.BitSet; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Do Nothing */ ; }  ret = R_SFMA_SpibscWriteStatusRegister(Unit, st_reg1, cf_reg1, SpiConfig); } } }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr performance enhance mode  Continuous read mode is the most efficient method to access SPI flash, because it allows to receive read burst sequences without the costly need to transfer the 1-bit read command sequence at the start of each burst. In order to do enable the continuous read mode, the SPI must first receive a standard  read command sequence, which transmits a specific bit pattern (0xa5) right after the address bits. After this initial dummy read command, the SPI flash is in continuous read mode, where only the address bits need to be transferred at the beginning of each burst (still followed by the bit pattern (0xa5). The device exits continuous read mode right after the first SPI sequence which does not contain the 0xa5 pattern. */  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if the status & config registers are configured correctly then request the performance enhance mode */ if ((ret == R_SFMA_ERR_OK) && (SpiConfig->PerformanceEnMode == R_SFMA_PER_EN_MODE_ENABLE)) {  spibsc_reg.Cdb = R_SFMA_SPIBSC_1BIT; spibsc_reg.Ocdb = R_SFMA_SPIBSC_1BIT; spibsc_reg.Adb = R_SFMA_SPIBSC_4BIT; spibsc_reg.Opdb = R_SFMA_SPIBSC_4BIT; spibsc_reg.Spidb = R_SFMA_SPIBSC_4BIT; spibsc_reg.Cde = R_SFMA_SPIBSC_OUTPUT_ENABLE; spibsc_reg.Ocde = R_SFMA_SPIBSC_OUTPUT_DISABLE; spibsc_reg.Ade = R_SFMA_SPIBSC_OUTPUT_ADDR_32; spibsc_reg.Opde = R_SFMA_SPIBSC_OUTPUT_OPD_3; spibsc_reg.Spide = R_SFMA_SPIBSC_OUTPUT_DISABLE; spibsc_reg.Sslkp = R_SFMA_SPIBSC_SPISSL_NEGATE; spibsc_reg.Spire = R_SFMA_SPIBSC_OUTPUT_DISABLE; spibsc_reg.Spiwe = R_SFMA_SPIBSC_OUTPUT_ENABLE; spibsc_reg.Dme = R_SFMA_SPIBSC_OUTPUT_ENABLE; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Dummy cycle enable at the time of a SPI mode */ spibsc_reg.Addr = 0x00000000uL; spibsc_reg.Dmdb = R_SFMA_SPIBSC_4BIT; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The dummy cycle bit width of the time of a SPI mode */ spibsc_reg.Dmcyc = 6uL; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The number of dummy cycles of the time of a SPI mode */ spibsc_reg.Ocmd = 0uL;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr option bytes */ spibsc_reg.Opd[0] = 0x00uL; spibsc_reg.Opd[1] = 0x00uL; spibsc_reg.Opd[2] = 0x00uL; spibsc_reg.Opd[3] = 0xA5uL; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr performance enhance indicator */  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr different command for SDR and DDR */ if(SpiConfig->TransferMode == R_SFMA_SPIBSC_DDR_TRANS) { spibsc_reg.Addre = R_SFMA_SPIBSC_DDR_TRANS; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Address DDR enable */ spibsc_reg.Opdre = R_SFMA_SPIBSC_DDR_TRANS; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Option data DDRenable */ spibsc_reg.Spidre = R_SFMA_SPIBSC_DDR_TRANS; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Transmission data DDR enable */  spibsc_reg.Cmd = SpiConfig->Command.ReadDdrIoQuad; ret = R_SFMA_SpibscCommandTransfer(Unit, &spibsc_reg); } else if(SpiConfig->TransferMode == R_SFMA_SPIBSC_SDR_TRANS) { spibsc_reg.Addre = R_SFMA_SPIBSC_SDR_TRANS; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Address SDR enable */ spibsc_reg.Opdre = R_SFMA_SPIBSC_SDR_TRANS; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Option data SDRenable */ spibsc_reg.Spidre = R_SFMA_SPIBSC_SDR_TRANS; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Transmission data DDR enable */  spibsc_reg.Cmd = SpiConfig->Command.ReadSdrIoQuad; ret = R_SFMA_SpibscCommandTransfer(Unit, &spibsc_reg); } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr not supported */ ret = R_SFMA_ERR_NOT_SUPPORT_TRANSFER; } } }  return ret; }  /*************************************************************************** Section: Global Functions */  /*************************************************************************** Function: R_SFMA_SpibscOpen  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscOpen(const uint32_t Unit, const r_sfma_SpiConfig_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const SpiConfig) { r_sfma_Error_t ret = R_SFMA_ERR_OK; r_sfma_Req_t req = R_SFMA_REQ_SERIALMODE; uint32_t clock_div; uint32_t get_clock; uint8_t spbr = 0; uint8_t brdv = 0;  if (SpiConfig == R_NULL) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else if (SpiConfig->MaxClock == 0) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ==== setting serial-flash quad mode ==== */ if ((SpiConfig->DataWidth == R_SFMA_SPIBSC_1BIT) || (SpiConfig->DataWidth == R_SFMA_SPIBSC_2BIT)) { req = R_SFMA_REQ_SERIALMODE; } else if (SpiConfig->DataWidth == R_SFMA_SPIBSC_4BIT) { req = R_SFMA_REQ_QUADMODE; } else { ret = R_SFMA_ERR_PARAM_INCORRECT; }  if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr calculate the bit rate from a bus clock and the maximum clock of connected serial flash memory */ get_clock = (120*1000*1000); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr CPU clock = 120MHz */ clock_div = (get_clock / SpiConfig->MaxClock);  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr When not dividing, it lowers one frequency dividing rate. */ if ((get_clock % SpiConfig->MaxClock) != 0) { clock_div++; }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPBCR is possible to set only by even number. */ if ((clock_div & LOC_SFMA_EVEN_CHECK_NUM) != 0) { clock_div += LOC_SFMA_EVEN_CHECK_NUM; } if (clock_div <= LOC_SFMA_SPIBSC_CLK_MAX) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr When brdv makes 0 fixations */ if (clock_div == 0) { spbr = LOC_SFMA_SPIBSC_SPBR_MIN; } else { spbr = (uint8_t)(clock_div / LOC_SFMA_SPIBSC_SPBR_SET_DIV2); } brdv = LOC_SFMA_SPIBSC_BRDV_BASE; } else if (clock_div <= LOC_SFMA_SPIBSC_CLK_MAX_DIV2) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr When brdv makes 1 fixations */ spbr = (uint8_t)(clock_div / LOC_SFMA_SPIBSC_SPBR_SET_DIV4); brdv = LOC_SFMA_SPIBSC_BRDV_2DIV; } else if (clock_div <= LOC_SFMA_SPIBSC_CLK_MAX_DIV4) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr When brdv makes 2 fixations */ spbr = (uint8_t)(clock_div / LOC_SFMA_SPIBSC_SPBR_SET_DIV8); brdv = LOC_SFMA_SPIBSC_BRDV_4DIV; } else if (clock_div <= LOC_SFMA_SPIBSC_CLK_MAX_DIV8) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr When brdv makes 3 fixations */ spbr = (uint8_t)(clock_div / LOC_SFMA_SPIBSC_SPBR_SET_DIV16); brdv = LOC_SFMA_SPIBSC_BRDV_8DIV; } else { ret = R_SFMA_ERR_NOT_SUPPORT_CLOCK; }  if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ==== Initialization of SPIBSC ==== */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr when 120MHz -> spbr = 1 ;brdv = 0 */ ret = R_SFMA_SpibscCommonInit(Unit, SpiConfig->MemoryNum, spbr, brdv, SpiConfig->DataWidth, SpiConfig->TransferMode); if (ret == R_SFMA_ERR_OK) { ret = loc_Spibsc_SetMode(Unit, req, SpiConfig);  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if External address space mode selected */ if(SpiConfig->Mode == R_SFMA_SPIBSC_MODE_EXTERNAL) {  if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr ==== Initialization of an outside address space read mode. ==== */ ret = R_SFMA_SpibscDrInit(Unit, SpiConfig); if (ret == R_SFMA_ERR_OK) { ret = R_SFMA_SpibscDrAddr(Unit, 0, 0); } } } } } } }  return ret; }  /*************************************************************************** Function: R_SFMA_SpibscJEDECRead  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscJEDECRead(const uint32_t Unit, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const ManufacturerID, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const MemoryType, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Capacity) { r_sfma_SpibscSpimdReg_t spibsc_reg; r_sfma_Error_t ret; uint32_t read_data;  if ((ManufacturerID == R_NULL) || (MemoryType == R_NULL) || (Capacity == R_NULL)) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else { ret = R_SFMA_SpibscCommonInit(Unit, R_SFMA_SPIBSC_CMNCR_BSZ_SINGLE, LOC_SFMA_SPIBSC_SPBR_MIN, 0, R_SFMA_SPIBSC_1BIT, R_SFMA_SPIBSC_SDR_TRANS); if (ret == R_SFMA_ERR_OK) { ret = R_SFMA_SpibscRegsetInit(&spibsc_reg); if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr read status in Single-SPI */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Command */ spibsc_reg.Cmd = LOC_SFLASHCMD_READ_JEDEC; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI mode Enable */ spibsc_reg.Spide = R_SFMA_SPIBSC_OUTPUT_SPID_32; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI mode Control */ spibsc_reg.Spire = R_SFMA_SPIBSC_SPIDATA_ENABLE;  ret = R_SFMA_SpibscCommandTransfer(Unit, &spibsc_reg); if (ret == R_SFMA_ERR_OK) { read_data = spibsc_reg.Smrdr[R_SFMA_SMRDR_DATA_0];  *ManufacturerID = (uint8_t)(read_data  & LOC_SFMA_MASK_BYTE_LOW); *MemoryType = (uint8_t)((read_data >> R_SFMA_SHIFT_BYTE)  & LOC_SFMA_MASK_BYTE_LOW); *Capacity = (uint8_t)((read_data >> R_SFMA_SHIFT_2BYTE)  & LOC_SFMA_MASK_BYTE_LOW); } ret = R_SFMA_SpibscClose(Unit); } } }  return ret; }  /*************************************************************************** Function: R_SFMA_SpibscAccessAddressSet  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscAccessAddressSet(const uint32_t Unit, const uint64_t Addr, const uint8_t Range) { r_sfma_Error_t ret; uint8_t eav;  eav = (uint8_t)((Addr >> LOC_SFMA_SPIBSC_SET_EAV_SHIFT) & LOC_SFMA_SPIBSC_SET_EAV_MASK); ret = R_SFMA_SpibscDrAddr(Unit, eav, Range);  return ret; }  /*************************************************************************** Function: R_SFMA_SpibscReadStatusRegister  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscReadStatusRegister(const uint32_t Unit, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Status1, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Status2, const r_sfma_SpiConfig_t *SpiConfig) { r_sfma_SpibscSpimdReg_t spibsc_reg; r_sfma_Error_t ret;  if ((Status1 == R_NULL) || (Status2 == R_NULL)) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else if (SpiConfig == R_NULL) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else { ret = R_SFMA_SpibscRegsetInit(&spibsc_reg); if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Command */ spibsc_reg.Cmd = SpiConfig->Command.ReadStatus1; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI mode Enable */ spibsc_reg.Spide = R_SFMA_SPIBSC_OUTPUT_SPID_8; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI mode Control */ spibsc_reg.Spire = R_SFMA_SPIBSC_SPIDATA_ENABLE;  ret = R_SFMA_SpibscCommandTransfer(Unit, &spibsc_reg); if (ret == R_SFMA_ERR_OK) { if (SpiConfig->MemoryNum == R_SFMA_SPIBSC_CMNCR_BSZ_SINGLE) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Data[31:24] */ *Status1 = (uint8_t)(spibsc_reg.Smrdr[R_SFMA_SMRDR_DATA_0] >> R_SFMA_SHIFT_3BYTE); *Status2 = 0; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Data[55:48](23:16) */ *Status1 = (uint8_t)(spibsc_reg.Smrdr[R_SFMA_SMRDR_DATA_0] >> R_SFMA_SHIFT_2BYTE); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Data[63:56](31:24) */ *Status2 = (uint8_t)(spibsc_reg.Smrdr[R_SFMA_SMRDR_DATA_0] >> R_SFMA_SHIFT_3BYTE); } } } }  return ret; }  /*************************************************************************** Function: R_SFMA_SpibscReadConfigRegister  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscReadConfigRegister(const uint32_t Unit, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config1, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config2, const r_sfma_SpiConfig_t *SpiConfig) { r_sfma_SpibscSpimdReg_t spibsc_reg; r_sfma_Error_t ret;  if ((Config1 == R_NULL) || (Config2 == R_NULL)) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else if (SpiConfig == R_NULL) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else { ret = R_SFMA_SpibscRegsetInit(&spibsc_reg); if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Command */ spibsc_reg.Cmd = SpiConfig->Command.ReadStatus2; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI mode Enable */ spibsc_reg.Spide = R_SFMA_SPIBSC_OUTPUT_SPID_8; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI mode Control */ spibsc_reg.Spire = R_SFMA_SPIBSC_SPIDATA_ENABLE;  ret = R_SFMA_SpibscCommandTransfer(Unit, &spibsc_reg); if (ret == R_SFMA_ERR_OK) { if (SpiConfig->MemoryNum == R_SFMA_SPIBSC_CMNCR_BSZ_SINGLE) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Data[31:24] */ *Config1 = (uint8_t)(spibsc_reg.Smrdr[R_SFMA_SMRDR_DATA_0] >> R_SFMA_SHIFT_3BYTE); *Config2 = 0; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Data[55:48](23:16) */ *Config1 = (uint8_t)(spibsc_reg.Smrdr[R_SFMA_SMRDR_DATA_0] >> R_SFMA_SHIFT_2BYTE); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Data[63:56](31:24) */ *Config2 = (uint8_t)(spibsc_reg.Smrdr[R_SFMA_SMRDR_DATA_0] >> R_SFMA_SHIFT_3BYTE); } } } }  return ret; }  /*************************************************************************** Function: R_SFMA_SpibscWriteEnableRegister  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscWriteEnableRegister(const uint32_t Unit, const r_sfma_SpiConfig_t *SpiConfig) { r_sfma_SpibscSpimdReg_t spibsc_reg; r_sfma_Error_t ret;  if (SpiConfig == R_NULL) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else { ret = R_SFMA_SpibscRegsetInit(&spibsc_reg); if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Command */ spibsc_reg.Cmd = SpiConfig->Command.WriteEnable;  ret = R_SFMA_SpibscCommandTransfer(Unit, &spibsc_reg); } }  return ret; }  /*************************************************************************** Function: R_SFMA_SpibscWriteStatusRegister  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscWriteStatusRegister(const uint32_t Unit, const uint8_t Status, const uint8_t Config, const r_sfma_SpiConfig_t *SpiConfig) { r_sfma_SpibscSpimdReg_t spibsc_reg; r_sfma_Error_t ret;  if (SpiConfig == R_NULL) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr write status in Single-SPI */ ret = R_SFMA_SpibscWriteEnableRegister(Unit, SpiConfig); if (ret == R_SFMA_ERR_OK) { ret = R_SFMA_SpibscRegsetInit(&spibsc_reg); if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Command */ spibsc_reg.Cmd = SpiConfig->Command.WriteStatus; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Option-Data OPD3, OPD2 */ spibsc_reg.Opde = R_SFMA_SPIBSC_OUTPUT_OPD_32; spibsc_reg.Opdb = R_SFMA_SPIBSC_1BIT; spibsc_reg.Opd[R_SFMA_OPTION_DATA_0] = 0; spibsc_reg.Opd[R_SFMA_OPTION_DATA_1] = 0; spibsc_reg.Opd[R_SFMA_OPTION_DATA_2] = Config; spibsc_reg.Opd[R_SFMA_OPTION_DATA_3] = Status;  ret = R_SFMA_SpibscCommandTransfer(Unit, &spibsc_reg);  if (ret == R_SFMA_ERR_OK) { ret = R_SFMA_SpibscBusyWait(Unit, SpiConfig); } } } }  return ret; }  /*************************************************************************** Function: R_SFMA_SpibscBusyWait  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscBusyWait(const uint32_t Unit, const r_sfma_SpiConfig_t *SpiConfig) { r_sfma_Error_t ret = R_SFMA_ERR_OK; uint8_t st_reg1 = 0; uint8_t st_reg2 = 0; uint32_t loop_break; uint32_t wait = 0;  if (SpiConfig == R_NULL) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else { loop_break = LOC_SFMA_WAIT_FLAG_FALSE; while (loop_break != LOC_SFMA_WAIT_FLAG_TRUE) { if (SpiConfig->Command.WriteInProgress.Reg == R_SFMA_STATUS_REG) { ret = R_SFMA_SpibscReadStatusRegister(Unit, &st_reg1, &st_reg2, SpiConfig); } else if (SpiConfig->Command.WriteInProgress.Reg == R_SFMA_CONFIG_REG) { ret = R_SFMA_SpibscReadConfigRegister(Unit, &st_reg1, &st_reg2, SpiConfig); } else { ret = R_SFMA_ERR_PARAM_INCORRECT; }  if (ret == R_SFMA_ERR_OK) { if (SpiConfig->MemoryNum == R_SFMA_SPIBSC_CMNCR_BSZ_DUAL) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr s-flash x 2 */ if (((st_reg1 & SpiConfig->Command.WriteInProgress.BitPosition) == 0) && ((st_reg2 & SpiConfig->Command.WriteInProgress.BitPosition) == 0)) { loop_break = LOC_SFMA_WAIT_FLAG_TRUE; } } else if (SpiConfig->MemoryNum == R_SFMA_SPIBSC_CMNCR_BSZ_SINGLE) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr s-flash x 1 */ if ((st_reg1 & SpiConfig->Command.WriteInProgress.BitPosition) == 0) { loop_break = LOC_SFMA_WAIT_FLAG_TRUE; } } else { ret = R_SFMA_ERR_PARAM_INCORRECT; loop_break = LOC_SFMA_WAIT_FLAG_TRUE; }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The check of the timeout */ if (wait >= R_SFMA_BUSY_WAIT) { ret = R_SFMA_ERR_FATAL_HW; loop_break = LOC_SFMA_WAIT_FLAG_TRUE; } wait++; } else { loop_break = LOC_SFMA_WAIT_FLAG_TRUE; } } }  return ret; }  /*************************************************************************** Function: R_SFMA_SpibscRegsetInit  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscRegsetInit(r_sfma_SpibscSpimdReg_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Regset) { r_sfma_Error_t ret = R_SFMA_ERR_OK;  if (Regset == R_NULL) { ret = R_SFMA_ERR_PARAM_INCORRECT; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Command Enable */ Regset->Cde = R_SFMA_SPIBSC_OUTPUT_ENABLE; Regset->Cdb = R_SFMA_SPIBSC_1BIT; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Optional-Command Disable */ Regset->Ocde = R_SFMA_SPIBSC_OUTPUT_DISABLE; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Address Disable */ Regset->Ade = R_SFMA_SPIBSC_OUTPUT_DISABLE; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Option-Data Disable */ Regset->Opde = R_SFMA_SPIBSC_OUTPUT_DISABLE; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Dummy cycle Disable */ Regset->Dme = R_SFMA_SPIBSC_DUMMY_CYC_DISABLE; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI mode Enable */ Regset->Spide = R_SFMA_SPIBSC_OUTPUT_DISABLE; Regset->Smwdr[R_SFMA_SMWDR_DATA_0] = 0x00; Regset->Smwdr[R_SFMA_SMWDR_DATA_1] = 0x00; Regset->Spidb = R_SFMA_SPIBSC_1BIT; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI mode Control */ Regset->Sslkp = R_SFMA_SPIBSC_SPISSL_NEGATE; Regset->Spire = R_SFMA_SPIBSC_SPIDATA_DISABLE; Regset->Spiwe = R_SFMA_SPIBSC_SPIDATA_DISABLE; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI mode SDR Setting */ Regset->Addre = R_SFMA_SPIBSC_SDR_TRANS; Regset->Opdre = R_SFMA_SPIBSC_SDR_TRANS; Regset->Spidre = R_SFMA_SPIBSC_SDR_TRANS; }  return ret; }   /*************************************************************************** Function: R_SFMA_SpibscWriteExitExtAddr  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscWriteExitExtAddr(const uint32_t Unit, const r_sfma_SpiConfig_t *SpiConfig) { r_sfma_SpibscSpimdReg_t spibsc_reg; r_sfma_Error_t ret;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if we are in external address space we need to exit out of this mode  convert to single IO and send 0xFF   if we are not in external address space then it will not be necessary to  send this but no harm anyway */  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr terminate current transfer */ ret = R_SFMA_ERR_OK;  if (ret == R_SFMA_ERR_OK) { ret = R_SFMA_SpibscRegsetInit(&spibsc_reg); if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Command + the option cmd */ spibsc_reg.Cmd = SpiConfig->Command.ExitExtAddrSpc; spibsc_reg.Ocdb = R_SFMA_SPIBSC_1BIT; spibsc_reg.Ocde = R_SFMA_SPIBSC_OUTPUT_ENABLE; spibsc_reg.Ocmd = SpiConfig->Command.ExitExtAddrSpc;  spibsc_reg.Sslkp = R_SFMA_SPIBSC_SPISSL_NEGATE; ret = R_SFMA_SpibscCommandTransfer(Unit, &spibsc_reg); } }  return ret; }   /*************************************************************************** Function: R_SFMA_SpibscWriteReset  see: <r_sfma_spibsc.h> */ r_sfma_Error_t R_SFMA_SpibscWriteReset(const uint32_t Unit, const r_sfma_SpiConfig_t *SpiConfig) { r_sfma_SpibscSpimdReg_t spibsc_reg; r_sfma_Error_t ret;  ret = R_SFMA_ERR_OK; if (ret == R_SFMA_ERR_OK) { ret = R_SFMA_SpibscRegsetInit(&spibsc_reg); if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr RSTEN Command */ spibsc_reg.Cmd = SpiConfig->Command.ResetEnable; spibsc_reg.Ocdb = R_SFMA_SPIBSC_1BIT;  spibsc_reg.Sslkp = R_SFMA_SPIBSC_SPISSL_NEGATE; ret = R_SFMA_SpibscCommandTransfer(Unit, &spibsc_reg); }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr we need a delay of at least 10us between the two commands */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr TODO: will maybe not work without waiting but waiting fixed amount of time is also wrong */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr R_TICK_WaitUS(0, 10u); */  if (ret == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr RST Command */ spibsc_reg.Cmd = SpiConfig->Command.Reset; ret = R_SFMA_SpibscCommandTransfer(Unit, &spibsc_reg); } }  return ret; }
