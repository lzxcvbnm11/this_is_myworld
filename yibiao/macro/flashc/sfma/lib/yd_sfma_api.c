/* **************************************************************************** PROJECT : SFMA driver FILE : $Id: yd_sfma_api.c 7491 2016-02-02 16:51:40Z florian.zimmermann $ ============================================================================ DESCRIPTION Driver for the SFMA(Serial Flash Memory Interface A) macro ============================================================================ C O P Y R I G H T ============================================================================ Copyright (c) 2013 - 2014 by Renesas Electronics (Europe) GmbH. Arcadiastrasse 10 D-40472 Duesseldorf Germany All rights reserved. ============================================================================  DISCLAIMER  LICENSEE has read, understood and accepted the terms and conditions defined in the license agreement, especially the usage rights. In any case, it is LICENSEE's responsibility to make sure that any user of the software complies with the terms and conditions of the signed license agreement.  **************************************************************************** */  /*************************************************************************** Title: SFMA Driver API  SFMA driver API Module functions */   /*************************************************************************** Section: Includes */ #include "r_typedefs.h" #include "yd_sfma_api.h" #include "r_sfma_api.h" #include "yd_sfma_sys.h" #include "yd_config_sfma.h" #include "yd_sfma_spibsc.h" #include "yd_sfma_flash.h"  /*************************************************************************** Section: Local Defines */ /******************************************************************************* Constant: LOC_YD_SFMA_VERSION  A string containig the macro driver version information. */  #define LOC_YD_SFMA_VERSIONPREFIX "@(#)SFMA Version " #define LOC_YD_SFMA_VERSIONPOSTFIX " - " #if defined (__ghs__) #define LOC_YD_SFMA_VERSION { LOC_YD_SFMA_VERSIONPREFIX R_XSTR(YD_SFMA_VERSION_HI) "." \ R_XSTR(YD_SFMA_VERSION_LO) LOC_YD_SFMA_VERSIONPOSTFIX \ __DATE__ R_SPACE __TIME__ }  #else #define LOC_YD_SFMA_VERSION R_VERSION(SFMA, YD_SFMA_VERSION_HI, YD_SFMA_VERSION_LO) #endif  /*************************************************************************** Constant: LOC_YD_SFMA_HW_VERSION  A string containig the major and minor version of the H/W macro.  LOC_YD_SFMA_HW_VERSION_MAJOR - The major version. LOC_YD_SFMA_HW_VERSION_MINOR - The minor version. */ #define LOC_YD_SFMA_HW_VERSION_MAJOR (0x00000001u) #define LOC_YD_SFMA_HW_VERSION_MINOR (0x00000000u)  /******************************************************************************* Constant: LOC_YD_SFMA_DUAL  Define a two serial flash connection. */ #define LOC_YD_SFMA_DUAL (2)  /******************************************************************************* Constant: LOC_YD_SFMA_DEFAULT_SECTOR_SIZE  Define a default erase sector size. */ #define LOC_YD_SFMA_DEFAULT_SECTOR_SIZE (256uL r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c 1024uL) /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Sector size = 256 KB */  /******************************************************************************* Constant: LOC_YD_SFMA_MAXSIZE_OF_FLASH  Define a maximum size which is accessible to the serial flash memory */ #define LOC_YD_SFMA_MAXSIZE_OF_FLASH (0x100000000ULL) /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr 4GB */  /*************************************************************************** Section: Local Types */ /*************************************************************************** Enum: yd_sfma_State_t  Description: This type describes the state of SFMA.  Values: YD_SFMA_STATE_UNINITIALIZED - The SFMA driver is an uninitialized state. YD_SFMA_STATE_INITIALIZED - The SFMA driver is an initialization state. YD_SFMA_STATE_EXECUTING - The SFMA driver is an execution state. */ typedef enum { YD_SFMA_STATE_UNINITIALIZED = 0, YD_SFMA_STATE_INITIALIZED, YD_SFMA_STATE_EXECUTING } yd_sfma_State_t;  /************************************************************************** typedef: yd_sfma_Dev_t  Description: This type describes the information of the SFMA driver.  Struct members: Mode - See <yd_sfma_Mode_t> AccessAddr - The parameter specifies the access address of the serial flash memory. AccessRange - See <yd_sfma_AccessRange_t> SpiConfig - See <yd_sfma_SpiConfig_t> */ typedef struct { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Driver information. */ yd_sfma_Mode_t Mode; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr External address space mode information. */ uint64_t AccessAddr; yd_sfma_AccessRange_t AccessRange; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI configuration information. */ yd_sfma_SpiConfig_t SpiConfig; } yd_sfma_Dev_t;  /*************************************************************************** Section: Local Variables */ /******************************************************************************* Variable: loc_sfma_State  This value stores the status of SFMA driver. */ static yd_sfma_State_t loc_sfma_State[YD_SFMA_MACRO_NUM] = {YD_SFMA_STATE_UNINITIALIZED};  /******************************************************************************* Variable: loc_sfma_Dev  This value stores the setting information of SFMA driver. */ static yd_sfma_Dev_t loc_sfma_Dev[YD_SFMA_MACRO_NUM];  /*************************************************************************** Section: Local functions */  /*************************************************************************** Function: YD_SFMA_ConfigParameterCheck  Description: This function check parameters of <yd_sfma_Config_t> structure.  Parameter: Config - This is a pointer to the <yd_sfma_Config_t> structure to the configuration of the unit.  Return value: See <yd_sfma_Error_t>. */ static yd_sfma_Error_t YD_SFMA_ConfigParameterCheck(const yd_sfma_Config_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config);  static yd_sfma_Error_t YD_SFMA_ConfigParameterCheck(const yd_sfma_Config_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config) { yd_sfma_Error_t ret_val; uint8_t mode;  if (Config == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { if ((Config->MemoryNum != YD_SFMA_MEMORY_SINGLE) && (Config->MemoryNum != YD_SFMA_MEMORY_DUAL)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Mode != YD_SFMA_MODE_EX_SPACE) && (Config->Mode != YD_SFMA_MODE_SPI_OPERATING)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->AddressMode != YD_SFMA_ADDRESS_24BIT) && (Config->AddressMode != YD_SFMA_ADDRESS_32BIT)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if (Config->Command == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->QuadIoMode.Reg != YD_SFMA_STATUS_REG) && (Config->Command->QuadIoMode.Reg != YD_SFMA_CONFIG_REG) && (Config->Command->QuadIoMode.Reg != YD_SFMA_NONE_REG)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->BlockProtect.Reg != YD_SFMA_STATUS_REG) && (Config->Command->BlockProtect.Reg != YD_SFMA_CONFIG_REG) && (Config->Command->BlockProtect.Reg != YD_SFMA_NONE_REG)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->WriteInProgress.Reg != YD_SFMA_STATUS_REG) && (Config->Command->WriteInProgress.Reg != YD_SFMA_CONFIG_REG) && (Config->Command->WriteInProgress.Reg != YD_SFMA_NONE_REG)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->DummyCycle.Reg != YD_SFMA_STATUS_REG) && (Config->Command->DummyCycle.Reg != YD_SFMA_CONFIG_REG) && (Config->Command->DummyCycle.Reg != YD_SFMA_NONE_REG)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadSdrDummyCycle != YD_SFMA_DUMMY_0CYC) && (Config->Command->ReadSdrDummyCycle != YD_SFMA_DUMMY_1CYC) && (Config->Command->ReadSdrDummyCycle != YD_SFMA_DUMMY_2CYC) && (Config->Command->ReadSdrDummyCycle != YD_SFMA_DUMMY_3CYC) && (Config->Command->ReadSdrDummyCycle != YD_SFMA_DUMMY_4CYC) && (Config->Command->ReadSdrDummyCycle != YD_SFMA_DUMMY_5CYC) && (Config->Command->ReadSdrDummyCycle != YD_SFMA_DUMMY_6CYC) && (Config->Command->ReadSdrDummyCycle != YD_SFMA_DUMMY_7CYC) && (Config->Command->ReadSdrDummyCycle != YD_SFMA_DUMMY_8CYC)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadSdrIoDualDummyCycle != YD_SFMA_DUMMY_0CYC) && (Config->Command->ReadSdrIoDualDummyCycle != YD_SFMA_DUMMY_1CYC) && (Config->Command->ReadSdrIoDualDummyCycle != YD_SFMA_DUMMY_2CYC) && (Config->Command->ReadSdrIoDualDummyCycle != YD_SFMA_DUMMY_3CYC) && (Config->Command->ReadSdrIoDualDummyCycle != YD_SFMA_DUMMY_4CYC) && (Config->Command->ReadSdrIoDualDummyCycle != YD_SFMA_DUMMY_5CYC) && (Config->Command->ReadSdrIoDualDummyCycle != YD_SFMA_DUMMY_6CYC) && (Config->Command->ReadSdrIoDualDummyCycle != YD_SFMA_DUMMY_7CYC) && (Config->Command->ReadSdrIoDualDummyCycle != YD_SFMA_DUMMY_8CYC)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadSdrIoQuadDummyCycle != YD_SFMA_DUMMY_0CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != YD_SFMA_DUMMY_1CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != YD_SFMA_DUMMY_2CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != YD_SFMA_DUMMY_3CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != YD_SFMA_DUMMY_4CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != YD_SFMA_DUMMY_5CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != YD_SFMA_DUMMY_6CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != YD_SFMA_DUMMY_7CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != YD_SFMA_DUMMY_8CYC)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadDdrDummyCycle != YD_SFMA_DUMMY_0CYC) && (Config->Command->ReadDdrDummyCycle != YD_SFMA_DUMMY_1CYC) && (Config->Command->ReadDdrDummyCycle != YD_SFMA_DUMMY_2CYC) && (Config->Command->ReadDdrDummyCycle != YD_SFMA_DUMMY_3CYC) && (Config->Command->ReadDdrDummyCycle != YD_SFMA_DUMMY_4CYC) && (Config->Command->ReadDdrDummyCycle != YD_SFMA_DUMMY_5CYC) && (Config->Command->ReadDdrDummyCycle != YD_SFMA_DUMMY_6CYC) && (Config->Command->ReadDdrDummyCycle != YD_SFMA_DUMMY_7CYC) && (Config->Command->ReadDdrDummyCycle != YD_SFMA_DUMMY_8CYC)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadDdrIoDualDummyCycle != YD_SFMA_DUMMY_0CYC) && (Config->Command->ReadDdrIoDualDummyCycle != YD_SFMA_DUMMY_1CYC) && (Config->Command->ReadDdrIoDualDummyCycle != YD_SFMA_DUMMY_2CYC) && (Config->Command->ReadDdrIoDualDummyCycle != YD_SFMA_DUMMY_3CYC) && (Config->Command->ReadDdrIoDualDummyCycle != YD_SFMA_DUMMY_4CYC) && (Config->Command->ReadDdrIoDualDummyCycle != YD_SFMA_DUMMY_5CYC) && (Config->Command->ReadDdrIoDualDummyCycle != YD_SFMA_DUMMY_6CYC) && (Config->Command->ReadDdrIoDualDummyCycle != YD_SFMA_DUMMY_7CYC) && (Config->Command->ReadDdrIoDualDummyCycle != YD_SFMA_DUMMY_8CYC)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadDdrIoQuadDummyCycle != YD_SFMA_DUMMY_0CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != YD_SFMA_DUMMY_1CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != YD_SFMA_DUMMY_2CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != YD_SFMA_DUMMY_3CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != YD_SFMA_DUMMY_4CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != YD_SFMA_DUMMY_5CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != YD_SFMA_DUMMY_6CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != YD_SFMA_DUMMY_7CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != YD_SFMA_DUMMY_8CYC)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->WriteAddressBit != YD_SFMA_ADDRESS_SIZE_1BIT) && (Config->Command->WriteAddressBit != YD_SFMA_ADDRESS_SIZE_2BIT) && (Config->Command->WriteAddressBit != YD_SFMA_ADDRESS_SIZE_4BIT)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if (Config->SerialFlashMemoryMaxClock == 0) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->SerialFlashMemorySize == 0) || (Config->SerialFlashMemorySize > LOC_YD_SFMA_MAXSIZE_OF_FLASH)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if (Config->SerialFlashMemorySectorSize == 0) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if (Config->SerialFlashMemoryPageSize == 0) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->CacheMode != YD_SFMA_CACHE_OFF) && (Config->CacheMode != YD_SFMA_CACHE_BL1) && (Config->CacheMode != YD_SFMA_CACHE_BL2) && (Config->CacheMode != YD_SFMA_CACHE_BL3) && (Config->CacheMode != YD_SFMA_CACHE_BL4) && (Config->CacheMode != YD_SFMA_CACHE_BL5) && (Config->CacheMode != YD_SFMA_CACHE_BL6) && (Config->CacheMode != YD_SFMA_CACHE_BL7) && (Config->CacheMode != YD_SFMA_CACHE_BL8) && (Config->CacheMode != YD_SFMA_CACHE_BL9) && (Config->CacheMode != YD_SFMA_CACHE_BL10) && (Config->CacheMode != YD_SFMA_CACHE_BL11) && (Config->CacheMode != YD_SFMA_CACHE_BL12) && (Config->CacheMode != YD_SFMA_CACHE_BL13) && (Config->CacheMode != YD_SFMA_CACHE_BL14) && (Config->CacheMode != YD_SFMA_CACHE_BL15) && (Config->CacheMode != YD_SFMA_CACHE_BL16)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->PerformanceEnMode != YD_SFMA_PER_EN_MODE_DISABLE) && (Config->PerformanceEnMode != YD_SFMA_PER_EN_MODE_ENABLE)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = YD_SFMA_ERR_OK; }  mode = YD_SFMA_Sys_DDREnable(); //mode = R_FALSE; if (mode == R_FALSE) { if ((Config->DataTransferMode != YD_SFMA_SDR_SINGLE_IO) && (Config->DataTransferMode != YD_SFMA_SDR_DUAL_IO) && (Config->DataTransferMode != YD_SFMA_SDR_QUAD_IO)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } } else { if ((Config->DataTransferMode != YD_SFMA_SDR_SINGLE_IO) && (Config->DataTransferMode != YD_SFMA_SDR_DUAL_IO) && (Config->DataTransferMode != YD_SFMA_SDR_QUAD_IO) && (Config->DataTransferMode != YD_SFMA_DDR_SINGLE_IO) && (Config->DataTransferMode != YD_SFMA_DDR_DUAL_IO) && (Config->DataTransferMode != YD_SFMA_DDR_QUAD_IO)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } }  mode = YD_SFMA_Sys_BusWidth8BitEnable(); //mode = R_FALSE; if ((mode == R_FALSE) && (Config->MemoryNum == YD_SFMA_MEMORY_DUAL)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } }  return ret_val; }   /*************************************************************************** Section: Global Functions */  /*************************************************************************** Function: YD_SFMA_Init  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_Init(const uint32_t Unit) { yd_sfma_Error_t ret_val;  uint32_t base;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Check Base Address */ base = YD_SFMA_BASE_ADD; if (base == 0u) { ret_val = YD_SFMA_ERR_FATAL_HW; } else { if (Unit <= YD_SFMA_MACRO_NUM) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_UNINITIALIZED) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { loc_sfma_State[Unit] = YD_SFMA_STATE_INITIALIZED; } ret_val = YD_SFMA_ERR_OK; } else { ret_val = YD_SFMA_ERR_NG; } } }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_DeInit  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_DeInit(const uint32_t Unit) { yd_sfma_Error_t ret_val;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else { ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_INITIALIZED) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { loc_sfma_State[Unit] = YD_SFMA_STATE_UNINITIALIZED; } } }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_Open  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_Open(const uint32_t Unit, const yd_sfma_Config_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else if (Config == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = YD_SFMA_ConfigParameterCheck(Config); if (ret_val == YD_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_INITIALIZED) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Copy SFMA configuration. */ p_dev->Mode = Config->Mode; p_dev->SpiConfig.FlashSize = Config->SerialFlashMemorySize;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr for SPI configuration. */ if (Config->MemoryNum == YD_SFMA_MEMORY_DUAL) { p_dev->SpiConfig.MemoryNum = YD_SFMA_SPIBSC_CMNCR_BSZ_DUAL; } else { p_dev->SpiConfig.MemoryNum = YD_SFMA_SPIBSC_CMNCR_BSZ_SINGLE; } if ((Config->DataTransferMode == YD_SFMA_SDR_QUAD_IO) || (Config->DataTransferMode == YD_SFMA_DDR_QUAD_IO)) { p_dev->SpiConfig.DataWidth = YD_SFMA_SPIBSC_4BIT; } else if ((Config->DataTransferMode == YD_SFMA_SDR_DUAL_IO) || (Config->DataTransferMode == YD_SFMA_DDR_DUAL_IO)) { p_dev->SpiConfig.DataWidth = YD_SFMA_SPIBSC_2BIT; } else { p_dev->SpiConfig.DataWidth = YD_SFMA_SPIBSC_1BIT; }  if ((Config->DataTransferMode == YD_SFMA_DDR_SINGLE_IO) || (Config->DataTransferMode == YD_SFMA_DDR_DUAL_IO) || (Config->DataTransferMode == YD_SFMA_DDR_QUAD_IO)) { p_dev->SpiConfig.TransferMode = YD_SFMA_SPIBSC_DDR_TRANS; } else { p_dev->SpiConfig.TransferMode = YD_SFMA_SPIBSC_SDR_TRANS; }  if (Config->AddressMode == YD_SFMA_ADDRESS_32BIT) { p_dev->SpiConfig.AddressMode = YD_SFMA_SPIBSC_OUTPUT_ADDR_32; } else { p_dev->SpiConfig.AddressMode = YD_SFMA_SPIBSC_OUTPUT_ADDR_24; }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Copy flash memory control command. */ p_dev->SpiConfig.PageSize = Config->SerialFlashMemoryPageSize; p_dev->SpiConfig.MaxClock = Config->SerialFlashMemoryMaxClock; p_dev->SpiConfig.EraseSectorSize = Config->SerialFlashMemorySectorSize; p_dev->SpiConfig.Command.ReadSdr = Config->Command->ReadSdr; p_dev->SpiConfig.Command.ReadSdrDual = Config->Command->ReadSdrDual; p_dev->SpiConfig.Command.ReadSdrQuad = Config->Command->ReadSdrQuad; p_dev->SpiConfig.Command.ReadSdrIoDual = Config->Command->ReadSdrIoDual; p_dev->SpiConfig.Command.ReadSdrIoQuad = Config->Command->ReadSdrIoQuad; p_dev->SpiConfig.Command.ReadDdr = Config->Command->ReadDdr; p_dev->SpiConfig.Command.ReadDdrDual = Config->Command->ReadDdrDual; p_dev->SpiConfig.Command.ReadDdrQuad = Config->Command->ReadDdrQuad; p_dev->SpiConfig.Command.ReadDdrIoDual = Config->Command->ReadDdrIoDual; p_dev->SpiConfig.Command.ReadDdrIoQuad = Config->Command->ReadDdrIoQuad; p_dev->SpiConfig.Command.WriteSdr = Config->Command->WriteSdr; p_dev->SpiConfig.Command.WriteSdrDual = Config->Command->WriteSdrDual; p_dev->SpiConfig.Command.WriteSdrQuad = Config->Command->WriteSdrQuad; p_dev->SpiConfig.Command.WriteDdr = Config->Command->WriteDdr; p_dev->SpiConfig.Command.WriteDdrDual = Config->Command->WriteDdrDual; p_dev->SpiConfig.Command.WriteDdrQuad = Config->Command->WriteDdrQuad; p_dev->SpiConfig.Command.WriteEnable = Config->Command->WriteEnable; p_dev->SpiConfig.Command.Erase = Config->Command->Erase; p_dev->SpiConfig.Command.ReadStatus1 = Config->Command->ReadStatus1; p_dev->SpiConfig.Command.ReadStatus2 = Config->Command->ReadStatus2; p_dev->SpiConfig.Command.WriteStatus = Config->Command->WriteStatus; p_dev->SpiConfig.Command.QuadIoMode.Reg = Config->Command->QuadIoMode.Reg; p_dev->SpiConfig.Command.QuadIoMode.BitPosition = Config->Command->QuadIoMode.BitPosition; p_dev->SpiConfig.Command.BlockProtect.Reg = Config->Command->BlockProtect.Reg; p_dev->SpiConfig.Command.BlockProtect.BitPosition = Config->Command->BlockProtect.BitPosition; p_dev->SpiConfig.Command.DummyCycle.Reg = Config->Command->DummyCycle.Reg; p_dev->SpiConfig.Command.DummyCycle.BitMask = Config->Command->DummyCycle.BitMask; p_dev->SpiConfig.Command.DummyCycle.BitSet = Config->Command->DummyCycle.BitSet; p_dev->SpiConfig.Command.WriteInProgress.Reg = Config->Command->WriteInProgress.Reg; p_dev->SpiConfig.Command.WriteInProgress.BitPosition = Config->Command->WriteInProgress.BitPosition; p_dev->SpiConfig.Command.ReadSdrDummyCycle = Config->Command->ReadSdrDummyCycle; p_dev->SpiConfig.Command.ReadSdrIoQuadDummyCycle = Config->Command->ReadSdrIoQuadDummyCycle; p_dev->SpiConfig.Command.ReadSdrIoDualDummyCycle = Config->Command->ReadSdrIoDualDummyCycle; p_dev->SpiConfig.Command.ReadDdrDummyCycle = Config->Command->ReadDdrDummyCycle; p_dev->SpiConfig.Command.ReadDdrIoDualDummyCycle = Config->Command->ReadDdrIoDualDummyCycle; p_dev->SpiConfig.Command.ReadDdrIoQuadDummyCycle = Config->Command->ReadDdrIoQuadDummyCycle; p_dev->SpiConfig.Command.WriteAddressBit = Config->Command->WriteAddressBit; p_dev->SpiConfig.Command.ExitExtAddrSpc = Config->Command->ExitExtAddrSpc; p_dev->SpiConfig.Command.ResetEnable = Config->Command->ResetEnable; p_dev->SpiConfig.Command.Reset = Config->Command->Reset; p_dev->SpiConfig.Command.WriteStatus2 = Config->Command->WriteStatus2; p_dev->SpiConfig.Command.BulkErase = Config->Command->BulkErase;  p_dev->SpiConfig.Cachemode = (uint32_t)Config->CacheMode;  p_dev->SpiConfig.PerformanceEnMode = Config->PerformanceEnMode;  p_dev->SpiConfig.Mode = Config->Mode;  ret_val = YD_SFMA_SpibscOpen(Unit, &p_dev->SpiConfig);  if (ret_val == YD_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr update the calibration value */ ret_val = YD_SFMA_Sys_CalibSetting(Unit, Config); if (ret_val == YD_SFMA_ERR_OK) { loc_sfma_State[Unit] = YD_SFMA_STATE_EXECUTING; } } } }  return ret_val; }   /*************************************************************************** Function: YD_SFMA_Close  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_Close(const uint32_t Unit) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else { ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_EXECUTING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { ret_val = YD_SFMA_SpibscWriteExitExtAddr(Unit, &p_dev->SpiConfig); if (ret_val == YD_SFMA_ERR_OK) { ret_val = YD_SFMA_SpibscClose(Unit); if (ret_val == YD_SFMA_ERR_OK) { loc_sfma_State[Unit] = YD_SFMA_STATE_INITIALIZED; } } } } }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_AccessAddressSet  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_AccessAddressSet(const uint32_t Unit, const uint64_t Addr, const yd_sfma_AccessRange_t Range) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else if ((Addr & YD_SFMA_ADDRESS_ALIGNMENT) != 0uL) { ret_val = YD_SFMA_ERR_RANGE_PARAM; } else if ((Range != YD_SFMA_ACCESS_RANGE_32MB) && (Range != YD_SFMA_ACCESS_RANGE_64MB) && (Range != YD_SFMA_ACCESS_RANGE_128MB) && (Range != YD_SFMA_ACCESS_RANGE_256MB) && (Range != YD_SFMA_ACCESS_RANGE_512MB)) { ret_val = YD_SFMA_ERR_RANGE_PARAM; } else { p_dev = &loc_sfma_Dev[Unit];  if (Addr >= p_dev->SpiConfig.FlashSize) { ret_val = YD_SFMA_ERR_RANGE_PARAM; } else { ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_EXECUTING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != YD_SFMA_MODE_EX_SPACE) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { ret_val = YD_SFMA_SpibscAccessAddressSet(Unit, Addr, (uint8_t)Range); if (ret_val == YD_SFMA_ERR_OK) { p_dev->AccessAddr = Addr; p_dev->AccessRange = Range; } } } } }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_AccessAddressGet  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_AccessAddressGet(const uint32_t Unit, uint64_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Addr, yd_sfma_AccessRange_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Range) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else if (Addr == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if (Range == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_EXECUTING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != YD_SFMA_MODE_EX_SPACE) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { *Addr = p_dev->AccessAddr; *Range = p_dev->AccessRange; } } }  return ret_val; }   /*************************************************************************** Function: YD_SFMA_AccessAddressGet  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_CheckReg(const uint32_t Unit, const yd_sfma_Config_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else if (Config == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = YD_SFMA_SpibscCheckReg(Unit, &p_dev->SpiConfig); }  return ret_val; } /*************************************************************************** Function: YD_SFMA_ProtectionModeSet  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_ProtectionModeSet(const uint32_t Unit, const yd_sfma_ProtectionMode_t Mode) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev; yd_sfma_Req_t req;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else if ((Mode != YD_SFMA_MODE_PROTECT) && (Mode != YD_SFMA_MODE_UNPROTECT)) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_EXECUTING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != YD_SFMA_MODE_SPI_OPERATING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { if (Mode == YD_SFMA_MODE_PROTECT) { req = YD_SFMA_REQ_PROTECT; } else { req = YD_SFMA_REQ_UNPROTECT; }  ret_val = YD_SFMA_FlashProtectModeSet(Unit, req, &p_dev->SpiConfig); } } }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_DataErase  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_DataErase(const uint32_t Unit, const uint64_t Addr, const int32_t Size) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev; uint64_t erase_sector; uint64_t erase_addr;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else if (Size <= 0) {//size must > 0 ret_val = YD_SFMA_ERR_RANGE_PARAM; } else { p_dev = &loc_sfma_Dev[Unit];  if ((Addr + (uint64_t)Size) > p_dev->SpiConfig.FlashSize) {//total size must < max ret_val = YD_SFMA_ERR_RANGE_PARAM; } else if (p_dev->SpiConfig.EraseSectorSize == 0) {//sector size must > 0 ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_EXECUTING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != YD_SFMA_MODE_SPI_OPERATING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else {//calculate the ersaing size erase_sector = (Addr / p_dev->SpiConfig.EraseSectorSize); erase_addr = (erase_sector r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c p_dev->SpiConfig.EraseSectorSize); while (erase_addr < (Addr + (uint32_t)Size)) { ret_val = YD_SFMA_FlashSectorErase(Unit, erase_addr, &p_dev->SpiConfig); if (ret_val == YD_SFMA_ERR_OK) { erase_addr += p_dev->SpiConfig.EraseSectorSize; ret_val = YD_SFMA_Sys_Relax(Unit); }  if (ret_val != YD_SFMA_ERR_OK) { break; } } } } } }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_BulkErase  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_BulkErase(const uint32_t Unit) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else { p_dev = &loc_sfma_Dev[Unit];  ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_EXECUTING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != YD_SFMA_MODE_SPI_OPERATING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { ret_val = YD_SFMA_FlashBulkErase(Unit, &p_dev->SpiConfig); } } }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_DataWrite  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_DataWrite(const uint32_t Unit, const uint64_t Addr, const uint8_t *Buf, const int32_t Size) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev; int32_t write_size; int32_t remain_size; int32_t relax_size; uint32_t page_size; uint64_t write_addr; uint8_t mode_tmp;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else if (Buf == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { p_dev = &loc_sfma_Dev[Unit];  if (((Addr + (uint64_t)Size) > p_dev->SpiConfig.FlashSize) || (Size <= 0)) { ret_val = YD_SFMA_ERR_RANGE_PARAM; } else { if (p_dev->SpiConfig.MemoryNum == YD_SFMA_SPIBSC_CMNCR_BSZ_SINGLE) { page_size = p_dev->SpiConfig.PageSize; } else { page_size = (p_dev->SpiConfig.PageSize r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c LOC_YD_SFMA_DUAL); }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr write address check of page size unit */ if ((Addr % page_size) != 0uL) { ret_val = YD_SFMA_ERR_RANGE_PARAM; } else { ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_EXECUTING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != YD_SFMA_MODE_SPI_OPERATING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Because there is not a Write command of DDR, change SDR mode */ mode_tmp = p_dev->SpiConfig.TransferMode; p_dev->SpiConfig.TransferMode = YD_SFMA_SPIBSC_SDR_TRANS;  remain_size = Size; write_addr = Addr; relax_size = 0; while (remain_size > 0L) { if (remain_size > (int32_t)page_size) { write_size = (int32_t)page_size; } else { write_size = remain_size; }  ret_val = YD_SFMA_FlashDataWrite(Unit, write_addr, Buf, write_size, &p_dev->SpiConfig); if (ret_val == YD_SFMA_ERR_OK) { remain_size -= write_size; write_addr += (uint32_t)write_size; Buf += write_size; relax_size += write_size;  if (relax_size >= YD_SFMA_RELAX_CALL_SIZE) { ret_val = YD_SFMA_Sys_Relax(Unit); relax_size = 0; } }  if (ret_val != YD_SFMA_ERR_OK) { remain_size = 0; } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr return to original transfer mode setting */ p_dev->SpiConfig.TransferMode = mode_tmp; } } } } }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_DataRead  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_DataRead(const uint32_t Unit, const uint64_t Addr, uint8_t *Buf, const int32_t Size) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev; int32_t read_size; int32_t remain_size; uint64_t read_addr;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else if (Buf == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if (Size <= 0) { ret_val = YD_SFMA_ERR_RANGE_PARAM; } else { p_dev = &loc_sfma_Dev[Unit]; if ((Addr + (uint64_t)Size) > p_dev->SpiConfig.FlashSize) { ret_val = YD_SFMA_ERR_RANGE_PARAM; } else { ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_EXECUTING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != YD_SFMA_MODE_SPI_OPERATING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { remain_size = Size; read_addr = Addr; while (remain_size > 0L) { if (remain_size > YD_SFMA_RELAX_CALL_SIZE) { read_size = YD_SFMA_RELAX_CALL_SIZE; } else { read_size = remain_size; }  ret_val = YD_SFMA_FlashDataRead(Unit, read_addr, Buf, read_size, &p_dev->SpiConfig); if (ret_val == YD_SFMA_ERR_OK) { remain_size -= read_size; read_addr += (uint32_t)read_size; Buf += read_size;  ret_val = YD_SFMA_Sys_Relax(Unit); }  if (ret_val != YD_SFMA_ERR_OK) { remain_size = 0; } } } } } }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_JEDECRead  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_JEDECRead(const uint32_t Unit, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const ManufacturerID, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const MemoryType, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Capacity) { yd_sfma_Error_t ret_val;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else if (ManufacturerID == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if (MemoryType == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if (Capacity == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Read JEDEC */ ret_val = YD_SFMA_SpibscJEDECRead(Unit, ManufacturerID, MemoryType, Capacity); }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_VersionStringGet  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ const uint8_t* YD_SFMA_VersionStringGet(void) { static const uint8_t version[] = LOC_YD_SFMA_VERSION;  return version; }  /*************************************************************************** Function: YD_SFMA_MacroVersionGet  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_MacroVersionGet(uint32_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Major, uint32_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Minor) { yd_sfma_Error_t ret_val = YD_SFMA_ERR_OK;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Major == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else if (Minor == R_NULL) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { *Major = LOC_YD_SFMA_HW_VERSION_MAJOR; *Minor = LOC_YD_SFMA_HW_VERSION_MINOR; }  return ret_val; }   /*************************************************************************** Function: YD_SFMA_GetCal  #include "yd_sfma_api.h" #include "r_sfma_api.h" */ yd_sfma_Error_t YD_SFMA_GetCal(const uint32_t Unit, uint32_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c Cal) { yd_sfma_Error_t ret_val = YD_SFMA_ERR_OK;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr error, invalid value */ *Cal = 0xFFFFFFFFuL; } else { *Cal = YD_SFMA_Sys_GetCal(Unit); }  return ret_val; }   /*************************************************************************** Function: YD_SFMA_GetStatus  see: <yd_sfma_api.h> */ yd_sfma_Error_t YD_SFMA_GetStatus(const uint32_t Unit, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Status1, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Status2) { yd_sfma_Error_t ret_val = YD_SFMA_ERR_OK; yd_sfma_Dev_t* p_dev;  p_dev = &loc_sfma_Dev[Unit];  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = YD_SFMA_SpibscReadStatusRegister(Unit, Status1, Status2, &p_dev->SpiConfig); }  return ret_val; }  /*************************************************************************** Function: YD_SFMA_GetConfig  see: <yd_sfma_api.h> */ yd_sfma_Error_t YD_SFMA_GetConfig(const uint32_t Unit, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config1, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config2) { yd_sfma_Error_t ret_val = YD_SFMA_ERR_OK; yd_sfma_Dev_t* p_dev;  p_dev = &loc_sfma_Dev[Unit];  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = YD_SFMA_SpibscReadConfigRegister(Unit, Config1, Config2, &p_dev->SpiConfig); }  return ret_val; }   /*************************************************************************** Function: YD_SFMA_GetConfig  see: <yd_sfma_api.h> */ yd_sfma_Error_t YD_SFMA_WriteStatusConfig(const uint32_t Unit, uint8_t Status, uint8_t Config) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else { ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_EXECUTING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != YD_SFMA_MODE_SPI_OPERATING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { ret_val = YD_SFMA_SpibscWriteStatusRegister(Unit, Status, Config, &p_dev->SpiConfig); } } }  return ret_val; }   /*************************************************************************** Function: YD_SFMA_WriteReset  see: <yd_sfma_api.h> */ yd_sfma_Error_t YD_SFMA_WriteReset(const uint32_t Unit) { yd_sfma_Error_t ret_val; yd_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= YD_SFMA_MACRO_NUM) { ret_val = YD_SFMA_ERR_RANGE_UNIT; } else { ret_val = YD_SFMA_ERR_OK; if (ret_val == YD_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != YD_SFMA_STATE_EXECUTING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != YD_SFMA_MODE_SPI_OPERATING) { ret_val = YD_SFMA_ERR_NOT_ACCEPTABLE; } else { ret_val = YD_SFMA_SpibscWriteReset(Unit, &p_dev->SpiConfig); } } }  return ret_val; }
