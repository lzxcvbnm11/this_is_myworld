/* **************************************************************************** PROJECT : SFMA driver FILE : $Id: r_sfma_api.c 7491 2016-02-02 16:51:40Z florian.zimmermann $ ============================================================================ DESCRIPTION Driver for the SFMA(Serial Flash Memory Interface A) macro ============================================================================ C O P Y R I G H T ============================================================================ Copyright (c) 2013 - 2014 by Renesas Electronics (Europe) GmbH. Arcadiastrasse 10 D-40472 Duesseldorf Germany All rights reserved. ============================================================================  DISCLAIMER  LICENSEE has read, understood and accepted the terms and conditions defined in the license agreement, especially the usage rights. In any case, it is LICENSEE's responsibility to make sure that any user of the software complies with the terms and conditions of the signed license agreement.  **************************************************************************** */  /*************************************************************************** Title: SFMA Driver API  SFMA driver API Module functions */   /*************************************************************************** Section: Includes */ #include "r_typedefs.h" #include "r_sfma_api.h" #include "r_sfma_sys.h" #include "r_config_sfma.h" #include "r_sfma_spibsc.h" #include "r_sfma_flash.h"  /*************************************************************************** Section: Local Defines */ /******************************************************************************* Constant: LOC_SFMA_VERSION  A string containig the macro driver version information. */  #define LOC_SFMA_VERSIONPREFIX "@(#)SFMA Version " #define LOC_SFMA_VERSIONPOSTFIX " - " #if defined (__ghs__) #define LOC_SFMA_VERSION { LOC_SFMA_VERSIONPREFIX R_XSTR(R_SFMA_VERSION_HI) "." \ R_XSTR(R_SFMA_VERSION_LO) LOC_SFMA_VERSIONPOSTFIX \ __DATE__ R_SPACE __TIME__ }  #else #define LOC_SFMA_VERSION R_VERSION(SFMA, R_SFMA_VERSION_HI, R_SFMA_VERSION_LO) #endif  /*************************************************************************** Constant: LOC_SFMA_HW_VERSION  A string containig the major and minor version of the H/W macro.  LOC_SFMA_HW_VERSION_MAJOR - The major version. LOC_SFMA_HW_VERSION_MINOR - The minor version. */ #define LOC_SFMA_HW_VERSION_MAJOR (0x00000001u) #define LOC_SFMA_HW_VERSION_MINOR (0x00000000u)  /******************************************************************************* Constant: LOC_SFMA_DUAL  Define a two serial flash connection. */ #define LOC_SFMA_DUAL (2)  /******************************************************************************* Constant: LOC_SFMA_DEFAULT_SECTOR_SIZE  Define a default erase sector size. */ #define LOC_SFMA_DEFAULT_SECTOR_SIZE (256uL r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c 1024uL) /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Sector size = 256 KB */  /******************************************************************************* Constant: LOC_SFMA_MAXSIZE_OF_FLASH  Define a maximum size which is accessible to the serial flash memory */ #define LOC_SFMA_MAXSIZE_OF_FLASH (0x100000000ULL) /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr 4GB */  /*************************************************************************** Section: Local Types */ /*************************************************************************** Enum: r_sfma_State_t  Description: This type describes the state of SFMA.  Values: R_SFMA_STATE_UNINITIALIZED - The SFMA driver is an uninitialized state. R_SFMA_STATE_INITIALIZED - The SFMA driver is an initialization state. R_SFMA_STATE_EXECUTING - The SFMA driver is an execution state. */ typedef enum { R_SFMA_STATE_UNINITIALIZED = 0, R_SFMA_STATE_INITIALIZED, R_SFMA_STATE_EXECUTING } r_sfma_State_t;  /************************************************************************** typedef: r_sfma_Dev_t  Description: This type describes the information of the SFMA driver.  Struct members: Mode - See <r_sfma_Mode_t> AccessAddr - The parameter specifies the access address of the serial flash memory. AccessRange - See <r_sfma_AccessRange_t> SpiConfig - See <r_sfma_SpiConfig_t> */ typedef struct { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Driver information. */ r_sfma_Mode_t Mode; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr External address space mode information. */ uint64_t AccessAddr; r_sfma_AccessRange_t AccessRange; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr SPI configuration information. */ r_sfma_SpiConfig_t SpiConfig; } r_sfma_Dev_t;  /*************************************************************************** Section: Local Variables */ /******************************************************************************* Variable: loc_sfma_State  This value stores the status of SFMA driver. */ static r_sfma_State_t loc_sfma_State[R_SFMA_MACRO_NUM] = {R_SFMA_STATE_UNINITIALIZED};  /******************************************************************************* Variable: loc_sfma_Dev  This value stores the setting information of SFMA driver. */ static r_sfma_Dev_t loc_sfma_Dev[R_SFMA_MACRO_NUM];  /*************************************************************************** Section: Local functions */  /*************************************************************************** Function: loc_SFMA_ConfigParameterCheck  Description: This function check parameters of <r_sfma_Config_t> structure.  Parameter: Config - This is a pointer to the <r_sfma_Config_t> structure to the configuration of the unit.  Return value: See <r_sfma_Error_t>. */ static r_sfma_Error_t loc_SFMA_ConfigParameterCheck(const r_sfma_Config_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config);  static r_sfma_Error_t loc_SFMA_ConfigParameterCheck(const r_sfma_Config_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config) { r_sfma_Error_t ret_val; uint8_t mode;  if (Config == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { if ((Config->MemoryNum != R_SFMA_MEMORY_SINGLE) && (Config->MemoryNum != R_SFMA_MEMORY_DUAL)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Mode != R_SFMA_MODE_EX_SPACE) && (Config->Mode != R_SFMA_MODE_SPI_OPERATING)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->AddressMode != R_SFMA_ADDRESS_24BIT) && (Config->AddressMode != R_SFMA_ADDRESS_32BIT)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if (Config->Command == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->QuadIoMode.Reg != R_SFMA_STATUS_REG) && (Config->Command->QuadIoMode.Reg != R_SFMA_CONFIG_REG) && (Config->Command->QuadIoMode.Reg != R_SFMA_NONE_REG)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->BlockProtect.Reg != R_SFMA_STATUS_REG) && (Config->Command->BlockProtect.Reg != R_SFMA_CONFIG_REG) && (Config->Command->BlockProtect.Reg != R_SFMA_NONE_REG)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->WriteInProgress.Reg != R_SFMA_STATUS_REG) && (Config->Command->WriteInProgress.Reg != R_SFMA_CONFIG_REG) && (Config->Command->WriteInProgress.Reg != R_SFMA_NONE_REG)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->DummyCycle.Reg != R_SFMA_STATUS_REG) && (Config->Command->DummyCycle.Reg != R_SFMA_CONFIG_REG) && (Config->Command->DummyCycle.Reg != R_SFMA_NONE_REG)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadSdrDummyCycle != R_SFMA_DUMMY_0CYC) && (Config->Command->ReadSdrDummyCycle != R_SFMA_DUMMY_1CYC) && (Config->Command->ReadSdrDummyCycle != R_SFMA_DUMMY_2CYC) && (Config->Command->ReadSdrDummyCycle != R_SFMA_DUMMY_3CYC) && (Config->Command->ReadSdrDummyCycle != R_SFMA_DUMMY_4CYC) && (Config->Command->ReadSdrDummyCycle != R_SFMA_DUMMY_5CYC) && (Config->Command->ReadSdrDummyCycle != R_SFMA_DUMMY_6CYC) && (Config->Command->ReadSdrDummyCycle != R_SFMA_DUMMY_7CYC) && (Config->Command->ReadSdrDummyCycle != R_SFMA_DUMMY_8CYC)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadSdrIoDualDummyCycle != R_SFMA_DUMMY_0CYC) && (Config->Command->ReadSdrIoDualDummyCycle != R_SFMA_DUMMY_1CYC) && (Config->Command->ReadSdrIoDualDummyCycle != R_SFMA_DUMMY_2CYC) && (Config->Command->ReadSdrIoDualDummyCycle != R_SFMA_DUMMY_3CYC) && (Config->Command->ReadSdrIoDualDummyCycle != R_SFMA_DUMMY_4CYC) && (Config->Command->ReadSdrIoDualDummyCycle != R_SFMA_DUMMY_5CYC) && (Config->Command->ReadSdrIoDualDummyCycle != R_SFMA_DUMMY_6CYC) && (Config->Command->ReadSdrIoDualDummyCycle != R_SFMA_DUMMY_7CYC) && (Config->Command->ReadSdrIoDualDummyCycle != R_SFMA_DUMMY_8CYC)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadSdrIoQuadDummyCycle != R_SFMA_DUMMY_0CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != R_SFMA_DUMMY_1CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != R_SFMA_DUMMY_2CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != R_SFMA_DUMMY_3CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != R_SFMA_DUMMY_4CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != R_SFMA_DUMMY_5CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != R_SFMA_DUMMY_6CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != R_SFMA_DUMMY_7CYC) && (Config->Command->ReadSdrIoQuadDummyCycle != R_SFMA_DUMMY_8CYC)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadDdrDummyCycle != R_SFMA_DUMMY_0CYC) && (Config->Command->ReadDdrDummyCycle != R_SFMA_DUMMY_1CYC) && (Config->Command->ReadDdrDummyCycle != R_SFMA_DUMMY_2CYC) && (Config->Command->ReadDdrDummyCycle != R_SFMA_DUMMY_3CYC) && (Config->Command->ReadDdrDummyCycle != R_SFMA_DUMMY_4CYC) && (Config->Command->ReadDdrDummyCycle != R_SFMA_DUMMY_5CYC) && (Config->Command->ReadDdrDummyCycle != R_SFMA_DUMMY_6CYC) && (Config->Command->ReadDdrDummyCycle != R_SFMA_DUMMY_7CYC) && (Config->Command->ReadDdrDummyCycle != R_SFMA_DUMMY_8CYC)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadDdrIoDualDummyCycle != R_SFMA_DUMMY_0CYC) && (Config->Command->ReadDdrIoDualDummyCycle != R_SFMA_DUMMY_1CYC) && (Config->Command->ReadDdrIoDualDummyCycle != R_SFMA_DUMMY_2CYC) && (Config->Command->ReadDdrIoDualDummyCycle != R_SFMA_DUMMY_3CYC) && (Config->Command->ReadDdrIoDualDummyCycle != R_SFMA_DUMMY_4CYC) && (Config->Command->ReadDdrIoDualDummyCycle != R_SFMA_DUMMY_5CYC) && (Config->Command->ReadDdrIoDualDummyCycle != R_SFMA_DUMMY_6CYC) && (Config->Command->ReadDdrIoDualDummyCycle != R_SFMA_DUMMY_7CYC) && (Config->Command->ReadDdrIoDualDummyCycle != R_SFMA_DUMMY_8CYC)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->ReadDdrIoQuadDummyCycle != R_SFMA_DUMMY_0CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != R_SFMA_DUMMY_1CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != R_SFMA_DUMMY_2CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != R_SFMA_DUMMY_3CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != R_SFMA_DUMMY_4CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != R_SFMA_DUMMY_5CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != R_SFMA_DUMMY_6CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != R_SFMA_DUMMY_7CYC) && (Config->Command->ReadDdrIoQuadDummyCycle != R_SFMA_DUMMY_8CYC)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->Command->WriteAddressBit != R_SFMA_ADDRESS_SIZE_1BIT) && (Config->Command->WriteAddressBit != R_SFMA_ADDRESS_SIZE_2BIT) && (Config->Command->WriteAddressBit != R_SFMA_ADDRESS_SIZE_4BIT)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if (Config->SerialFlashMemoryMaxClock == 0) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->SerialFlashMemorySize == 0) || (Config->SerialFlashMemorySize > LOC_SFMA_MAXSIZE_OF_FLASH)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if (Config->SerialFlashMemorySectorSize == 0) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if (Config->SerialFlashMemoryPageSize == 0) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->CacheMode != R_SFMA_CACHE_OFF) && (Config->CacheMode != R_SFMA_CACHE_BL1) && (Config->CacheMode != R_SFMA_CACHE_BL2) && (Config->CacheMode != R_SFMA_CACHE_BL3) && (Config->CacheMode != R_SFMA_CACHE_BL4) && (Config->CacheMode != R_SFMA_CACHE_BL5) && (Config->CacheMode != R_SFMA_CACHE_BL6) && (Config->CacheMode != R_SFMA_CACHE_BL7) && (Config->CacheMode != R_SFMA_CACHE_BL8) && (Config->CacheMode != R_SFMA_CACHE_BL9) && (Config->CacheMode != R_SFMA_CACHE_BL10) && (Config->CacheMode != R_SFMA_CACHE_BL11) && (Config->CacheMode != R_SFMA_CACHE_BL12) && (Config->CacheMode != R_SFMA_CACHE_BL13) && (Config->CacheMode != R_SFMA_CACHE_BL14) && (Config->CacheMode != R_SFMA_CACHE_BL15) && (Config->CacheMode != R_SFMA_CACHE_BL16)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if ((Config->PerformanceEnMode != R_SFMA_PER_EN_MODE_DISABLE) && (Config->PerformanceEnMode != R_SFMA_PER_EN_MODE_ENABLE)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = R_SFMA_ERR_OK; }  mode = R_SFMA_Sys_DDREnable(); //mode = R_FALSE; if (mode == R_FALSE) { if ((Config->DataTransferMode != R_SFMA_SDR_SINGLE_IO) && (Config->DataTransferMode != R_SFMA_SDR_DUAL_IO) && (Config->DataTransferMode != R_SFMA_SDR_QUAD_IO)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } } else  { if ((Config->DataTransferMode != R_SFMA_SDR_SINGLE_IO) && (Config->DataTransferMode != R_SFMA_SDR_DUAL_IO) && (Config->DataTransferMode != R_SFMA_SDR_QUAD_IO) && (Config->DataTransferMode != R_SFMA_DDR_SINGLE_IO) && (Config->DataTransferMode != R_SFMA_DDR_DUAL_IO) && (Config->DataTransferMode != R_SFMA_DDR_QUAD_IO)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } }  mode = R_SFMA_Sys_BusWidth8BitEnable(); //mode = R_FALSE; if ((mode == R_FALSE) && (Config->MemoryNum == R_SFMA_MEMORY_DUAL)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } }  return ret_val; }   /*************************************************************************** Section: Global Functions */  /*************************************************************************** Function: R_SFMA_Init  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_Init(const uint32_t Unit) { r_sfma_Error_t ret_val;  uint32_t base;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Check Base Address */ base = R_SFMA_BASE_ADD; if (base == 0u) { ret_val = R_SFMA_ERR_FATAL_HW; } else { if (Unit <= R_SFMA_MACRO_NUM) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_UNINITIALIZED) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { loc_sfma_State[Unit] = R_SFMA_STATE_INITIALIZED; } ret_val = R_SFMA_ERR_OK; } else {  ret_val = R_SFMA_ERR_NG; } } }  return ret_val; }  /*************************************************************************** Function: R_SFMA_DeInit  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_DeInit(const uint32_t Unit) { r_sfma_Error_t ret_val;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else { ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_INITIALIZED) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { loc_sfma_State[Unit] = R_SFMA_STATE_UNINITIALIZED; } } }  return ret_val; }  /*************************************************************************** Function: R_SFMA_Open  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_Open(const uint32_t Unit, const r_sfma_Config_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else if (Config == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = loc_SFMA_ConfigParameterCheck(Config); if (ret_val == R_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_INITIALIZED) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Copy SFMA configuration. */ p_dev->Mode = Config->Mode; p_dev->SpiConfig.FlashSize = Config->SerialFlashMemorySize;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr for SPI configuration. */ if (Config->MemoryNum == R_SFMA_MEMORY_DUAL) { p_dev->SpiConfig.MemoryNum = R_SFMA_SPIBSC_CMNCR_BSZ_DUAL; } else { p_dev->SpiConfig.MemoryNum = R_SFMA_SPIBSC_CMNCR_BSZ_SINGLE; } if ((Config->DataTransferMode == R_SFMA_SDR_QUAD_IO) || (Config->DataTransferMode == R_SFMA_DDR_QUAD_IO)) { p_dev->SpiConfig.DataWidth = R_SFMA_SPIBSC_4BIT; } else if ((Config->DataTransferMode == R_SFMA_SDR_DUAL_IO) || (Config->DataTransferMode == R_SFMA_DDR_DUAL_IO)) { p_dev->SpiConfig.DataWidth = R_SFMA_SPIBSC_2BIT; } else { p_dev->SpiConfig.DataWidth = R_SFMA_SPIBSC_1BIT; }  if ((Config->DataTransferMode == R_SFMA_DDR_SINGLE_IO) || (Config->DataTransferMode == R_SFMA_DDR_DUAL_IO) || (Config->DataTransferMode == R_SFMA_DDR_QUAD_IO)) { p_dev->SpiConfig.TransferMode = R_SFMA_SPIBSC_DDR_TRANS; } else { p_dev->SpiConfig.TransferMode = R_SFMA_SPIBSC_SDR_TRANS; }  if (Config->AddressMode == R_SFMA_ADDRESS_32BIT) { p_dev->SpiConfig.AddressMode = R_SFMA_SPIBSC_OUTPUT_ADDR_32; } else { p_dev->SpiConfig.AddressMode = R_SFMA_SPIBSC_OUTPUT_ADDR_24; }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Copy flash memory control command. */ p_dev->SpiConfig.PageSize = Config->SerialFlashMemoryPageSize; p_dev->SpiConfig.MaxClock = Config->SerialFlashMemoryMaxClock; p_dev->SpiConfig.EraseSectorSize = Config->SerialFlashMemorySectorSize; p_dev->SpiConfig.Command.ReadSdr = Config->Command->ReadSdr; p_dev->SpiConfig.Command.ReadSdrDual = Config->Command->ReadSdrDual; p_dev->SpiConfig.Command.ReadSdrQuad = Config->Command->ReadSdrQuad; p_dev->SpiConfig.Command.ReadSdrIoDual = Config->Command->ReadSdrIoDual; p_dev->SpiConfig.Command.ReadSdrIoQuad = Config->Command->ReadSdrIoQuad; p_dev->SpiConfig.Command.ReadDdr = Config->Command->ReadDdr; p_dev->SpiConfig.Command.ReadDdrDual = Config->Command->ReadDdrDual; p_dev->SpiConfig.Command.ReadDdrQuad = Config->Command->ReadDdrQuad; p_dev->SpiConfig.Command.ReadDdrIoDual = Config->Command->ReadDdrIoDual; p_dev->SpiConfig.Command.ReadDdrIoQuad = Config->Command->ReadDdrIoQuad; p_dev->SpiConfig.Command.WriteSdr = Config->Command->WriteSdr; p_dev->SpiConfig.Command.WriteSdrDual = Config->Command->WriteSdrDual; p_dev->SpiConfig.Command.WriteSdrQuad = Config->Command->WriteSdrQuad; p_dev->SpiConfig.Command.WriteDdr = Config->Command->WriteDdr; p_dev->SpiConfig.Command.WriteDdrDual = Config->Command->WriteDdrDual; p_dev->SpiConfig.Command.WriteDdrQuad = Config->Command->WriteDdrQuad; p_dev->SpiConfig.Command.WriteEnable = Config->Command->WriteEnable; p_dev->SpiConfig.Command.Erase = Config->Command->Erase; p_dev->SpiConfig.Command.ReadStatus1 = Config->Command->ReadStatus1; p_dev->SpiConfig.Command.ReadStatus2 = Config->Command->ReadStatus2; p_dev->SpiConfig.Command.WriteStatus = Config->Command->WriteStatus; p_dev->SpiConfig.Command.QuadIoMode.Reg = Config->Command->QuadIoMode.Reg; p_dev->SpiConfig.Command.QuadIoMode.BitPosition = Config->Command->QuadIoMode.BitPosition; p_dev->SpiConfig.Command.BlockProtect.Reg = Config->Command->BlockProtect.Reg; p_dev->SpiConfig.Command.BlockProtect.BitPosition = Config->Command->BlockProtect.BitPosition; p_dev->SpiConfig.Command.DummyCycle.Reg = Config->Command->DummyCycle.Reg; p_dev->SpiConfig.Command.DummyCycle.BitMask = Config->Command->DummyCycle.BitMask; p_dev->SpiConfig.Command.DummyCycle.BitSet = Config->Command->DummyCycle.BitSet; p_dev->SpiConfig.Command.WriteInProgress.Reg = Config->Command->WriteInProgress.Reg; p_dev->SpiConfig.Command.WriteInProgress.BitPosition = Config->Command->WriteInProgress.BitPosition; p_dev->SpiConfig.Command.ReadSdrDummyCycle = Config->Command->ReadSdrDummyCycle; p_dev->SpiConfig.Command.ReadSdrIoQuadDummyCycle = Config->Command->ReadSdrIoQuadDummyCycle; p_dev->SpiConfig.Command.ReadSdrIoDualDummyCycle = Config->Command->ReadSdrIoDualDummyCycle; p_dev->SpiConfig.Command.ReadDdrDummyCycle = Config->Command->ReadDdrDummyCycle; p_dev->SpiConfig.Command.ReadDdrIoDualDummyCycle = Config->Command->ReadDdrIoDualDummyCycle; p_dev->SpiConfig.Command.ReadDdrIoQuadDummyCycle = Config->Command->ReadDdrIoQuadDummyCycle; p_dev->SpiConfig.Command.WriteAddressBit = Config->Command->WriteAddressBit; p_dev->SpiConfig.Command.ExitExtAddrSpc = Config->Command->ExitExtAddrSpc; p_dev->SpiConfig.Command.ResetEnable = Config->Command->ResetEnable; p_dev->SpiConfig.Command.Reset = Config->Command->Reset; p_dev->SpiConfig.Command.WriteStatus2 = Config->Command->WriteStatus2; p_dev->SpiConfig.Command.BulkErase = Config->Command->BulkErase;  p_dev->SpiConfig.Cachemode = (uint32_t)Config->CacheMode;  p_dev->SpiConfig.PerformanceEnMode = Config->PerformanceEnMode;  p_dev->SpiConfig.Mode = Config->Mode;  ret_val = R_SFMA_SpibscOpen(Unit, &p_dev->SpiConfig);  if (ret_val == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr update the calibration value */ ret_val = R_SFMA_Sys_CalibSetting(Unit, Config); if (ret_val == R_SFMA_ERR_OK) { loc_sfma_State[Unit] = R_SFMA_STATE_EXECUTING; } } } }  return ret_val; }   /*************************************************************************** Function: R_SFMA_Close  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_Close(const uint32_t Unit) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else { ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_EXECUTING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { ret_val = R_SFMA_SpibscWriteExitExtAddr(Unit, &p_dev->SpiConfig); if (ret_val == R_SFMA_ERR_OK) { ret_val = R_SFMA_SpibscClose(Unit); if (ret_val == R_SFMA_ERR_OK) { loc_sfma_State[Unit] = R_SFMA_STATE_INITIALIZED; } } } } }  return ret_val; }  /*************************************************************************** Function: R_SFMA_AccessAddressSet  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_AccessAddressSet(const uint32_t Unit, const uint64_t Addr, const r_sfma_AccessRange_t Range) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else if ((Addr & R_SFMA_ADDRESS_ALIGNMENT) != 0uL) { ret_val = R_SFMA_ERR_RANGE_PARAM; } else if ((Range != R_SFMA_ACCESS_RANGE_32MB) && (Range != R_SFMA_ACCESS_RANGE_64MB) && (Range != R_SFMA_ACCESS_RANGE_128MB) && (Range != R_SFMA_ACCESS_RANGE_256MB) && (Range != R_SFMA_ACCESS_RANGE_512MB)) { ret_val = R_SFMA_ERR_RANGE_PARAM; } else { p_dev = &loc_sfma_Dev[Unit];  if (Addr >= p_dev->SpiConfig.FlashSize) { ret_val = R_SFMA_ERR_RANGE_PARAM; } else { ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_EXECUTING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != R_SFMA_MODE_EX_SPACE) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { ret_val = R_SFMA_SpibscAccessAddressSet(Unit, Addr, (uint8_t)Range); if (ret_val == R_SFMA_ERR_OK) { p_dev->AccessAddr = Addr; p_dev->AccessRange = Range; } } } } }  return ret_val; }  /*************************************************************************** Function: R_SFMA_AccessAddressGet  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_AccessAddressGet(const uint32_t Unit, uint64_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Addr, r_sfma_AccessRange_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Range) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else if (Addr == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if (Range == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_EXECUTING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != R_SFMA_MODE_EX_SPACE) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { *Addr = p_dev->AccessAddr; *Range = p_dev->AccessRange; } } }  return ret_val; }  /*************************************************************************** Function: R_SFMA_ProtectionModeSet  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_ProtectionModeSet(const uint32_t Unit, const r_sfma_ProtectionMode_t Mode) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev; r_sfma_Req_t req;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else if ((Mode != R_SFMA_MODE_PROTECT) && (Mode != R_SFMA_MODE_UNPROTECT)) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_EXECUTING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != R_SFMA_MODE_SPI_OPERATING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { if (Mode == R_SFMA_MODE_PROTECT) { req = R_SFMA_REQ_PROTECT; } else { req = R_SFMA_REQ_UNPROTECT; }  ret_val = R_SFMA_FlashProtectModeSet(Unit, req, &p_dev->SpiConfig); } } }  return ret_val; }  /*************************************************************************** Function: R_SFMA_DataErase  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_DataErase(const uint32_t Unit, const uint64_t Addr, const int32_t Size) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev; uint64_t erase_sector; uint64_t erase_addr;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else if (Size <= 0) {//size must > 0 ret_val = R_SFMA_ERR_RANGE_PARAM; } else { p_dev = &loc_sfma_Dev[Unit];  if ((Addr + (uint64_t)Size) > p_dev->SpiConfig.FlashSize) {//total size must < max ret_val = R_SFMA_ERR_RANGE_PARAM; } else if (p_dev->SpiConfig.EraseSectorSize == 0) {//sector size must > 0 ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_EXECUTING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != R_SFMA_MODE_SPI_OPERATING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else {//calculate the ersaing size erase_sector = (Addr / p_dev->SpiConfig.EraseSectorSize); erase_addr = (erase_sector r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c p_dev->SpiConfig.EraseSectorSize); while (erase_addr < (Addr + (uint32_t)Size)) { ret_val = R_SFMA_FlashSectorErase(Unit, erase_addr, &p_dev->SpiConfig); if (ret_val == R_SFMA_ERR_OK) { erase_addr += p_dev->SpiConfig.EraseSectorSize; ret_val = R_SFMA_Sys_Relax(Unit); }  if (ret_val != R_SFMA_ERR_OK) { break; } } } } } }  return ret_val; }  /*************************************************************************** Function: R_SFMA_BulkErase  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_BulkErase(const uint32_t Unit) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else { p_dev = &loc_sfma_Dev[Unit];  ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_EXECUTING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != R_SFMA_MODE_SPI_OPERATING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else {  ret_val = R_SFMA_FlashBulkErase(Unit, &p_dev->SpiConfig); } } }  return ret_val; }  /*************************************************************************** Function: R_SFMA_DataWrite  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_DataWrite(const uint32_t Unit, const uint64_t Addr, const uint8_t *Buf, const int32_t Size) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev; int32_t write_size; int32_t remain_size; int32_t relax_size; uint32_t page_size; uint64_t write_addr; uint8_t mode_tmp;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else if (Buf == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { p_dev = &loc_sfma_Dev[Unit];  if (((Addr + (uint64_t)Size) > p_dev->SpiConfig.FlashSize) || (Size <= 0)) { ret_val = R_SFMA_ERR_RANGE_PARAM; } else { if (p_dev->SpiConfig.MemoryNum == R_SFMA_SPIBSC_CMNCR_BSZ_SINGLE) { page_size = p_dev->SpiConfig.PageSize; } else { page_size = (p_dev->SpiConfig.PageSize r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c LOC_SFMA_DUAL); }  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr write address check of page size unit */ if ((Addr % page_size) != 0uL) { ret_val = R_SFMA_ERR_RANGE_PARAM; } else { ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_EXECUTING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != R_SFMA_MODE_SPI_OPERATING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Because there is not a Write command of DDR, change SDR mode */ mode_tmp = p_dev->SpiConfig.TransferMode; p_dev->SpiConfig.TransferMode = R_SFMA_SPIBSC_SDR_TRANS;  remain_size = Size; write_addr = Addr; relax_size = 0; while (remain_size > 0L) { if (remain_size > (int32_t)page_size) { write_size = (int32_t)page_size; } else { write_size = remain_size; }  ret_val = R_SFMA_FlashDataWrite(Unit, write_addr, Buf, write_size, &p_dev->SpiConfig); if (ret_val == R_SFMA_ERR_OK) { remain_size -= write_size; write_addr += (uint32_t)write_size; Buf += write_size; relax_size += write_size;  if (relax_size >= R_SFMA_RELAX_CALL_SIZE) { ret_val = R_SFMA_Sys_Relax(Unit); relax_size = 0; } }  if (ret_val != R_SFMA_ERR_OK) { remain_size = 0; } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr return to original transfer mode setting */ p_dev->SpiConfig.TransferMode = mode_tmp; } } } } }  return ret_val; }  /*************************************************************************** Function: R_SFMA_DataRead  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_DataRead(const uint32_t Unit, const uint64_t Addr, uint8_t *Buf, const int32_t Size) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev; int32_t read_size; int32_t remain_size; uint64_t read_addr;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else if (Buf == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if (Size <= 0) { ret_val = R_SFMA_ERR_RANGE_PARAM; } else { p_dev = &loc_sfma_Dev[Unit]; if ((Addr + (uint64_t)Size) > p_dev->SpiConfig.FlashSize) { ret_val = R_SFMA_ERR_RANGE_PARAM; } else { ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_EXECUTING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != R_SFMA_MODE_SPI_OPERATING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { remain_size = Size; read_addr = Addr; while (remain_size > 0L) { if (remain_size > R_SFMA_RELAX_CALL_SIZE) { read_size = R_SFMA_RELAX_CALL_SIZE; } else { read_size = remain_size; }  ret_val = R_SFMA_FlashDataRead(Unit, read_addr, Buf, read_size, &p_dev->SpiConfig); if (ret_val == R_SFMA_ERR_OK) { remain_size -= read_size; read_addr += (uint32_t)read_size; Buf += read_size;  ret_val = R_SFMA_Sys_Relax(Unit); }  if (ret_val != R_SFMA_ERR_OK) { remain_size = 0; } } } } } }  return ret_val; }  /*************************************************************************** Function: R_SFMA_JEDECRead  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_JEDECRead(const uint32_t Unit, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const ManufacturerID, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const MemoryType, uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Capacity) { r_sfma_Error_t ret_val;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else if (ManufacturerID == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if (MemoryType == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if (Capacity == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Read JEDEC */ ret_val = R_SFMA_SpibscJEDECRead(Unit, ManufacturerID, MemoryType, Capacity); }  return ret_val; }  /*************************************************************************** Function: R_SFMA_VersionStringGet  see: <r_sfma_api.h> */ const uint8_t* R_SFMA_VersionStringGet(void) { static const uint8_t version[] = LOC_SFMA_VERSION;  return version; }  /*************************************************************************** Function: R_SFMA_MacroVersionGet  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_MacroVersionGet(uint32_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Major, uint32_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Minor) { r_sfma_Error_t ret_val = R_SFMA_ERR_OK;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Major == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else if (Minor == R_NULL) { ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { *Major = LOC_SFMA_HW_VERSION_MAJOR; *Minor = LOC_SFMA_HW_VERSION_MINOR; }  return ret_val; }   /*************************************************************************** Function: R_SFMA_GetCal  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_GetCal(const uint32_t Unit, uint32_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c Cal) { r_sfma_Error_t ret_val = R_SFMA_ERR_OK;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr error, invalid value */ *Cal = 0xFFFFFFFFuL; } else { *Cal = R_SFMA_Sys_GetCal(Unit); }  return ret_val; }   /*************************************************************************** Function: R_SFMA_GetStatus  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_GetStatus(const uint32_t Unit,  uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Status1,  uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Status2) { r_sfma_Error_t ret_val = R_SFMA_ERR_OK; r_sfma_Dev_t* p_dev;  p_dev = &loc_sfma_Dev[Unit];  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) {  ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = R_SFMA_SpibscReadStatusRegister(Unit, Status1, Status2, &p_dev->SpiConfig); }  return ret_val; }  /*************************************************************************** Function: R_SFMA_GetConfig  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_GetConfig(const uint32_t Unit,  uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config1,  uint8_t r_sfma_api.c r_sfma_api.h r_sfma_driver_api.h r_sfma_flash.c r_sfma_flash.h r_sfma_iodevice_api.h r_sfma_spibsc.c r_sfma_spibsc.h r_sfma_spibsc_drv.c r_sfma_sys.h sfma_params.h yd_config_sfma.h yd_dev_api.h yd_dev_asm.s yd_sfma_api.c yd_sfma_api.h yd_sfma_flash.c yd_sfma_flash.h yd_sfma_spibsc.c yd_sfma_spibsc.h yd_sfma_spibsc_drv.c yd_sfma_sys.h yd_sys_sfma.c const Config2) { r_sfma_Error_t ret_val = R_SFMA_ERR_OK; r_sfma_Dev_t* p_dev;  p_dev = &loc_sfma_Dev[Unit];  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) {  ret_val = R_SFMA_ERR_PARAM_INCORRECT; } else { ret_val = R_SFMA_SpibscReadConfigRegister(Unit, Config1, Config2, &p_dev->SpiConfig); }  return ret_val; }   /*************************************************************************** Function: R_SFMA_GetConfig  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_WriteStatusConfig(const uint32_t Unit,  uint8_t Status, uint8_t Config) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else { ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_EXECUTING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != R_SFMA_MODE_SPI_OPERATING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { ret_val = R_SFMA_SpibscWriteStatusRegister(Unit, Status, Config, &p_dev->SpiConfig); } } }  return ret_val; }   /*************************************************************************** Function: R_SFMA_WriteReset  see: <r_sfma_api.h> */ r_sfma_Error_t R_SFMA_WriteReset(const uint32_t Unit) { r_sfma_Error_t ret_val; r_sfma_Dev_t* p_dev;  /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Parameter Check */ if (Unit >= R_SFMA_MACRO_NUM) { ret_val = R_SFMA_ERR_RANGE_UNIT; } else { ret_val = R_SFMA_ERR_OK; if (ret_val == R_SFMA_ERR_OK) { p_dev = &loc_sfma_Dev[Unit]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr State Check */ if (loc_sfma_State[Unit] != R_SFMA_STATE_EXECUTING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else if (p_dev->Mode != R_SFMA_MODE_SPI_OPERATING) { ret_val = R_SFMA_ERR_NOT_ACCEPTABLE; } else { ret_val = R_SFMA_SpibscWriteReset(Unit, &p_dev->SpiConfig); } } }  return ret_val; }
