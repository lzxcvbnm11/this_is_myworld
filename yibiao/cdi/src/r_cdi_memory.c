/bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr r_cdi_main.c r_cdi_memory.c r_cdi_rbuffer.c PROJECT : CDI FILE : $Id: r_cdi_memory.c 7682 2016-02-16 13:05:29Z florian.zimmermann $ ============================================================================ DESCRIPTION Common Driver Interface ============================================================================ C O P Y R I G H T ============================================================================ Copyright (c) 2013 - 2014 by Renesas Electronics (Europe) GmbH. Arcadiastrasse 10 D-40472 Duesseldorf Germany All rights reserved. ============================================================================ Purpose: only for testing, not for mass production DISCLAIMER LICENSEE has read, understood and accepted the terms and conditions defined in the license agreement, especially the usage rights. In any case, it is LICENSEE's responsibility to make sure that any user of the software complies with the terms and conditions of the signed license agreement. SAMPLE CODE is not part of the licensed software, as such it must not be used in mass-production applications. It can only be used for evaluation and demonstration purposes at customer's premises listed in the signed license agreement. r_cdi_main.c r_cdi_memory.c r_cdi_rbuffer.c */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Section: Includes */ #include "r_typedefs.h" #include "r_cdi_api.h" #ifdef USE_ROS #include "r_os_api.h" #endif #ifdef MEM_DEBUG #include <stdio.h> #endif /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Section: Local Variables */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Variable: locCpuHeapMng Local CPU heap manager This local variable is initialised once in the function <eeCdi_InitCpuHeapManager> with the given parameters. This function must be called when initialising the hardware. */ static r_cdi_HeapMng_t locCpuHeapMng; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Variable: locVidHeapMng Local video heap manager This local variable is initialised once in the function <eeCdi_InitVidHeapManager> with the given parameters. This function must be called when initialising the hardware. */ static r_cdi_HeapMng_t locVidHeapMng; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Variable: locSpecialModeHeapMng Local SPECIAL_MODE heap manager SPECIAL_MODE is a special type of video memory. It is currently only used in DK4-H (-> VMEM). If you use SPECIAL_MODE, make sure that your device supports this type of memory. This local variable is initialised once in the function <eeCdi_InitSpecialModeHeapManager> with the given parameters. This function must be called when initialising the hardware. */ static r_cdi_HeapMng_t locSpecialModeHeapMng; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Variable: locNextCpuBlockIndex */ static r_cdi_HpBlkIndex_t locNextCpuBlockIndex = 0u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Variable: locNextVidBlockIndex */ static r_cdi_HpBlkIndex_t locNextVidBlockIndex = 0u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Variable: locNextSpecialModeBlockIndex */ static r_cdi_HpBlkIndex_t locNextSpecialModeBlockIndex = 0u; #ifdef USE_ROS static R_OS_ThreadMutex_t locCdiMemLock; #endif static uint32_t locFreeVideoBlocks = 0u; static uint32_t locFreeCPUBlocks = 0u; static uint32_t locFreeSpecialModeBlocks = 0u; static uint32_t locNextCPUFreeBlockNb = 0u; static uint32_t locNextVideoFreeBlockNb = 0u; static uint32_t locNextSpecialModeFreeBlockNb = 0u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Section: Global API Memory Controller Functions */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_InitHeapManager */ uint32_t R_CDI_InitHeapManager( uint32_t HeapAddr, r_cdi_Heap_t *HeapMng, r_cdi_HpBlkIndex_t *HeapIdxList, uint32_t NbBlocks, uint32_t BlkSize) { uint32_t err = 0u; uint32_t index; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr If the pointer HeapIdxList is NULL, then the index list will be placed into the memory whose heap we are initializing just now */ if (0 == HeapIdxList) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr How much memory is required for the HeapIdxList */ const uint32_t HeapIdxListSize = sizeof(r_cdi_HpBlkIndex_t) r_cdi_main.c r_cdi_memory.c r_cdi_rbuffer.c NbBlocks; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Size of the HeapIdxList in terms of Blocks (Rounded UP) */ const uint32_t HeapIdxListSizeBlks = (HeapIdxListSize + (BlkSize-1)) / BlkSize; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Number of Blocks left for normal CDI operation */ const uint32_t NbBlocksInternal = NbBlocks - HeapIdxListSizeBlks; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Starting point of integrated HeapIdxList */ r_cdi_HpBlkIndex_t *HeapIdxListInternal = (r_cdi_HpBlkIndex_t*)(HeapAddr + (BlkSize*NbBlocksInternal)); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Transfer new information to existing variables */ HeapIdxList = HeapIdxListInternal; NbBlocks = NbBlocksInternal; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr test if the pointers different than NULL */ if ((0 != NbBlocks) && (0 != HeapAddr) && ( 0 != HeapIdxList) && ( 0 != HeapMng)) { HeapMng->BaseAddr = HeapAddr; HeapMng->NbOfBlock = NbBlocks; HeapMng->BlockSize = BlkSize; HeapMng->BlockIdxList = HeapIdxList; HeapMng->FreeBlocks = NbBlocks; HeapMng->NextFreeBlockNb = 0u; HeapMng->NextBlockIdx = 0u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Initialise the block list */ for (index = 0u; index < NbBlocks; index++) { *HeapIdxList = 0u; HeapIdxList++; } HeapMng->NextBlockIdx++; } else { err = 1u; } #ifdef USE_ROS R_OS_ThreadMutexInit(&locCdiMemLock, 0); #endif return err; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_InitCpuHeapManager */ uint32_t R_CDI_InitCpuHeapManager( uint32_t hpaddr, r_cdi_HpBlkIndex_t *hpblkindexlist, uint32_t nbblk, uint32_t blksize) { uint32_t err = 0u; uint32_t index; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr test if the pointers different than NULL */ if ((0 != hpaddr) && ( 0 != hpblkindexlist)) { locCpuHeapMng.BaseAddr = hpaddr; locCpuHeapMng.NbOfBlock = nbblk; locCpuHeapMng.BlockSize = blksize; locCpuHeapMng.Type = CPU; locCpuHeapMng.BlockIndexList = hpblkindexlist; locFreeCPUBlocks = nbblk; locNextCPUFreeBlockNb = 0u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Initialise the block list */ for (index = 0u; index < nbblk; index++) { *hpblkindexlist = 0u; hpblkindexlist++; } locNextCpuBlockIndex++; } else { err = 1u; } #ifdef USE_ROS R_OS_ThreadMutexInit(&locCdiMemLock, 0); #endif return err; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_InitVidHeapManager */ uint32_t R_CDI_InitVidHeapManager( uint32_t hpaddr, r_cdi_HpBlkIndex_t r_cdi_main.c r_cdi_memory.c r_cdi_rbuffer.c hpblkindexlist, uint32_t nbblock, uint32_t blksize) { uint32_t err = 0u; uint32_t index; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr test if the pointers different than NULL */ if ((0 != hpaddr) && ( 0 != hpblkindexlist)) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Initialise the heap manager */ locVidHeapMng.BaseAddr = hpaddr; locVidHeapMng.NbOfBlock = nbblock; locVidHeapMng.BlockSize = blksize; locVidHeapMng.Type = VIDEO; locFreeVideoBlocks = nbblock; locNextVideoFreeBlockNb = 0u; locVidHeapMng.BlockIndexList = hpblkindexlist; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Initialise the block list */ for (index = 0u; index < nbblock; index++) { *hpblkindexlist = 0u; hpblkindexlist++; } locNextVidBlockIndex++; } else { err = 1u; } return err; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_InitSmHeapManager */ uint32_t R_CDI_InitSmHeapManager( uint32_t hpaddr, r_cdi_HpBlkIndex_t r_cdi_main.c r_cdi_memory.c r_cdi_rbuffer.c hpblkindexlist, uint32_t nbblock, uint32_t blksize) { uint32_t err = 0u; uint32_t index; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr test if the pointers different than NULL */ if ((0 != hpaddr) && ( 0 != hpblkindexlist)) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Initialise the heap manager */ locSpecialModeHeapMng.BaseAddr = hpaddr; locSpecialModeHeapMng.NbOfBlock = nbblock; locSpecialModeHeapMng.BlockSize = blksize; locSpecialModeHeapMng.Type = SPECIAL_MODE; locFreeSpecialModeBlocks = nbblock; locSpecialModeHeapMng.BlockIndexList = hpblkindexlist; locNextSpecialModeFreeBlockNb = 0u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Initialise the block list */ for (index = 0u; index < nbblock; index++) { *hpblkindexlist = 0u; hpblkindexlist++; } locNextSpecialModeBlockIndex++; } else { err = 1u; } return err; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_HeapAlloc */ uint32_t R_CDI_HeapAlloc(uint32_t size, r_cdi_HpType_t type) { uint32_t addr = 1u; uint32_t allocnbblk = 0u; uint32_t adjfreeblk = 0u; int32_t tmp; uint32_t i; r_cdi_HeapMng_t *lochpmng; r_cdi_HpBlkIndex_t *locblkindexlist; r_cdi_HpBlkIndex_t startblk; r_cdi_HpBlkIndex_t *currentindex; uint32_t *freeCount; uint32_t *nextBlock; uint8_t leave = 0u; r_cdi_HpBlkIndex_t prevBlkIndex = 0; r_cdi_HpBlkIndex_t nextBlkIndex = 0; #ifdef USE_ROS R_OS_ThreadMutexLock(&locCdiMemLock); #endif /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Check memory type and get the pointer to the corresponding heap manager.*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if the type is incorrect then 0 is returned */ if((type == CPU) && (0 != locCpuHeapMng.BaseAddr)) { lochpmng = &locCpuHeapMng; currentindex = &locNextCpuBlockIndex; freeCount = &locFreeCPUBlocks; nextBlock = &locNextCPUFreeBlockNb; } else if((type == SPECIAL_MODE) && (0 != locSpecialModeHeapMng.BaseAddr)) { lochpmng = &locSpecialModeHeapMng; currentindex = &locNextSpecialModeBlockIndex; freeCount = &locFreeSpecialModeBlocks; nextBlock = &locNextSpecialModeFreeBlockNb; } else { if((type == VIDEO) && (0 != locVidHeapMng.BaseAddr) ) { lochpmng = &locVidHeapMng; currentindex = &locNextVidBlockIndex; freeCount = &locFreeVideoBlocks; nextBlock = &locNextVideoFreeBlockNb; } else { addr = 0u; } } if((*freeCount) <= 0) { addr = 0u; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Calculate number of required blocks*/ if (addr != 0u) { tmp = size; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr calculate number of blocks needed*/ while (tmp > 0) { allocnbblk++; tmp -= lochpmng->BlockSize;; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if not enough blocks left */ if((*freeCount) <= allocnbblk) { addr = 0u; } } if(addr != 0u) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Search for n free adjacent blocks */ locblkindexlist = lochpmng->BlockIndexList; addr = 0u; i = *nextBlock; while (i != ((*nextBlock) - 1)) { if (*nextBlock == 0u) { if (i == (lochpmng->NbOfBlock - 1)) { leave = 1u; } } if (0u == leave) { if (*(locblkindexlist + i ) == 0u) { if (adjfreeblk == 0u) { startblk = i; } adjfreeblk++; } else { adjfreeblk = 0u; startblk = 0u; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr When n free adjacent block are found, all blocks' status are set to used */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Start address is then returned */ if (adjfreeblk == allocnbblk) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr If there are blocks before and/or after the current block to be allocated, check their indices and adapt the current block index if necessary. */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We don't need to check for a previous block, if we are at the start of the list */ if (startblk > 0) { prevBlkIndex = *(lochpmng->BlockIndexList + (startblk - 1)); } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We don't need to check for a next block, if we are at the end of the list */ if ((startblk + adjfreeblk) < lochpmng->NbOfBlock) { nextBlkIndex = *(lochpmng->BlockIndexList + (startblk + adjfreeblk)); } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Increment the index to be used for allocation if it is already used by the neighboring blocks */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr This loop will be executed two times at maximum */ while ( ((*currentindex) == prevBlkIndex) || ((*currentindex) == nextBlkIndex) ) { (*currentindex)++; if ( 0 == (*currentindex)) { (*currentindex) = 1; } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Calculate address of allocated memory */ addr = lochpmng->BaseAddr + (startblk r_cdi_main.c r_cdi_memory.c r_cdi_rbuffer.c lochpmng->BlockSize); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr For the blocks that have been found to be free by above searching pass, allocate them for this operation by writing the current block index into them. */ while(adjfreeblk != 0u) { *(lochpmng->BlockIndexList + startblk) = *currentindex; startblk++; adjfreeblk--; (*freeCount)--; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Increment index for next allocation operation. In case of an overflow, set index to 1, as zero is reserved for empty blocks. */ (*currentindex)++; if ( 0 == (*currentindex)) { (*currentindex) = 1; } (*nextBlock) = startblk % lochpmng->NbOfBlock; leave = 1u; } if (0u == leave) { i = (i + 1) % lochpmng->NbOfBlock; if(i == 0u) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr we are back to the beginning of the heap */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr then reset the startblock and the adjfreeblk variable*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We do not want to have an allocation divided between the end and the start of the heap */ adjfreeblk = 0u; startblk = 0u; } } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr end: if (0u == leave)*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr check for break conditions */ if (0 != leave) { break; } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr end: while (i != ((*nextBlock) - 1)) */ } #ifdef MEM_DEBUG /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr debug code to make a breakpoint32_t on out of memory possible */ if(!addr) { if(type==VIDEO) { addr = 0u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr break here */ } } #endif #ifdef USE_ROS R_OS_ThreadMutexUnlock(&locCdiMemLock); #endif return addr; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_Alloc */ void r_cdi_main.c r_cdi_memory.c r_cdi_rbuffer.c R_CDI_Alloc(r_cdi_Heap_t *HeapMng, uint32_t Size) { uint32_t addr = 1u; uint32_t allocNbBlocks = 0u; uint32_t adjfreeblk = 0u; int32_t tmp; uint32_t i; r_cdi_Heap_t *lochpmng; r_cdi_HpBlkIndex_t *locblkindexlist; r_cdi_HpBlkIndex_t startblk; r_cdi_HpBlkIndex_t *currentindex; r_cdi_HpBlkIndex_t *freeCount; r_cdi_HpBlkIndex_t *nextBlock; uint8_t leave = 0u; r_cdi_HpBlkIndex_t prevBlkIndex = 0; r_cdi_HpBlkIndex_t nextBlkIndex = 0; #ifdef USE_ROS R_OS_ThreadMutexLock(&locCdiMemLock); #endif if(0 != HeapMng->BaseAddr) { lochpmng = HeapMng; currentindex = &(HeapMng->NextBlockIdx); freeCount = &(HeapMng->FreeBlocks); nextBlock = &(HeapMng->NextFreeBlockNb); } else { addr = 0u; } if((*freeCount) <= 0) { addr = 0u; } if (0 == Size) { addr = 0u; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Calculate number of required blocks*/ if (addr != 0u) { tmp = Size; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr calculate number of blocks needed*/ while (tmp > 0) { allocNbBlocks++; tmp -= lochpmng->BlockSize; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if not enough blocks left */ if((*freeCount) <= allocNbBlocks) { addr = 0u; } } if(addr != 0u) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Search for n free adjacent blocks */ locblkindexlist = lochpmng->BlockIdxList; addr = 0u; i = *nextBlock; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Search through the block index until we are at the starting point again */ while (i != ((*nextBlock) - 1)) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Special case: When the starting point was zero, stop when we reach the end of the index */ if (*nextBlock == 0u) { if (i == (lochpmng->NbOfBlock - 1)) { leave = 1u; } } if (0u == leave) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr If block index states that the current block is free, take it as starting point */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr With the following iterations, check that the adjacent block are also free */ if (*(locblkindexlist + i ) == 0u) { if (adjfreeblk == 0u) { startblk = i; } adjfreeblk++; } else { adjfreeblk = 0u; startblk = 0u; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr When n free adjacent block are found, all blocks' status are set to used*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Start address is then returned */ if (adjfreeblk == allocNbBlocks) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr If there are blocks before and/or after the current block to be allocated, check their indices and adapt the current block index if necessary. */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We don't need to check for a previous block, if we are at the start of the list */ if (startblk > 0) { prevBlkIndex = *(lochpmng->BlockIdxList + (startblk - 1)); } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We don't need to check for a next block, if we are at the end of the list */ if ((startblk + adjfreeblk) < lochpmng->NbOfBlock) { nextBlkIndex = *(lochpmng->BlockIdxList + (startblk + adjfreeblk)); } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Increment the index to be used for allocation if it is already used by the neighboring blocks */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr This loop will be executed two times at maximum */ while ( ((*currentindex) == prevBlkIndex) || ((*currentindex) == nextBlkIndex) ) { (*currentindex)++; if ( 0 == (*currentindex)) { (*currentindex) = 1; } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Calculate address of allocated memory */ addr = lochpmng->BaseAddr + (startblk r_cdi_main.c r_cdi_memory.c r_cdi_rbuffer.c lochpmng->BlockSize); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Reserve allocated memory in the block index */ while(adjfreeblk != 0u) { *(lochpmng->BlockIdxList + startblk) = *currentindex; startblk++; adjfreeblk--; (*freeCount)--; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Increase the index that uniquely identifies one allocation operation */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr In case of an overflow, set index to 1, as zero is reserved for empty blocks. */ (*currentindex)++; if ( 0 == (*currentindex)) { (*currentindex) = 1; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set next free block number to be directly behind the just allocated memory */ (*nextBlock) = startblk % lochpmng->NbOfBlock; leave = 1u; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Proceed to go through the block index with each iteration */ if (0u == leave) { i = (i + 1) % lochpmng->NbOfBlock; if(i == 0u) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr we are back to the beginning of the heap */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr then reset the startblock and the adjfreeblk variable*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We do not want to have an allocation divided between the end and the start of the heap */ adjfreeblk = 0u; startblk = 0u; } } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if (0u == leave)*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr check for break conditions */ if (0 != leave) { break; } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr while (i != ((*nextBlock) - 1)) */ } #ifdef MEM_DEBUG /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr debug code to make a breakpoint32_t on out of memory possible */ if(!addr) { addr = 0u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr break here */ } #endif #ifdef USE_ROS R_OS_ThreadMutexUnlock(&locCdiMemLock); #endif return (void *)addr; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_AllocAlign */ void r_cdi_main.c r_cdi_memory.c r_cdi_rbuffer.c R_CDI_AllocAlign(r_cdi_Heap_t *HeapMng, uint32_t Size, uint32_t Alignment) { uint32_t addr = 1u; uint32_t allocNbBlocks = 0u; uint32_t adjfreeblk = 0u; int32_t tmp; uint32_t i; uint32_t align = 1u; uint32_t alignOffset = 0u; r_cdi_Heap_t *lochpmng; r_cdi_HpBlkIndex_t *locblkindexlist; r_cdi_HpBlkIndex_t startblk = 0u; r_cdi_HpBlkIndex_t *currentindex; r_cdi_HpBlkIndex_t *freeCount; r_cdi_HpBlkIndex_t *nextBlock; uint8_t leave = 0u; r_cdi_HpBlkIndex_t prevBlkIndex = 0; r_cdi_HpBlkIndex_t nextBlkIndex = 0; #ifdef USE_ROS R_OS_ThreadMutexLock(&locCdiMemLock); #endif if(0 != HeapMng->BaseAddr) { lochpmng = HeapMng; currentindex = &(HeapMng->NextBlockIdx); freeCount = &(HeapMng->FreeBlocks); nextBlock = &(HeapMng->NextFreeBlockNb); } else { addr = 0u; } if((*freeCount) <= 0) { addr = 0u; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Calculate number of required blocks*/ if (addr != 0u) { tmp = Size; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr calculate number of blocks needed*/ while (tmp > 0) { allocNbBlocks++; tmp -= lochpmng->BlockSize; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if not enough blocks left */ if((*freeCount) <= allocNbBlocks) { addr = 0u; } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Calculate alignment of block index number to mathc required alignment */ if (Alignment != 0) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr If <Alignment> is smaller than <BlockSize>, the alignment is given inherently. */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr <Alignment> and <BlockSize> are expected to be powers of two, otherwise a correct alignment might be technically imposssible */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr The requested <Alignment> can be bigger than the alignment of <BaseAddr>. As long as the <BaseAddr> is aligned to <BlockSize>, this function will find an address which is aligned to the system's address space. */ if (Alignment >= lochpmng->BlockSize) { uint32_t virtualIndex; align = Alignment / lochpmng->BlockSize; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr What "virtual index" would the first block of our index list have if we started counting at the address 0x00000000 ? */ virtualIndex = lochpmng->BaseAddr / lochpmng->BlockSize; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr If the virtual index is not a multiple of our alignment <align>, we need to add an offset. */ alignOffset = (virtualIndex % align); } } if(addr != 0u) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Search for n free adjacent blocks */ locblkindexlist = lochpmng->BlockIdxList; addr = 0u; i = *nextBlock; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Search through the block index until we are at the starting point again */ while (i != ((*nextBlock) - 1)) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Special case: When the starting point was zero, stop when we reach the end of the index */ if (*nextBlock == 0u) { if (i == (lochpmng->NbOfBlock - 1)) { leave = 1u; } } if (0u == leave) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr If block index states that the current block is free, take it as starting point */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr With the following iterations, check that the adjacent block are also free */ if (*(locblkindexlist + i ) == 0u) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Only take it as a starting point if it matches our alignment requirement */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr .. or if a starting point was already found */ if ((startblk != 0) || (((i+alignOffset) % align) == 0u)) { if (adjfreeblk == 0u) { startblk = i; } adjfreeblk++; } } else { adjfreeblk = 0u; startblk = 0u; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr When n free adjacent block are found, all blocks' status are set to used*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Start address is then returned */ if (adjfreeblk == allocNbBlocks) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr If there are blocks before and/or after the current block to be allocated, check their indices and adapt the current block index if necessary. */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We don't need to check for a previous block, if we are at the start of the list */ if (startblk > 0) { prevBlkIndex = *(lochpmng->BlockIdxList + (startblk - 1)); } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We don't need to check for a next block, if we are at the end of the list */ if ((startblk + adjfreeblk) < lochpmng->NbOfBlock) { nextBlkIndex = *(lochpmng->BlockIdxList + (startblk + adjfreeblk)); } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Increment the index to be used for allocation if it is already used by the neighboring blocks */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr This loop will be executed two times at maximum */ while ( ((*currentindex) == prevBlkIndex) || ((*currentindex) == nextBlkIndex) ) { (*currentindex)++; if ( 0 == (*currentindex)) { (*currentindex) = 1; } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Calculate address of allocated memory */ addr = lochpmng->BaseAddr + (startblk r_cdi_main.c r_cdi_memory.c r_cdi_rbuffer.c lochpmng->BlockSize); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Reserve allocated memory in the block index */ while(adjfreeblk != 0u) { *(lochpmng->BlockIdxList + startblk) = *currentindex; startblk++; adjfreeblk--; (*freeCount)--; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Increase the index that uniquely identifies one allocation operation */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr In case of an overflow, set index to 1, as zero is reserved for empty blocks. */ (*currentindex)++; if ( 0 == (*currentindex)) { (*currentindex) = 1; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Set next free block number to be directly behind the just allocated memory */ (*nextBlock) = startblk % lochpmng->NbOfBlock; leave = 1u; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Proceed to go through the block index with each iteration */ if (0u == leave) { i = (i + 1) % lochpmng->NbOfBlock; if(i == 0u) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr we are back to the beginning of the heap */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr then reset the startblock and the adjfreeblk variable*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr We do not want to have an allocation divided between the end and the start of the heap */ adjfreeblk = 0u; startblk = 0u; } } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if (0u == leave)*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr check for break conditions */ if (0 != leave) { break; } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr while (i != ((*nextBlock) - 1)) */ } #ifdef MEM_DEBUG /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr debug code to make a breakpoint on out of memory possible */ if(!addr) { addr = 0u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr break here */ } #endif #ifdef USE_ROS R_OS_ThreadMutexUnlock(&locCdiMemLock); #endif return (void *)addr; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_HeapResetNextFreeBlockNb */ uint32_t R_CDI_HeapResetNextFreeBlockNb(r_cdi_HpType_t type) { uint32_t err = 0u; switch (type) { case CPU: locNextCPUFreeBlockNb = 1u; break; case SPECIAL_MODE: locNextSpecialModeFreeBlockNb = 1u; break; case VIDEO: locNextVideoFreeBlockNb = 1u; break; default: err = 1u; break; } return err; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_Free */ uint32_t R_CDI_Free(uint32_t Addr, r_cdi_Heap_t *HeapMng) { uint32_t i; uint32_t err = 0u; int32_t blknb; r_cdi_Heap_t *lochpmng; r_cdi_HpBlkIndex_t *locblkindexlist; r_cdi_HpBlkIndex_t blkindex; r_cdi_HpBlkIndex_t *freeCount; r_cdi_HpBlkIndex_t *nextBlock; #ifdef USE_ROS R_OS_ThreadMutexLock(&locCdiMemLock); #endif if(Addr != 0u) { lochpmng = HeapMng; freeCount = &(HeapMng->FreeBlocks); nextBlock = &(HeapMng->NextFreeBlockNb); /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Calculate block number from addr */ blknb = (Addr - (lochpmng->BaseAddr)) / (lochpmng->BlockSize); locblkindexlist = lochpmng->BlockIdxList; blkindex = locblkindexlist[blknb]; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr If this memory manager is used in an environment, where the pointer of the allocated memory are aligned upwards outside of the CDI, the resulting pointer might leaved the first block of several that are assigned to this allocation operation. */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr In such an environment, the "Free" routine must first seach the lowest index number with the same Block ID before starting the cleanup. */ if(Addr < lochpmng->BaseAddr) { err = 2u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr address is below managed range of this Heap */ } else if (Addr >= (lochpmng->BaseAddr + (lochpmng->BlockSize*lochpmng->NbOfBlock))) { err = 2u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr address is above managed range of this Heap */ } else if (blkindex == 0u) { err = 2u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr already free */ } else { (*nextBlock) = blknb; i = blknb; while (locblkindexlist[i] == blkindex) { locblkindexlist[i] = 0u; i++; (*freeCount)++; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Stop deallocation if we leave the range of the block index list */ if (i>lochpmng->NbOfBlock) { break; } } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Reset block index to zero, if all blocks are deallocated */ if (lochpmng->NbOfBlock == HeapMng->FreeBlocks) { HeapMng->NextFreeBlockNb = 0u; } } } #ifdef USE_ROS R_OS_ThreadMutexUnlock(&locCdiMemLock); #endif return err; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_HeapFree */ uint32_t R_CDI_HeapFree(uint32_t addr, r_cdi_HpType_t type) { uint32_t i, vidsize; uint32_t err = 0u; int32_t blknb; r_cdi_HeapMng_t *lochpmng; r_cdi_HpBlkIndex_t *locblkindexlist; r_cdi_HpBlkIndex_t blkindex; uint32_t *freeCount; uint32_t *nextBlock; #ifdef USE_ROS R_OS_ThreadMutexLock(&locCdiMemLock); #endif if(addr != 0u) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Check memory type and get the pointer to the corresponding heap manager.*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if the type is incorrect then 1 is returned */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Have to add check on addr, because if short in CPU memory Video is allocated*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr No other way to know it... */ vidsize = locVidHeapMng.BlockSize*locVidHeapMng.NbOfBlock; if((type == VIDEO) || ((addr >= locVidHeapMng.BaseAddr) && (addr < (locVidHeapMng.BaseAddr + vidsize)))) { lochpmng = &locVidHeapMng; freeCount = &locFreeVideoBlocks; nextBlock = &locNextVideoFreeBlockNb; } else if(type == SPECIAL_MODE) { lochpmng = &locSpecialModeHeapMng; freeCount = &locFreeSpecialModeBlocks; nextBlock = &locNextSpecialModeFreeBlockNb; } else { if(type == CPU) { lochpmng = &locCpuHeapMng; freeCount = &locFreeCPUBlocks; nextBlock = &locNextCPUFreeBlockNb; } else { err = 1u; } } if (err == 0u) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Calculate block number from addr */ blknb = (addr - (lochpmng->BaseAddr)) / (lochpmng->BlockSize); locblkindexlist = lochpmng->BlockIndexList; blkindex = locblkindexlist[blknb]; if(addr < lochpmng->BaseAddr) { err = 2u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr address is below managed range of this Heap */ } else if (addr >= (lochpmng->BaseAddr + (lochpmng->BlockSize*lochpmng->NbOfBlock))) { err = 2u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr address is above managed range of this Heap */ } else if (blkindex == 0u) { err = 2u; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr already free */ } else { if((*nextBlock)> (uint32_t)blknb) { (*nextBlock) = blknb; } i = blknb; while (locblkindexlist[i] == blkindex) { locblkindexlist[i] = 0u; i++; (*freeCount)++; /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Stop deallocation if we leave the range of the block index list */ if (i>lochpmng->NbOfBlock) { break; } } } } } #ifdef USE_ROS R_OS_ThreadMutexUnlock(&locCdiMemLock); #endif return err; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_HeapFreeAll */ uint32_t R_CDI_HeapFreeAll(r_cdi_HpType_t type) { uint32_t err = 0u; int32_t tmp; r_cdi_HeapMng_t *lochpmng; r_cdi_HpBlkIndex_t *locblkindexlist; #ifdef USE_ROS R_OS_ThreadMutexLock(&locCdiMemLock); #endif /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Check memory type and get the pointer to the corresponding heap manager.*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if the type is incorrect then 1 is returned */ if(type == CPU) { lochpmng = &locCpuHeapMng; locNextCpuBlockIndex = 1u; } else if(type == SPECIAL_MODE) { lochpmng = &locSpecialModeHeapMng; locNextSpecialModeBlockIndex = 1u; } else { if(type == VIDEO) { lochpmng = &locVidHeapMng; locNextVidBlockIndex = 1u; } else { err = 1u; } } if (err == 0u) { locblkindexlist = lochpmng->BlockIndexList; tmp = lochpmng->NbOfBlock - 1; while(tmp >= 0) { locblkindexlist[tmp] = 0u; tmp--; } } #ifdef USE_ROS R_OS_ThreadMutexUnlock(&locCdiMemLock); #endif return err; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_GetHeapSize */ uint32_t R_CDI_GetHeapSize(uint32_t addr, r_cdi_HpType_t type) { uint32_t i; uint32_t size = 0u; uint32_t blknb; uint32_t vidsize; r_cdi_HeapMng_t *lochpmng; r_cdi_HpBlkIndex_t *locblkindexlist; r_cdi_HpBlkIndex_t blkindex; #ifdef USE_ROS R_OS_ThreadMutexLock(&locCdiMemLock); #endif /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Check memory type and get the pointer to the corresponding heap manager.*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if the type is incorrect then 1 is returned */ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Have to add check on addr, because if short in CPU memory Video is allocated*/ /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr No other way to know it... */ vidsize = locVidHeapMng.BlockSize*locVidHeapMng.NbOfBlock; if((type == VIDEO) || ((addr >= locVidHeapMng.BaseAddr) && (addr < (locVidHeapMng.BaseAddr + vidsize)))) { lochpmng = &locVidHeapMng; } else { if(type == CPU) { lochpmng = &locCpuHeapMng; } else { if(type == SPECIAL_MODE) { lochpmng = &locSpecialModeHeapMng; } else { lochpmng = 0u; } } } if (0 != lochpmng) { /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Calculate block number from addr */ blknb = (addr - (lochpmng->BaseAddr)) / (lochpmng->BlockSize); locblkindexlist = lochpmng->BlockIndexList; blkindex = locblkindexlist[blknb]; i = blknb; while (locblkindexlist[i] == blkindex) { size += lochpmng->BlockSize; i++; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr if no match found, then return size = 0 */ } #ifdef USE_ROS R_OS_ThreadMutexUnlock(&locCdiMemLock); #endif return size; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_GetVidHeapBlockSize */ uint32_t R_CDI_GetVidHeapBlockSize(void) { return locVidHeapMng.BlockSize; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_GetVidHeapBlockMax */ uint32_t R_CDI_GetVidHeapBlockMax(void) { return locVidHeapMng.NbOfBlock; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_GetVidHeapBlockUsed */ uint32_t R_CDI_GetVidHeapBlockUsed(void) { return (locVidHeapMng.NbOfBlock-locFreeVideoBlocks); } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_GetCpuHeapBlockSize */ uint32_t R_CDI_GetCpuHeapBlockSize(void) { return locCpuHeapMng.BlockSize; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_GetCpuHeapBlockMax */ uint32_t R_CDI_GetCpuHeapBlockMax(void) { return locCpuHeapMng.NbOfBlock; } /bin /cmd /dev /etc /git-bash.exe /git-cmd.exe /LICENSE.txt /mingw64 /proc /ReleaseNotes.html /tmp /unins000.dat /unins000.exe /unins000.msg /usr Function: R_CDI_GetCpuHeapBlockUsed */ uint32_t R_CDI_GetCpuHeapBlockUsed(void) { return (locCpuHeapMng.NbOfBlock-locFreeCPUBlocks); }
